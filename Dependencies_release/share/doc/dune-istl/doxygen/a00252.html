<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>dune-istl: Dune Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">dune-istl
   &#160;<span id="projectnumber">2.8.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Dune Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:a00267"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00267.html">Amg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00258"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00258.html">CounterImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00260"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00260.html">ForEach</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00261"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00261.html">ILU</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00254"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00254.html">ISTL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00263"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00263.html">MatrixImp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00264"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00264.html">MatrixMarketImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00268"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00268.html">Metis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01087.html">exists</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01091.html">DefaultAllocatorTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01095.html">DefaultAllocatorTraits&lt; T, std::void_t&lt; typename T::allocator_type &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01099.html">AllocatorTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01123.html">OverlappingSchwarzInitializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer for <a class="el" href="a02839.html" title="SuperLu Solver.">SuperLU</a> Matrices representing the subdomains.  <a href="a01123.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01139.html">MatrixDimension</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01143.html">CompressionStatistics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistics about compression achieved in implicit mode.  <a href="a01143.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01147.html">ImplicitMatrixBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for uniform access to the <a class="el" href="a01155.html" title="A sparse block matrix with compressed row storage.">BCRSMatrix</a> during and after the build stage in implicit build mode.  <a href="a01147.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html">BCRSMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sparse block matrix with compressed row storage.  <a href="a01155.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01171.html">BDMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A block-diagonal matrix.  <a href="a01171.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01175.html">MultiTypeBlockVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Vector class to support different block types.  <a href="a01175.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01179.html">MultiTypeBlockMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="a01451.html" title="A generic dynamic dense matrix.">Matrix</a> class to support different block types.  <a href="a01179.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01215.html">BTDMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A block-tridiagonal matrix.  <a href="a01215.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01239.html">BlockVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of blocks with memory management.  <a href="a01239.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01243.html">FieldTraits&lt; BlockVector&lt; B, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>AutonomousValueType&lt; Imp::BlockVectorWindow&lt; B, A &gt; &gt;</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the proxies of <code>BlockVectorWindow</code> <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01263.html">ColCompMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sparse matrix in compressed-column format.  <a href="a01263.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01279.html">ArPackPlusPlus_Algorithms</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to use a range of ARPACK++ eigenvalue solvers.  <a href="a01279.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01291.html">PowerIteration_Algorithms</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterative eigenvalue algorithms based on power iteration.  <a href="a01291.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01311.html">BL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">compile-time parameter for block recursion depth  <a href="a01311.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01315.html">algmeta_btsolve</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01319.html">algmeta_btsolve&lt; 0, withdiag, withrelax &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01323.html">algmeta_btsolve&lt; 0, withdiag, norelax &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01327.html">algmeta_btsolve&lt; 0, nodiag, withrelax &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01331.html">algmeta_btsolve&lt; 0, nodiag, norelax &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01335.html">algmeta_bdsolve</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01339.html">algmeta_bdsolve&lt; 0, withrelax &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01343.html">algmeta_bdsolve&lt; 0, norelax &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01347.html">algmeta_itsteps</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01351.html">algmeta_itsteps&lt; 0, M &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01355.html">algmeta_itsteps&lt; I, MultiTypeBlockMatrix&lt; T1, MultiTypeMatrixArgs... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01363.html">ILUSubdomainSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class encapsulating common algorithms of <a class="el" href="a01367.html" title="Exact subdomain solver using ILU(p) with appropriate p.">ILU0SubdomainSolver</a> and <a class="el" href="a01371.html">ILUNSubdomainSolver</a>.  <a href="a01363.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01367.html">ILU0SubdomainSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exact subdomain solver using ILU(p) with appropriate p.  <a href="a01367.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01371.html">ILUNSubdomainSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01383.html">ISTLError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">derive error class from the base class in common  <a href="a01383.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01387.html">BCRSMatrixError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error specific to <a class="el" href="a01155.html" title="A sparse block matrix with compressed row storage.">BCRSMatrix</a>.  <a href="a01387.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01391.html">ImplicitModeCompressionBufferExhausted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown when the compression buffer used by the implicit <a class="el" href="a01155.html" title="A sparse block matrix with compressed row storage.">BCRSMatrix</a> construction is exhausted.  <a href="a01391.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01395.html">SolverAbort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown when a solver aborts due to some problem.  <a href="a01395.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01399.html">MatrixBlockError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error when performing an operation on a matrix block.  <a href="a01399.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html">SeqOverlappingSchwarz</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequential overlapping Schwarz preconditioner.  <a href="a01403.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01407.html">SeqOverlappingSchwarzAssemblerHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01411.html">LDL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the LDL package to directly solve linear systems &ndash; empty default class.  <a href="a01411.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01415.html">LDL&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, A &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LDL direct sparse solver for matrices of type <a class="el" href="a01155.html" title="A sparse block matrix with compressed row storage.">BCRSMatrix</a>.  <a href="a01415.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01419.html">IsDirectSolver&lt; LDL&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, A &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01423.html">StoresColumnCompressed&lt; LDL&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, A &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01427.html">LDLCreator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01451.html">Matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic dynamic dense matrix.  <a href="a01451.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01455.html">MatrixIndexSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the nonzero entries in a sparse matrix.  <a href="a01455.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01579.html">MatrixMarketFormatError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01651.html">MatMultMatResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper TMP to get the result type of a sparse matrix matrix multiplication ( <img class="formulaInl" alt="$C=A*B$" src="form_29.png"/>)  <a href="a01651.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01655.html">MatMultMatResult&lt; FieldMatrix&lt; T, n, k &gt;, FieldMatrix&lt; T, k, m &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01659.html">MatMultMatResult&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, k &gt;, A &gt;, BCRSMatrix&lt; FieldMatrix&lt; T, k, m &gt;, A1 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01663.html">TransposedMatMultMatResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper TMP to get the result type of a sparse matrix matrix multiplication ( <img class="formulaInl" alt="$C=A*B$" src="form_29.png"/>)  <a href="a01663.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01667.html">TransposedMatMultMatResult&lt; FieldMatrix&lt; T, k, n &gt;, FieldMatrix&lt; T, k, m &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01671.html">TransposedMatMultMatResult&lt; BCRSMatrix&lt; FieldMatrix&lt; T, k, n &gt;, A &gt;, BCRSMatrix&lt; FieldMatrix&lt; T, k, m &gt;, A1 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01675.html">RedistributeInformation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01679.html">RedistributeInformation&lt; OwnerOverlapCopyCommunication&lt; T, T1 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01683.html">CommMatrixRowSize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to communicate and set the row sizes of a redistributed matrix.  <a href="a01683.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01687.html">CommMatrixSparsityPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to communicate and build the sparsity pattern of a redistributed matrix.  <a href="a01687.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01691.html">CommPolicy&lt; CommMatrixSparsityPattern&lt; M, I &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01695.html">CommMatrixRow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for comunicating the matrix entries.  <a href="a01695.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01699.html">CommPolicy&lt; CommMatrixRow&lt; M, I &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01703.html">MatrixRowSizeGatherScatter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01707.html">MatrixCopyRowSizeGatherScatter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01711.html">MatrixSparsityPatternGatherScatter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01715.html">MatrixRowGatherScatter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01719.html">FieldMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01723.html">CheckIfDiagonalPresent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the a matrix has diagonal values on blocklevel recursion levels.  <a href="a01723.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01727.html">CheckIfDiagonalPresent&lt; Matrix, 0, l &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01731.html">CheckIfDiagonalPresent&lt; MultiTypeBlockMatrix&lt; T1, Args... &gt;, blocklevel, l &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01739.html">MatrixDimension&lt; Matrix&lt; B, TA &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01743.html">MatrixDimension&lt; BCRSMatrix&lt; B, TA &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01747.html">MatrixDimension&lt; BCRSMatrix&lt; FieldMatrix&lt; B, n, m &gt;, TA &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01751.html">MatrixDimension&lt; FieldMatrix&lt; K, n, m &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01755.html">MatrixDimension&lt; Dune::DynamicMatrix&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01759.html">MatrixDimension&lt; Matrix&lt; FieldMatrix&lt; K, n, m &gt;, TA &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01763.html">MatrixDimension&lt; DiagonalMatrix&lt; K, n &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01767.html">MatrixDimension&lt; ScaledIdentityMatrix&lt; K, n &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01771.html">IsMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether a type is an <a class="el" href="a00254.html">ISTL</a> <a class="el" href="a01451.html" title="A generic dynamic dense matrix.">Matrix</a>.  <a href="a01771.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01775.html">IsMatrix&lt; DenseMatrix&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01779.html">IsMatrix&lt; BCRSMatrix&lt; T, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01783.html">PointerCompare</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01787.html">MultiTypeBlockMatrix_Solver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">solver for <a class="el" href="a01175.html" title="A Vector class to support different block types.">MultiTypeBlockVector</a> &amp; <a class="el" href="a01179.html" title="A Matrix class to support different block types.">MultiTypeBlockMatrix</a> types  <a href="a01787.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01791.html">MultiTypeBlockMatrix_Solver_Col</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">part of solvers for <a class="el" href="a01175.html" title="A Vector class to support different block types.">MultiTypeBlockVector</a> &amp; <a class="el" href="a01179.html" title="A Matrix class to support different block types.">MultiTypeBlockMatrix</a> types  <a href="a01791.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01795.html">MultiTypeBlockMatrix_Solver_Col&lt; I, crow, ccol, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01799.html">MultiTypeBlockMatrix_Solver&lt; I, crow, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01803.html">FieldTraits&lt; MultiTypeBlockVector&lt; Arg0, Args... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01807.html">NonoverlappingSchwarzOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A nonoverlapping operator with communication object.  <a href="a01807.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01815.html">NonoverlappingBlockPreconditioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nonoverlapping parallel preconditioner.  <a href="a01815.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01819.html">LinearOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linear operator.  <a href="a01819.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01823.html">AssembledLinearOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linear operator exporting itself in matrix form.  <a href="a01823.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01827.html">MatrixAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapter to turn a matrix into a linear operator.  <a href="a01827.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01835.html">AdditiveSchwarzMode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag that the tells the Schwarz method to be additive.  <a href="a01835.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01839.html">MultiplicativeSchwarzMode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag that tells the Schwarz method to be multiplicative.  <a href="a01839.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01843.html">SymmetricMultiplicativeSchwarzMode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag that tells the Schwarz method to be multiplicative and symmetric.  <a href="a01843.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01847.html">DynamicMatrixSubdomainSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exact subdomain solver using Dune::DynamicMatrix&lt;T&gt;::solve.  <a href="a01847.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01851.html">DynamicMatrixSubdomainSolver&lt; BCRSMatrix&lt; K, Al &gt;, X, Y &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01855.html">OverlappingAssignerHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01859.html">OverlappingAssignerHelper&lt; DynamicMatrixSubdomainSolver&lt; BCRSMatrix&lt; K, Al &gt;, X, Y &gt;, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01863.html">OverlappingAssignerHelper&lt; S&lt; BCRSMatrix&lt; T, A &gt; &gt;, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01867.html">OverlappingAssignerILUBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01871.html">OverlappingAssignerHelper&lt; ILU0SubdomainSolver&lt; M, X, Y &gt;, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01875.html">OverlappingAssignerHelper&lt; ILUNSubdomainSolver&lt; M, X, Y &gt;, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01879.html">AdditiveAdder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01883.html">AdditiveAdder&lt; S, BlockVector&lt; T, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01887.html">MultiplicativeAdder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01891.html">MultiplicativeAdder&lt; S, BlockVector&lt; T, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01895.html">AdderSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">template meta program for choosing how to add the correction.  <a href="a01895.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01899.html">AdderSelector&lt; AdditiveSchwarzMode, X, S &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01903.html">AdderSelector&lt; MultiplicativeSchwarzMode, X, S &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01907.html">AdderSelector&lt; SymmetricMultiplicativeSchwarzMode, X, S &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01911.html">IteratorDirectionSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template meta program for application of overlapping Schwarz.  <a href="a01911.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01915.html">IteratorDirectionSelector&lt; T1, T2, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01919.html">SeqOverlappingSchwarzApplier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template meta program for application of overlapping Schwarz.  <a href="a01919.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01923.html">SeqOverlappingSchwarzApplier&lt; SeqOverlappingSchwarz&lt; M, X, SymmetricMultiplicativeSchwarzMode, TD, TA &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01927.html">SeqOverlappingSchwarzAssemblerHelper&lt; DynamicMatrixSubdomainSolver&lt; BCRSMatrix&lt; K, Al &gt;, X, Y &gt;, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01931.html">SeqOverlappingSchwarzAssemblerHelper&lt; S&lt; BCRSMatrix&lt; T, A &gt; &gt;, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01935.html">SeqOverlappingSchwarzAssemblerILUBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01939.html">SeqOverlappingSchwarzAssemblerHelper&lt; ILU0SubdomainSolver&lt; M, X, Y &gt;, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01943.html">SeqOverlappingSchwarzAssemblerHelper&lt; ILUNSubdomainSolver&lt; M, X, Y &gt;, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01947.html">SeqOverlappingSchwarzDomainSize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01951.html">SeqOverlappingSchwarzDomainSize&lt; BCRSMatrix&lt; T, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01955.html">OwnerOverlapCopyAttributeSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute set for overlapping Schwarz.  <a href="a01955.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01959.html">IndexInfoFromGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about the index distribution.  <a href="a01959.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01963.html">OwnerOverlapCopyCommunication</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class setting up standard communication for a two-valued attribute set with owner/overlap/copy semantics.  <a href="a01963.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02103.html">AMGCreator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02143.html">OverlappingSchwarzOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An overlapping Schwarz operator.  <a href="a02143.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02183.html">PropertyMapTypeSelector&lt; Amg::VertexVisitedTag, Amg::PropertiesGraph&lt; G, Amg::VertexProperties, EP, VM, EM &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02275.html">CommPolicy&lt; Amg::GlobalAggregatesMap&lt; T, TI &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02583.html">Preconditioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for matrix free definition of preconditioners.  <a href="a02583.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02587.html">InverseOperator2Preconditioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns an <a class="el" href="a02679.html" title="Abstract base class for all solvers.">InverseOperator</a> into a <a class="el" href="a02583.html" title="Base class for matrix free definition of preconditioners.">Preconditioner</a>.  <a href="a02587.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02591.html">SeqSSOR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequential SSOR preconditioner.  <a href="a02591.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02595.html">SeqSOR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequential SOR preconditioner.  <a href="a02595.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02599.html">SeqJac</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sequential jacobian preconditioner.  <a href="a02599.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02603.html">SeqILU</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequential <a class="el" href="a00261.html">ILU</a> preconditioner.  <a href="a02603.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02607.html">Richardson</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a02607.html" title="Richardson preconditioner.">Richardson</a> preconditioner.  <a href="a02607.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02611.html">SeqILDL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">sequential ILDL preconditioner  <a href="a02611.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02619.html">RedistributeInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02639.html">ScalarProduct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for scalar product and norm computation.  <a href="a02639.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02643.html">ParallelScalarProduct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar product for overlapping Schwarz methods.  <a href="a02643.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02647.html">SeqScalarProduct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation for the scalar case.  <a href="a02647.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02651.html">NonoverlappingSchwarzScalarProduct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nonoverlapping Scalar Product with communication object.  <a href="a02651.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02655.html">OverlappingSchwarzScalarProduct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar product for overlapping Schwarz methods.  <a href="a02655.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02659.html">ScaledIdentityMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multiple of the identity matrix of static size.  <a href="a02659.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02663.html">DenseMatrixAssigner&lt; DenseMatrix, ScaledIdentityMatrix&lt; field, N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02667.html">ParSSOR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A parallel SSOR preconditioner.  <a href="a02667.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02671.html">BlockPreconditioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block parallel preconditioner.  <a href="a02671.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02675.html">InverseOperatorResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistics about the application of an inverse operator.  <a href="a02675.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02679.html">InverseOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for all solvers.  <a href="a02679.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02683.html">IterativeSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all implementations of iterative solvers.  <a href="a02683.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02691.html">SolverHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for notifying a DUNE-ISTL linear solver about a change of the iteration matrix object in a unified way, i.e. independent from the solver's type (direct/iterative).  <a href="a02691.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02703.html">SolverCategory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Categories for the solvers.  <a href="a02703.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02707.html">InvalidSolverCategory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02711.html">SolverFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to assembly solvers configured by a <code>ParameterTree</code>.  <a href="a02711.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02727.html">UnsupportedType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02731.html">InvalidSolverFactoryConfiguration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02735.html">LoopSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preconditioned loop solver.  <a href="a02735.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02739.html">GradientSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">gradient method  <a href="a02739.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02743.html">CGSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">conjugate gradient method  <a href="a02743.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02747.html">BiCGSTABSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bi-conjugate Gradient Stabilized (BiCG-STAB)  <a href="a02747.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02751.html">MINRESSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimal Residual Method (MINRES)  <a href="a02751.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02755.html">RestartedGMResSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">implements the Generalized Minimal Residual (GMRes) method  <a href="a02755.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02759.html">RestartedFlexibleGMResSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">implements the Flexible Generalized Minimal Residual (FGMRes) method (right preconditioned)  <a href="a02759.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02763.html">GeneralizedPCGSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generalized preconditioned conjugate gradient solver.  <a href="a02763.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02767.html">RestartedFCGSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accelerated flexible conjugate gradient method.  <a href="a02767.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02771.html">CompleteFCGSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete flexible conjugate gradient method.  <a href="a02771.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02775.html">IsDirectSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02779.html">StoresColumnCompressed</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02783.html">SPQR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the SPQR package to directly solve linear systems &ndash; empty default class.  <a href="a02783.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02787.html">SPQR&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, A &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SPQR direct sparse solver for matrices of type <a class="el" href="a01155.html" title="A sparse block matrix with compressed row storage.">BCRSMatrix</a>.  <a href="a02787.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02791.html">IsDirectSolver&lt; SPQR&lt; BCRSMatrix&lt; T, A &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02795.html">StoresColumnCompressed&lt; SPQR&lt; BCRSMatrix&lt; T, A &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02799.html">SPQRCreator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02811.html">SuperLUSolveChooser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02815.html">SuperLUDenseMatChooser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02819.html">SuperLUQueryChooser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02823.html">QuerySpaceChooser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02839.html">SuperLU</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SuperLu Solver.  <a href="a02839.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02843.html">IsDirectSolver&lt; SuperLU&lt; BCRSMatrix&lt; T, A &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02847.html">StoresColumnCompressed&lt; SuperLU&lt; BCRSMatrix&lt; T, A &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02851.html">SuperLUCreator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02875.html">SuperMatrixCreateSparseChooser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02879.html">SuperMatrixPrinter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02883.html">BaseGetSuperLUType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02887.html">GetSuperLUType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02891.html">GetSuperLUType&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02895.html">GetSuperLUType&lt; float &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02899.html">GetSuperLUType&lt; std::complex&lt; double &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02903.html">GetSuperLUType&lt; std::complex&lt; float &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02907.html">SuperLUMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for converting an <a class="el" href="a00254.html">ISTL</a> <a class="el" href="a01451.html" title="A generic dynamic dense matrix.">Matrix</a> into a <a class="el" href="a02839.html" title="SuperLu Solver.">SuperLU</a> <a class="el" href="a01451.html" title="A generic dynamic dense matrix.">Matrix</a>.  <a href="a02907.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02911.html">SuperMatrixInitializer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02915.html">SuperLUMatrix&lt; BCRSMatrix&lt; B, TA &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converter for <a class="el" href="a01155.html" title="A sparse block matrix with compressed row storage.">BCRSMatrix</a> to <a class="el" href="a02839.html" title="SuperLu Solver.">SuperLU</a> <a class="el" href="a01451.html" title="A generic dynamic dense matrix.">Matrix</a>.  <a href="a02915.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02919.html">SuperMatrixInitializer&lt; BCRSMatrix&lt; B, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02923.html">UMFPackMethodChooser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02927.html">UMFPackMethodChooser&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02931.html">UMFPackMethodChooser&lt; std::complex&lt; double &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02947.html">UMFPack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The UMFPack direct sparse solver.  <a href="a02947.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02951.html">IsDirectSolver&lt; UMFPack&lt; BCRSMatrix&lt; FieldMatrix&lt; T, n, m &gt;, A &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02955.html">StoresColumnCompressed&lt; UMFPack&lt; BCRSMatrix&lt; T, A &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02959.html">UMFPackCreator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02971.html">VariableBlockVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Vector of blocks with different blocksizes.  <a href="a02971.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9ab4e8c72359591b27aede17f5ec6615"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9ab4e8c72359591b27aede17f5ec6615"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00252.html#a9ab4e8c72359591b27aede17f5ec6615">AllocatorType</a> = typename <a class="el" href="a01099.html">AllocatorTraits</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a9ab4e8c72359591b27aede17f5ec6615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9020314eeb58ec32f6fab5ef0c196674"><td class="memTemplParams" colspan="2">template&lt;typename T , typename X &gt; </td></tr>
<tr class="memitem:a9020314eeb58ec32f6fab5ef0c196674"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00252.html#a9020314eeb58ec32f6fab5ef0c196674">ReboundAllocatorType</a> = typename std::allocator_traits&lt; typename <a class="el" href="a01099.html">AllocatorTraits</a>&lt; T &gt;::type &gt;::template rebind_alloc&lt; X &gt;</td></tr>
<tr class="separator:a9020314eeb58ec32f6fab5ef0c196674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31a901b8fb8394865710949d0b466149"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00236.html#ga31a901b8fb8394865710949d0b466149">ImplicitModeOverflowExhausted</a> = <a class="el" href="a01391.html">ImplicitModeCompressionBufferExhausted</a></td></tr>
<tr class="memdesc:ga31a901b8fb8394865710949d0b466149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for backward compatibility.  <a href="a00236.html#ga31a901b8fb8394865710949d0b466149">More...</a><br /></td></tr>
<tr class="separator:ga31a901b8fb8394865710949d0b466149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57430ed63b8d6900976df9950af0a0bb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga57430ed63b8d6900976df9950af0a0bb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00245.html#ga57430ed63b8d6900976df9950af0a0bb">OverlappingAssigner</a> = <a class="el" href="a01855.html">OverlappingAssignerHelper</a>&lt; T, <a class="el" href="a02779.html">Dune::StoresColumnCompressed</a>&lt; T &gt;::value &gt;</td></tr>
<tr class="separator:ga57430ed63b8d6900976df9950af0a0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a5d6fa4ec6f65757b49ed7fe09e15e2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga5a5d6fa4ec6f65757b49ed7fe09e15e2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00245.html#ga5a5d6fa4ec6f65757b49ed7fe09e15e2">SeqOverlappingSchwarzAssembler</a> = <a class="el" href="a01407.html">SeqOverlappingSchwarzAssemblerHelper</a>&lt; T, <a class="el" href="a02779.html">Dune::StoresColumnCompressed</a>&lt; T &gt;::value &gt;</td></tr>
<tr class="separator:ga5a5d6fa4ec6f65757b49ed7fe09e15e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf04e8521e43d7b1c8fdb3a412210b36d"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , int l = 1&gt; </td></tr>
<tr class="memitem:gaf04e8521e43d7b1c8fdb3a412210b36d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00245.html#gaf04e8521e43d7b1c8fdb3a412210b36d">SeqGS</a> = <a class="el" href="a02595.html">SeqSOR</a>&lt; M, X, Y, l &gt;</td></tr>
<tr class="memdesc:gaf04e8521e43d7b1c8fdb3a412210b36d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequential Gauss Seidel preconditioner.  <a href="a00245.html#gaf04e8521e43d7b1c8fdb3a412210b36d">More...</a><br /></td></tr>
<tr class="separator:gaf04e8521e43d7b1c8fdb3a412210b36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91168438e4b9a921333311a3a08798dc"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y &gt; </td></tr>
<tr class="memitem:ga91168438e4b9a921333311a3a08798dc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00250.html#ga91168438e4b9a921333311a3a08798dc">DirectSolverSignature</a> = std::shared_ptr&lt; <a class="el" href="a02679.html">InverseOperator</a>&lt; X, Y &gt; &gt;(const M &amp;, const ParameterTree &amp;)</td></tr>
<tr class="separator:ga91168438e4b9a921333311a3a08798dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ed393ca70204435e43fe1d993d94146"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y &gt; </td></tr>
<tr class="memitem:ga4ed393ca70204435e43fe1d993d94146"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00250.html#ga4ed393ca70204435e43fe1d993d94146">DirectSolverFactory</a> = Singleton&lt; ParameterizedObjectFactory&lt; <a class="el" href="a00250.html#ga91168438e4b9a921333311a3a08798dc">DirectSolverSignature</a>&lt; M, X, Y &gt; &gt;&gt;</td></tr>
<tr class="separator:ga4ed393ca70204435e43fe1d993d94146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae55f25267d1fd33e3ca7d1626e0c2309"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y &gt; </td></tr>
<tr class="memitem:gae55f25267d1fd33e3ca7d1626e0c2309"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00250.html#gae55f25267d1fd33e3ca7d1626e0c2309">PreconditionerSignature</a> = std::shared_ptr&lt; <a class="el" href="a02583.html">Preconditioner</a>&lt; X, Y &gt; &gt;(const std::shared_ptr&lt; M &gt; &amp;, const ParameterTree &amp;)</td></tr>
<tr class="separator:gae55f25267d1fd33e3ca7d1626e0c2309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3331f94d4529c3668c246bb292d8616c"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y &gt; </td></tr>
<tr class="memitem:ga3331f94d4529c3668c246bb292d8616c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00250.html#ga3331f94d4529c3668c246bb292d8616c">PreconditionerFactory</a> = Singleton&lt; ParameterizedObjectFactory&lt; <a class="el" href="a00250.html#gae55f25267d1fd33e3ca7d1626e0c2309">PreconditionerSignature</a>&lt; M, X, Y &gt; &gt;&gt;</td></tr>
<tr class="separator:ga3331f94d4529c3668c246bb292d8616c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f1eb86d7953f95ba7cbc5e7364533fa"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:ga4f1eb86d7953f95ba7cbc5e7364533fa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00250.html#ga4f1eb86d7953f95ba7cbc5e7364533fa">IterativeSolverSignature</a> = std::shared_ptr&lt; <a class="el" href="a02679.html">InverseOperator</a>&lt; X, Y &gt; &gt;(const std::shared_ptr&lt; <a class="el" href="a01819.html">LinearOperator</a>&lt; X, Y &gt; &gt; &amp;, const std::shared_ptr&lt; <a class="el" href="a02639.html">ScalarProduct</a>&lt; X &gt; &gt; &amp;, const std::shared_ptr&lt; <a class="el" href="a02583.html">Preconditioner</a>&lt; X, Y &gt; &gt;, const ParameterTree &amp;)</td></tr>
<tr class="separator:ga4f1eb86d7953f95ba7cbc5e7364533fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab390de02beef7edaa843bf24ffbe10b7"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:gab390de02beef7edaa843bf24ffbe10b7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00250.html#gab390de02beef7edaa843bf24ffbe10b7">IterativeSolverFactory</a> = Singleton&lt; ParameterizedObjectFactory&lt; <a class="el" href="a00250.html#ga4f1eb86d7953f95ba7cbc5e7364533fa">IterativeSolverSignature</a>&lt; X, Y &gt; &gt;&gt;</td></tr>
<tr class="separator:gab390de02beef7edaa843bf24ffbe10b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga1d016a8baf2c49b7cf2f4381ac26dae8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00248.html#ga1d016a8baf2c49b7cf2f4381ac26dae8">WithDiagType</a> { <a class="el" href="a00248.html#gga1d016a8baf2c49b7cf2f4381ac26dae8aeee05f0dca4c1c766073efa5a0ce1864">withdiag</a> =1
, <a class="el" href="a00248.html#gga1d016a8baf2c49b7cf2f4381ac26dae8a2797146c0f86bb2e64d5dcdd09af49fa">nodiag</a> =0
 }</td></tr>
<tr class="separator:ga1d016a8baf2c49b7cf2f4381ac26dae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d35e02d27a4916c1ba6435f0c2d6ea8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00248.html#ga8d35e02d27a4916c1ba6435f0c2d6ea8">WithRelaxType</a> { <a class="el" href="a00248.html#gga8d35e02d27a4916c1ba6435f0c2d6ea8a6275e2591067a32a12c32074ae56a4ab">withrelax</a> =1
, <a class="el" href="a00248.html#gga8d35e02d27a4916c1ba6435f0c2d6ea8a4fcdb30f993f475659d8e031aff47b80">norelax</a> =0
 }</td></tr>
<tr class="separator:ga8d35e02d27a4916c1ba6435f0c2d6ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a33fa4c0298cf146aa9589b519344907f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a33fa4c0298cf146aa9589b519344907f"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00252.html#a33fa4c0298cf146aa9589b519344907f">maxBlockLevel</a> ()</td></tr>
<tr class="memdesc:a33fa4c0298cf146aa9589b519344907f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the maximum block level of a possibly nested vector/matrix type.  <a href="a00252.html#a33fa4c0298cf146aa9589b519344907f">More...</a><br /></td></tr>
<tr class="separator:a33fa4c0298cf146aa9589b519344907f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a728a69e20c62c789c9e4b616208d6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a93a728a69e20c62c789c9e4b616208d6"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00252.html#a93a728a69e20c62c789c9e4b616208d6">minBlockLevel</a> ()</td></tr>
<tr class="memdesc:a93a728a69e20c62c789c9e4b616208d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the minimum block level of a possibly nested vector/matrix type.  <a href="a00252.html#a93a728a69e20c62c789c9e4b616208d6">More...</a><br /></td></tr>
<tr class="separator:a93a728a69e20c62c789c9e4b616208d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d487fafa117ba8beb053d1c3417dee1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2d487fafa117ba8beb053d1c3417dee1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00252.html#a2d487fafa117ba8beb053d1c3417dee1">hasUniqueBlockLevel</a> ()</td></tr>
<tr class="memdesc:a2d487fafa117ba8beb053d1c3417dee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a vector/matrix has a uniquely determinable block level.  <a href="a00252.html#a2d487fafa117ba8beb053d1c3417dee1">More...</a><br /></td></tr>
<tr class="separator:a2d487fafa117ba8beb053d1c3417dee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477c671e3966936ca929dee4be2dcf95"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a477c671e3966936ca929dee4be2dcf95"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00252.html#a477c671e3966936ca929dee4be2dcf95">blockLevel</a> ()</td></tr>
<tr class="memdesc:a477c671e3966936ca929dee4be2dcf95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the block level of a possibly nested vector/matrix type.  <a href="a00252.html#a477c671e3966936ca929dee4be2dcf95">More...</a><br /></td></tr>
<tr class="separator:a477c671e3966936ca929dee4be2dcf95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6c22497a84e2ec8803ba78a7e2e988"><td class="memTemplParams" colspan="2">template&lt;class K , class A &gt; </td></tr>
<tr class="memitem:a2d6c22497a84e2ec8803ba78a7e2e988"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00252.html#a2d6c22497a84e2ec8803ba78a7e2e988">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="a01239.html">BlockVector</a>&lt; K, A &gt; &amp;v)</td></tr>
<tr class="memdesc:a2d6c22497a84e2ec8803ba78a7e2e988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send <a class="el" href="a01239.html" title="A vector of blocks with memory management.">BlockVector</a> to an output stream.  <a href="a00252.html#a2d6c22497a84e2ec8803ba78a7e2e988">More...</a><br /></td></tr>
<tr class="separator:a2d6c22497a84e2ec8803ba78a7e2e988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a87108c26ee37e7e43de1e8b15e4e67"><td class="memTemplParams" colspan="2">template&lt;class Vector , class F &gt; </td></tr>
<tr class="memitem:a7a87108c26ee37e7e43de1e8b15e4e67"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00252.html#a7a87108c26ee37e7e43de1e8b15e4e67">flatVectorForEach</a> (Vector &amp;&amp;vector, F &amp;&amp;f, std::size_t offset=0)</td></tr>
<tr class="memdesc:a7a87108c26ee37e7e43de1e8b15e4e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse a blocked vector and call a functor at each scalar entry.  <a href="a00252.html#a7a87108c26ee37e7e43de1e8b15e4e67">More...</a><br /></td></tr>
<tr class="separator:a7a87108c26ee37e7e43de1e8b15e4e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f3b70931de2f8f81b08a30865a17c2"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class F &gt; </td></tr>
<tr class="memitem:af2f3b70931de2f8f81b08a30865a17c2"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::size_t, std::size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00252.html#af2f3b70931de2f8f81b08a30865a17c2">flatMatrixForEach</a> (<a class="el" href="a01451.html">Matrix</a> &amp;&amp;matrix, F &amp;&amp;f, std::size_t rowOffset=0, std::size_t colOffset=0)</td></tr>
<tr class="memdesc:af2f3b70931de2f8f81b08a30865a17c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse a blocked matrix and call a functor at each scalar entry.  <a href="a00252.html#af2f3b70931de2f8f81b08a30865a17c2">More...</a><br /></td></tr>
<tr class="separator:af2f3b70931de2f8f81b08a30865a17c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f053fd0407ed1cc4bddd149fb6fb8ca"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y &gt; </td></tr>
<tr class="memitem:ga0f053fd0407ed1cc4bddd149fb6fb8ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00248.html#ga0f053fd0407ed1cc4bddd149fb6fb8ca">bltsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d)</td></tr>
<tr class="memdesc:ga0f053fd0407ed1cc4bddd149fb6fb8ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">block lower triangular solve  <a href="a00248.html#ga0f053fd0407ed1cc4bddd149fb6fb8ca">More...</a><br /></td></tr>
<tr class="separator:ga0f053fd0407ed1cc4bddd149fb6fb8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf814921e91eff2665f6faf02f5f2077f"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class K &gt; </td></tr>
<tr class="memitem:gaf814921e91eff2665f6faf02f5f2077f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00248.html#gaf814921e91eff2665f6faf02f5f2077f">bltsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d, const K &amp;w)</td></tr>
<tr class="memdesc:gaf814921e91eff2665f6faf02f5f2077f"><td class="mdescLeft">&#160;</td><td class="mdescRight">relaxed block lower triangular solve  <a href="a00248.html#gaf814921e91eff2665f6faf02f5f2077f">More...</a><br /></td></tr>
<tr class="separator:gaf814921e91eff2665f6faf02f5f2077f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44f4aa6e2cf4928911a3f5d1de3044d5"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y &gt; </td></tr>
<tr class="memitem:ga44f4aa6e2cf4928911a3f5d1de3044d5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00248.html#ga44f4aa6e2cf4928911a3f5d1de3044d5">ubltsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d)</td></tr>
<tr class="memdesc:ga44f4aa6e2cf4928911a3f5d1de3044d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">unit block lower triangular solve  <a href="a00248.html#ga44f4aa6e2cf4928911a3f5d1de3044d5">More...</a><br /></td></tr>
<tr class="separator:ga44f4aa6e2cf4928911a3f5d1de3044d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccddb305f448a410d5092fc19e65fde7"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class K &gt; </td></tr>
<tr class="memitem:gaccddb305f448a410d5092fc19e65fde7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00248.html#gaccddb305f448a410d5092fc19e65fde7">ubltsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d, const K &amp;w)</td></tr>
<tr class="memdesc:gaccddb305f448a410d5092fc19e65fde7"><td class="mdescLeft">&#160;</td><td class="mdescRight">relaxed unit block lower triangular solve  <a href="a00248.html#gaccddb305f448a410d5092fc19e65fde7">More...</a><br /></td></tr>
<tr class="separator:gaccddb305f448a410d5092fc19e65fde7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae258e10601de666271f1fc70365acaaf"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y &gt; </td></tr>
<tr class="memitem:gae258e10601de666271f1fc70365acaaf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00248.html#gae258e10601de666271f1fc70365acaaf">butsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d)</td></tr>
<tr class="memdesc:gae258e10601de666271f1fc70365acaaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">block upper triangular solve  <a href="a00248.html#gae258e10601de666271f1fc70365acaaf">More...</a><br /></td></tr>
<tr class="separator:gae258e10601de666271f1fc70365acaaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83b10b12a29ea2971cf8176d641b830f"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class K &gt; </td></tr>
<tr class="memitem:ga83b10b12a29ea2971cf8176d641b830f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00248.html#ga83b10b12a29ea2971cf8176d641b830f">butsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d, const K &amp;w)</td></tr>
<tr class="memdesc:ga83b10b12a29ea2971cf8176d641b830f"><td class="mdescLeft">&#160;</td><td class="mdescRight">relaxed block upper triangular solve  <a href="a00248.html#ga83b10b12a29ea2971cf8176d641b830f">More...</a><br /></td></tr>
<tr class="separator:ga83b10b12a29ea2971cf8176d641b830f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff15f888a81d558e39b36ac74fea2e42"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y &gt; </td></tr>
<tr class="memitem:gaff15f888a81d558e39b36ac74fea2e42"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00248.html#gaff15f888a81d558e39b36ac74fea2e42">ubutsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d)</td></tr>
<tr class="memdesc:gaff15f888a81d558e39b36ac74fea2e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">unit block upper triangular solve  <a href="a00248.html#gaff15f888a81d558e39b36ac74fea2e42">More...</a><br /></td></tr>
<tr class="separator:gaff15f888a81d558e39b36ac74fea2e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6559fd0a70f600ab376dd2083d8cb0dd"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class K &gt; </td></tr>
<tr class="memitem:ga6559fd0a70f600ab376dd2083d8cb0dd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00248.html#ga6559fd0a70f600ab376dd2083d8cb0dd">ubutsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d, const K &amp;w)</td></tr>
<tr class="memdesc:ga6559fd0a70f600ab376dd2083d8cb0dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">relaxed unit block upper triangular solve  <a href="a00248.html#ga6559fd0a70f600ab376dd2083d8cb0dd">More...</a><br /></td></tr>
<tr class="separator:ga6559fd0a70f600ab376dd2083d8cb0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c2d3410df660b6891f6a1eedafd49f6"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , int l&gt; </td></tr>
<tr class="memitem:ga8c2d3410df660b6891f6a1eedafd49f6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00248.html#ga8c2d3410df660b6891f6a1eedafd49f6">bltsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d, <a class="el" href="a01311.html">BL</a>&lt; l &gt;)</td></tr>
<tr class="memdesc:ga8c2d3410df660b6891f6a1eedafd49f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">block lower triangular solve  <a href="a00248.html#ga8c2d3410df660b6891f6a1eedafd49f6">More...</a><br /></td></tr>
<tr class="separator:ga8c2d3410df660b6891f6a1eedafd49f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d84c99a51fe0795b06b825a13538852"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class K , int l&gt; </td></tr>
<tr class="memitem:ga9d84c99a51fe0795b06b825a13538852"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00248.html#ga9d84c99a51fe0795b06b825a13538852">bltsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d, const K &amp;w, <a class="el" href="a01311.html">BL</a>&lt; l &gt;)</td></tr>
<tr class="memdesc:ga9d84c99a51fe0795b06b825a13538852"><td class="mdescLeft">&#160;</td><td class="mdescRight">relaxed block lower triangular solve  <a href="a00248.html#ga9d84c99a51fe0795b06b825a13538852">More...</a><br /></td></tr>
<tr class="separator:ga9d84c99a51fe0795b06b825a13538852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga112a6621ef260e4b265a0df07fede1be"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , int l&gt; </td></tr>
<tr class="memitem:ga112a6621ef260e4b265a0df07fede1be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00248.html#ga112a6621ef260e4b265a0df07fede1be">ubltsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d, <a class="el" href="a01311.html">BL</a>&lt; l &gt;)</td></tr>
<tr class="memdesc:ga112a6621ef260e4b265a0df07fede1be"><td class="mdescLeft">&#160;</td><td class="mdescRight">unit block lower triangular solve  <a href="a00248.html#ga112a6621ef260e4b265a0df07fede1be">More...</a><br /></td></tr>
<tr class="separator:ga112a6621ef260e4b265a0df07fede1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29094b87e08482d955ab1b4f731678fd"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class K , int l&gt; </td></tr>
<tr class="memitem:ga29094b87e08482d955ab1b4f731678fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00248.html#ga29094b87e08482d955ab1b4f731678fd">ubltsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d, const K &amp;w, <a class="el" href="a01311.html">BL</a>&lt; l &gt;)</td></tr>
<tr class="memdesc:ga29094b87e08482d955ab1b4f731678fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">relaxed unit block lower triangular solve  <a href="a00248.html#ga29094b87e08482d955ab1b4f731678fd">More...</a><br /></td></tr>
<tr class="separator:ga29094b87e08482d955ab1b4f731678fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ab5372aabac8f03a77f50227b611fd8"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , int l&gt; </td></tr>
<tr class="memitem:ga1ab5372aabac8f03a77f50227b611fd8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00248.html#ga1ab5372aabac8f03a77f50227b611fd8">butsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d, <a class="el" href="a01311.html">BL</a>&lt; l &gt; bl)</td></tr>
<tr class="memdesc:ga1ab5372aabac8f03a77f50227b611fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">block upper triangular solve  <a href="a00248.html#ga1ab5372aabac8f03a77f50227b611fd8">More...</a><br /></td></tr>
<tr class="separator:ga1ab5372aabac8f03a77f50227b611fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaed21180843947bd0efef18d54038998"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class K , int l&gt; </td></tr>
<tr class="memitem:gaaed21180843947bd0efef18d54038998"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00248.html#gaaed21180843947bd0efef18d54038998">butsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d, const K &amp;w, <a class="el" href="a01311.html">BL</a>&lt; l &gt; bl)</td></tr>
<tr class="memdesc:gaaed21180843947bd0efef18d54038998"><td class="mdescLeft">&#160;</td><td class="mdescRight">relaxed block upper triangular solve  <a href="a00248.html#gaaed21180843947bd0efef18d54038998">More...</a><br /></td></tr>
<tr class="separator:gaaed21180843947bd0efef18d54038998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00c2e6cbce34cf6d04e94567a48bb13c"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , int l&gt; </td></tr>
<tr class="memitem:ga00c2e6cbce34cf6d04e94567a48bb13c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00248.html#ga00c2e6cbce34cf6d04e94567a48bb13c">ubutsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d, <a class="el" href="a01311.html">BL</a>&lt; l &gt; bl)</td></tr>
<tr class="memdesc:ga00c2e6cbce34cf6d04e94567a48bb13c"><td class="mdescLeft">&#160;</td><td class="mdescRight">unit block upper triangular solve  <a href="a00248.html#ga00c2e6cbce34cf6d04e94567a48bb13c">More...</a><br /></td></tr>
<tr class="separator:ga00c2e6cbce34cf6d04e94567a48bb13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89e9f76f178486c9ded34ed26f367bc4"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class K , int l&gt; </td></tr>
<tr class="memitem:ga89e9f76f178486c9ded34ed26f367bc4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00248.html#ga89e9f76f178486c9ded34ed26f367bc4">ubutsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d, const K &amp;w, <a class="el" href="a01311.html">BL</a>&lt; l &gt; bl)</td></tr>
<tr class="memdesc:ga89e9f76f178486c9ded34ed26f367bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">relaxed unit block upper triangular solve  <a href="a00248.html#ga89e9f76f178486c9ded34ed26f367bc4">More...</a><br /></td></tr>
<tr class="separator:ga89e9f76f178486c9ded34ed26f367bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab20f25b7927dae733827e729fc3c25f7"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y &gt; </td></tr>
<tr class="memitem:gab20f25b7927dae733827e729fc3c25f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00248.html#gab20f25b7927dae733827e729fc3c25f7">bdsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d)</td></tr>
<tr class="memdesc:gab20f25b7927dae733827e729fc3c25f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">block diagonal solve, no relaxation  <a href="a00248.html#gab20f25b7927dae733827e729fc3c25f7">More...</a><br /></td></tr>
<tr class="separator:gab20f25b7927dae733827e729fc3c25f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab158b39f3ee085609cbae90a0cf6a5fb"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class K &gt; </td></tr>
<tr class="memitem:gab158b39f3ee085609cbae90a0cf6a5fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00248.html#gab158b39f3ee085609cbae90a0cf6a5fb">bdsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d, const K &amp;w)</td></tr>
<tr class="memdesc:gab158b39f3ee085609cbae90a0cf6a5fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">block diagonal solve, with relaxation  <a href="a00248.html#gab158b39f3ee085609cbae90a0cf6a5fb">More...</a><br /></td></tr>
<tr class="separator:gab158b39f3ee085609cbae90a0cf6a5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d7f687712467b7651d62ea0712aa5a3"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , int l&gt; </td></tr>
<tr class="memitem:ga7d7f687712467b7651d62ea0712aa5a3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00248.html#ga7d7f687712467b7651d62ea0712aa5a3">bdsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d, <a class="el" href="a01311.html">BL</a>&lt; l &gt;)</td></tr>
<tr class="memdesc:ga7d7f687712467b7651d62ea0712aa5a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">block diagonal solve, no relaxation  <a href="a00248.html#ga7d7f687712467b7651d62ea0712aa5a3">More...</a><br /></td></tr>
<tr class="separator:ga7d7f687712467b7651d62ea0712aa5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac245a72ffeecc409c7d242c6841738a9"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class K , int l&gt; </td></tr>
<tr class="memitem:gac245a72ffeecc409c7d242c6841738a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00248.html#gac245a72ffeecc409c7d242c6841738a9">bdsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d, const K &amp;w, <a class="el" href="a01311.html">BL</a>&lt; l &gt;)</td></tr>
<tr class="memdesc:gac245a72ffeecc409c7d242c6841738a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">block diagonal solve, with relaxation  <a href="a00248.html#gac245a72ffeecc409c7d242c6841738a9">More...</a><br /></td></tr>
<tr class="separator:gac245a72ffeecc409c7d242c6841738a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bec8914ff3d25fb86ddffef6e38677d"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class K &gt; </td></tr>
<tr class="memitem:ga5bec8914ff3d25fb86ddffef6e38677d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00248.html#ga5bec8914ff3d25fb86ddffef6e38677d">dbgs</a> (const M &amp;A, X &amp;x, const Y &amp;b, const K &amp;w)</td></tr>
<tr class="memdesc:ga5bec8914ff3d25fb86ddffef6e38677d"><td class="mdescLeft">&#160;</td><td class="mdescRight">GS step.  <a href="a00248.html#ga5bec8914ff3d25fb86ddffef6e38677d">More...</a><br /></td></tr>
<tr class="separator:ga5bec8914ff3d25fb86ddffef6e38677d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70ff88e446d2bb3927e2ae963292d02b"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class K , int l&gt; </td></tr>
<tr class="memitem:ga70ff88e446d2bb3927e2ae963292d02b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00248.html#ga70ff88e446d2bb3927e2ae963292d02b">dbgs</a> (const M &amp;A, X &amp;x, const Y &amp;b, const K &amp;w, <a class="el" href="a01311.html">BL</a>&lt; l &gt;)</td></tr>
<tr class="memdesc:ga70ff88e446d2bb3927e2ae963292d02b"><td class="mdescLeft">&#160;</td><td class="mdescRight">GS step.  <a href="a00248.html#ga70ff88e446d2bb3927e2ae963292d02b">More...</a><br /></td></tr>
<tr class="separator:ga70ff88e446d2bb3927e2ae963292d02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2caef773a37fd65ee1fa76ee0a95c47"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class K &gt; </td></tr>
<tr class="memitem:gaf2caef773a37fd65ee1fa76ee0a95c47"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00248.html#gaf2caef773a37fd65ee1fa76ee0a95c47">bsorf</a> (const M &amp;A, X &amp;x, const Y &amp;b, const K &amp;w)</td></tr>
<tr class="memdesc:gaf2caef773a37fd65ee1fa76ee0a95c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">SOR step.  <a href="a00248.html#gaf2caef773a37fd65ee1fa76ee0a95c47">More...</a><br /></td></tr>
<tr class="separator:gaf2caef773a37fd65ee1fa76ee0a95c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65105d18c5a743d1739179e696f5c022"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class K , int l&gt; </td></tr>
<tr class="memitem:ga65105d18c5a743d1739179e696f5c022"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00248.html#ga65105d18c5a743d1739179e696f5c022">bsorf</a> (const M &amp;A, X &amp;x, const Y &amp;b, const K &amp;w, <a class="el" href="a01311.html">BL</a>&lt; l &gt;)</td></tr>
<tr class="memdesc:ga65105d18c5a743d1739179e696f5c022"><td class="mdescLeft">&#160;</td><td class="mdescRight">SOR step.  <a href="a00248.html#ga65105d18c5a743d1739179e696f5c022">More...</a><br /></td></tr>
<tr class="separator:ga65105d18c5a743d1739179e696f5c022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a70747a68e23231ab6cb72b396942ec"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class K &gt; </td></tr>
<tr class="memitem:ga3a70747a68e23231ab6cb72b396942ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00248.html#ga3a70747a68e23231ab6cb72b396942ec">bsorb</a> (const M &amp;A, X &amp;x, const Y &amp;b, const K &amp;w)</td></tr>
<tr class="memdesc:ga3a70747a68e23231ab6cb72b396942ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">SSOR step.  <a href="a00248.html#ga3a70747a68e23231ab6cb72b396942ec">More...</a><br /></td></tr>
<tr class="separator:ga3a70747a68e23231ab6cb72b396942ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdb801f4a4aea1201bc09d32b202042a"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class K , int l&gt; </td></tr>
<tr class="memitem:gabdb801f4a4aea1201bc09d32b202042a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00248.html#gabdb801f4a4aea1201bc09d32b202042a">bsorb</a> (const M &amp;A, X &amp;x, const Y &amp;b, const K &amp;w, <a class="el" href="a01311.html">BL</a>&lt; l &gt;)</td></tr>
<tr class="memdesc:gabdb801f4a4aea1201bc09d32b202042a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backward SOR step.  <a href="a00248.html#gabdb801f4a4aea1201bc09d32b202042a">More...</a><br /></td></tr>
<tr class="separator:gabdb801f4a4aea1201bc09d32b202042a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51ae0ff4aea09b29d3f31ae2f6dfacc5"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class K &gt; </td></tr>
<tr class="memitem:ga51ae0ff4aea09b29d3f31ae2f6dfacc5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00248.html#ga51ae0ff4aea09b29d3f31ae2f6dfacc5">dbjac</a> (const M &amp;A, X &amp;x, const Y &amp;b, const K &amp;w)</td></tr>
<tr class="memdesc:ga51ae0ff4aea09b29d3f31ae2f6dfacc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Jacobi step.  <a href="a00248.html#ga51ae0ff4aea09b29d3f31ae2f6dfacc5">More...</a><br /></td></tr>
<tr class="separator:ga51ae0ff4aea09b29d3f31ae2f6dfacc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6642a19372a5ec5f405ce8cc56515596"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class K , int l&gt; </td></tr>
<tr class="memitem:ga6642a19372a5ec5f405ce8cc56515596"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00248.html#ga6642a19372a5ec5f405ce8cc56515596">dbjac</a> (const M &amp;A, X &amp;x, const Y &amp;b, const K &amp;w, <a class="el" href="a01311.html">BL</a>&lt; l &gt;)</td></tr>
<tr class="memdesc:ga6642a19372a5ec5f405ce8cc56515596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Jacobi step.  <a href="a00248.html#ga6642a19372a5ec5f405ce8cc56515596">More...</a><br /></td></tr>
<tr class="separator:ga6642a19372a5ec5f405ce8cc56515596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8de6b1951fa7f95a3e9f89973579115"><td class="memTemplParams" colspan="2">template&lt;class K , int m, int n&gt; </td></tr>
<tr class="memitem:af8de6b1951fa7f95a3e9f89973579115"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00252.html#af8de6b1951fa7f95a3e9f89973579115">bildl_subtractBCT</a> (const <a class="el" href="a01719.html">FieldMatrix</a>&lt; K, m, n &gt; &amp;B, const <a class="el" href="a01719.html">FieldMatrix</a>&lt; K, m, n &gt; &amp;CT, <a class="el" href="a01719.html">FieldMatrix</a>&lt; K, m, n &gt; &amp;A)</td></tr>
<tr class="separator:af8de6b1951fa7f95a3e9f89973579115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f5c61e1bb13aaae63f8229ca8fcf17"><td class="memTemplParams" colspan="2">template&lt;class K &gt; </td></tr>
<tr class="memitem:ad3f5c61e1bb13aaae63f8229ca8fcf17"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00252.html#ad3f5c61e1bb13aaae63f8229ca8fcf17">bildl_subtractBCT</a> (const K &amp;B, const K &amp;CT, K &amp;A, typename std::enable_if_t&lt; Dune::IsNumber&lt; K &gt;::value &gt; *sfinae=nullptr)</td></tr>
<tr class="separator:ad3f5c61e1bb13aaae63f8229ca8fcf17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a3af34e2b0e78906f8ac136b8a77b9"><td class="memTemplParams" colspan="2">template&lt;class Matrix &gt; </td></tr>
<tr class="memitem:ab8a3af34e2b0e78906f8ac136b8a77b9"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00252.html#ab8a3af34e2b0e78906f8ac136b8a77b9">bildl_subtractBCT</a> (const <a class="el" href="a01451.html">Matrix</a> &amp;B, const <a class="el" href="a01451.html">Matrix</a> &amp;CT, <a class="el" href="a01451.html">Matrix</a> &amp;A, typename std::enable_if_t&lt;!Dune::IsNumber&lt; <a class="el" href="a01451.html">Matrix</a> &gt;::value &gt; *sfinae=nullptr)</td></tr>
<tr class="separator:ab8a3af34e2b0e78906f8ac136b8a77b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a0ae9d92f1458eceb71778d88b9429"><td class="memTemplParams" colspan="2">template&lt;class Matrix &gt; </td></tr>
<tr class="memitem:a07a0ae9d92f1458eceb71778d88b9429"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00252.html#a07a0ae9d92f1458eceb71778d88b9429">bildl_decompose</a> (<a class="el" href="a01451.html">Matrix</a> &amp;A)</td></tr>
<tr class="memdesc:a07a0ae9d92f1458eceb71778d88b9429"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute ILDL decomposition of a symmetric matrix A  <a href="a00252.html#a07a0ae9d92f1458eceb71778d88b9429">More...</a><br /></td></tr>
<tr class="separator:a07a0ae9d92f1458eceb71778d88b9429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae801cb0f5df40c48568bc703f8c802b6"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class X , class Y &gt; </td></tr>
<tr class="memitem:ae801cb0f5df40c48568bc703f8c802b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00252.html#ae801cb0f5df40c48568bc703f8c802b6">bildl_backsolve</a> (const <a class="el" href="a01451.html">Matrix</a> &amp;A, X &amp;v, const Y &amp;d, bool isLowerTriangular=false)</td></tr>
<tr class="separator:ae801cb0f5df40c48568bc703f8c802b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67699f4a1392779203441b91402a834"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:ae67699f4a1392779203441b91402a834"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00252.html#ae67699f4a1392779203441b91402a834">bilu0_decomposition</a> (M &amp;A)</td></tr>
<tr class="separator:ae67699f4a1392779203441b91402a834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a874f8e0ab8b1bd84d6e615f7cde9ee"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y &gt; </td></tr>
<tr class="memitem:a9a874f8e0ab8b1bd84d6e615f7cde9ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00252.html#a9a874f8e0ab8b1bd84d6e615f7cde9ee">bilu_backsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d)</td></tr>
<tr class="separator:a9a874f8e0ab8b1bd84d6e615f7cde9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3410aebbe1151eaaf477a6229321bbdb"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:a3410aebbe1151eaaf477a6229321bbdb"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00252.html#a3410aebbe1151eaaf477a6229321bbdb">firstmatrixelement</a> (M &amp;A)</td></tr>
<tr class="separator:a3410aebbe1151eaaf477a6229321bbdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbd5513917454e0e1423e5be13cda74"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:acfbd5513917454e0e1423e5be13cda74"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00252.html#acfbd5513917454e0e1423e5be13cda74">bilu_decomposition</a> (const M &amp;A, int n, M &amp;ilu)</td></tr>
<tr class="separator:acfbd5513917454e0e1423e5be13cda74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfa35a4c02a1d2802460eb62ecbf3689"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:gacfa35a4c02a1d2802460eb62ecbf3689"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#gacfa35a4c02a1d2802460eb62ecbf3689">recursive_printvector</a> (std::ostream &amp;s, const V &amp;v, std::string rowtext, int &amp;counter, int columns, int width)</td></tr>
<tr class="memdesc:gacfa35a4c02a1d2802460eb62ecbf3689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively print a vector.  <a href="a00249.html#gacfa35a4c02a1d2802460eb62ecbf3689">More...</a><br /></td></tr>
<tr class="separator:gacfa35a4c02a1d2802460eb62ecbf3689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8674c142d6b29e12bcb94075f952d1e1"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:ga8674c142d6b29e12bcb94075f952d1e1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga8674c142d6b29e12bcb94075f952d1e1">printvector</a> (std::ostream &amp;s, const V &amp;v, std::string title, std::string rowtext, int columns=1, int width=10, int precision=2)</td></tr>
<tr class="memdesc:ga8674c142d6b29e12bcb94075f952d1e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an <a class="el" href="a00254.html">ISTL</a> vector.  <a href="a00249.html#ga8674c142d6b29e12bcb94075f952d1e1">More...</a><br /></td></tr>
<tr class="separator:ga8674c142d6b29e12bcb94075f952d1e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16a8aa6ba46f5e6afed17b49f25ccaf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00249.html#ga16a8aa6ba46f5e6afed17b49f25ccaf5">fill_row</a> (std::ostream &amp;s, int m, int width, [[maybe_unused]] int precision)</td></tr>
<tr class="memdesc:ga16a8aa6ba46f5e6afed17b49f25ccaf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a row of zeros for a non-existing block.  <a href="a00249.html#ga16a8aa6ba46f5e6afed17b49f25ccaf5">More...</a><br /></td></tr>
<tr class="separator:ga16a8aa6ba46f5e6afed17b49f25ccaf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5416e87c493938d5c9c670428aa29c0b"><td class="memTemplParams" colspan="2">template&lt;class K &gt; </td></tr>
<tr class="memitem:ga5416e87c493938d5c9c670428aa29c0b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga5416e87c493938d5c9c670428aa29c0b">print_row</a> (std::ostream &amp;s, const K &amp;value, [[maybe_unused]] typename <a class="el" href="a01719.html">FieldMatrix</a>&lt; K, 1, 1 &gt;::size_type I, [[maybe_unused]] typename <a class="el" href="a01719.html">FieldMatrix</a>&lt; K, 1, 1 &gt;::size_type J, [[maybe_unused]] typename <a class="el" href="a01719.html">FieldMatrix</a>&lt; K, 1, 1 &gt;::size_type therow, int width, [[maybe_unused]] int precision, typename std::enable_if_t&lt; Dune::IsNumber&lt; K &gt;::value &gt; *sfinae=nullptr)</td></tr>
<tr class="memdesc:ga5416e87c493938d5c9c670428aa29c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print one row of a matrix, specialization for number types.  <a href="a00249.html#ga5416e87c493938d5c9c670428aa29c0b">More...</a><br /></td></tr>
<tr class="separator:ga5416e87c493938d5c9c670428aa29c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6637eaf1e8d0c72f46f9edec7747c4d7"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:ga6637eaf1e8d0c72f46f9edec7747c4d7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga6637eaf1e8d0c72f46f9edec7747c4d7">print_row</a> (std::ostream &amp;s, const M &amp;A, typename M::size_type I, typename M::size_type J, typename M::size_type therow, int width, int precision, typename std::enable_if_t&lt;!Dune::IsNumber&lt; M &gt;::value &gt; *sfinae=nullptr)</td></tr>
<tr class="memdesc:ga6637eaf1e8d0c72f46f9edec7747c4d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print one row of a matrix.  <a href="a00249.html#ga6637eaf1e8d0c72f46f9edec7747c4d7">More...</a><br /></td></tr>
<tr class="separator:ga6637eaf1e8d0c72f46f9edec7747c4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81eff30b8e58a169e319b49f62e4ea7b"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:ga81eff30b8e58a169e319b49f62e4ea7b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga81eff30b8e58a169e319b49f62e4ea7b">printmatrix</a> (std::ostream &amp;s, const M &amp;A, std::string title, std::string rowtext, int width=10, int precision=2)</td></tr>
<tr class="memdesc:ga81eff30b8e58a169e319b49f62e4ea7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a generic block matrix.  <a href="a00249.html#ga81eff30b8e58a169e319b49f62e4ea7b">More...</a><br /></td></tr>
<tr class="separator:ga81eff30b8e58a169e319b49f62e4ea7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef563e4586001e657d48f01fae628846"><td class="memTemplParams" colspan="2">template&lt;class B , int n, int m, class A &gt; </td></tr>
<tr class="memitem:gaef563e4586001e657d48f01fae628846"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#gaef563e4586001e657d48f01fae628846">printSparseMatrix</a> (std::ostream &amp;s, const <a class="el" href="a01155.html">BCRSMatrix</a>&lt; <a class="el" href="a01719.html">FieldMatrix</a>&lt; B, n, m &gt;, A &gt; &amp;<a class="el" href="a00240.html#ga7051f2cf6a74fbd2d74ef52b1389cb0d">mat</a>, std::string title, std::string rowtext, int width=3, int precision=2)</td></tr>
<tr class="memdesc:gaef563e4586001e657d48f01fae628846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a <a class="el" href="a01155.html" title="A sparse block matrix with compressed row storage.">BCRSMatrix</a> with fixed sized blocks.  <a href="a00249.html#gaef563e4586001e657d48f01fae628846">More...</a><br /></td></tr>
<tr class="separator:gaef563e4586001e657d48f01fae628846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93b011f0c65384ec08aa12d56464daf9"><td class="memTemplParams" colspan="2">template&lt;class FieldType &gt; </td></tr>
<tr class="memitem:ga93b011f0c65384ec08aa12d56464daf9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga93b011f0c65384ec08aa12d56464daf9">writeMatrixToMatlabHelper</a> (const FieldType &amp;value, int rowOffset, int colOffset, std::ostream &amp;s, typename std::enable_if_t&lt; Dune::IsNumber&lt; FieldType &gt;::value &gt; *sfinae=nullptr)</td></tr>
<tr class="memdesc:ga93b011f0c65384ec08aa12d56464daf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method for the writeMatrixToMatlab routine.  <a href="a00249.html#ga93b011f0c65384ec08aa12d56464daf9">More...</a><br /></td></tr>
<tr class="separator:ga93b011f0c65384ec08aa12d56464daf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b083f3c81128b09bbfc7665a07b4b57"><td class="memTemplParams" colspan="2">template&lt;class MatrixType &gt; </td></tr>
<tr class="memitem:ga1b083f3c81128b09bbfc7665a07b4b57"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga1b083f3c81128b09bbfc7665a07b4b57">writeMatrixToMatlabHelper</a> (const MatrixType &amp;matrix, int externalRowOffset, int externalColOffset, std::ostream &amp;s, typename std::enable_if_t&lt;!Dune::IsNumber&lt; MatrixType &gt;::value &gt; *sfinae=nullptr)</td></tr>
<tr class="memdesc:ga1b083f3c81128b09bbfc7665a07b4b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method for the writeMatrixToMatlab routine.  <a href="a00249.html#ga1b083f3c81128b09bbfc7665a07b4b57">More...</a><br /></td></tr>
<tr class="separator:ga1b083f3c81128b09bbfc7665a07b4b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19c64bcf9cfcba21151f54c6cee16bba"><td class="memTemplParams" colspan="2">template&lt;class MatrixType &gt; </td></tr>
<tr class="memitem:ga19c64bcf9cfcba21151f54c6cee16bba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga19c64bcf9cfcba21151f54c6cee16bba">writeMatrixToMatlab</a> (const MatrixType &amp;matrix, const std::string &amp;filename, int outputPrecision=18)</td></tr>
<tr class="memdesc:ga19c64bcf9cfcba21151f54c6cee16bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes sparse matrix in a Matlab-readable format.  <a href="a00249.html#ga19c64bcf9cfcba21151f54c6cee16bba">More...</a><br /></td></tr>
<tr class="separator:ga19c64bcf9cfcba21151f54c6cee16bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95cc09d9210e3e99d3f3151e41b43536"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:ga95cc09d9210e3e99d3f3151e41b43536"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga95cc09d9210e3e99d3f3151e41b43536">writeVectorToMatlabHelper</a> (const V &amp;v, std::ostream &amp;stream)</td></tr>
<tr class="separator:ga95cc09d9210e3e99d3f3151e41b43536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab0213399acb112e901dc043b338ac00"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:gaab0213399acb112e901dc043b338ac00"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#gaab0213399acb112e901dc043b338ac00">writeVectorToMatlab</a> (const VectorType &amp;vector, const std::string &amp;filename, int outputPrecision=18)</td></tr>
<tr class="memdesc:gaab0213399acb112e901dc043b338ac00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes vectors in a Matlab-readable format.  <a href="a00249.html#gaab0213399acb112e901dc043b338ac00">More...</a><br /></td></tr>
<tr class="separator:gaab0213399acb112e901dc043b338ac00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ab4a1f419552328d594727627e696cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00236.html#ga4ab4a1f419552328d594727627e696cb">DUNE_REGISTER_DIRECT_SOLVER</a> (&quot;ldl&quot;, Dune::LDLCreator())</td></tr>
<tr class="separator:ga4ab4a1f419552328d594727627e696cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5669d944b34a0042d13688aaae6cd41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00249.html#gaf5669d944b34a0042d13688aaae6cd41">mm_read_header</a> (std::size_t &amp;rows, std::size_t &amp;cols, <a class="el" href="a01531.html">MatrixMarketImpl::MMHeader</a> &amp;header, std::istream &amp;istr, bool isVector)</td></tr>
<tr class="separator:gaf5669d944b34a0042d13688aaae6cd41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed3a11d2d57007d599549bdaac2dfb83"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:gaed3a11d2d57007d599549bdaac2dfb83"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#gaed3a11d2d57007d599549bdaac2dfb83">mm_read_vector_entries</a> (<a class="el" href="a01239.html">Dune::BlockVector</a>&lt; T, A &gt; &amp;vector, std::size_t size, std::istream &amp;istr, size_t lane)</td></tr>
<tr class="separator:gaed3a11d2d57007d599549bdaac2dfb83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0ec9d52cd4eab5d7c10b7ac15032026"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A , int entries&gt; </td></tr>
<tr class="memitem:gae0ec9d52cd4eab5d7c10b7ac15032026"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#gae0ec9d52cd4eab5d7c10b7ac15032026">mm_read_vector_entries</a> (<a class="el" href="a01239.html">Dune::BlockVector</a>&lt; Dune::FieldVector&lt; T, entries &gt;, A &gt; &amp;vector, std::size_t size, std::istream &amp;istr, size_t lane)</td></tr>
<tr class="separator:gae0ec9d52cd4eab5d7c10b7ac15032026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga050fdeb74ac186e9a2d3481230b64e54"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:ga050fdeb74ac186e9a2d3481230b64e54"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga050fdeb74ac186e9a2d3481230b64e54">readMatrixMarket</a> (<a class="el" href="a01239.html">Dune::BlockVector</a>&lt; T, A &gt; &amp;vector, std::istream &amp;istr)</td></tr>
<tr class="memdesc:ga050fdeb74ac186e9a2d3481230b64e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a <a class="el" href="a01239.html" title="A vector of blocks with memory management.">BlockVector</a> from a matrix market file.  <a href="a00249.html#ga050fdeb74ac186e9a2d3481230b64e54">More...</a><br /></td></tr>
<tr class="separator:ga050fdeb74ac186e9a2d3481230b64e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d1901dfd6a884df0a1295856c203df9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:ga3d1901dfd6a884df0a1295856c203df9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga3d1901dfd6a884df0a1295856c203df9">readMatrixMarket</a> (<a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; T, A &gt; &amp;matrix, std::istream &amp;istr)</td></tr>
<tr class="memdesc:ga3d1901dfd6a884df0a1295856c203df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a sparse matrix from a matrix market file.  <a href="a00249.html#ga3d1901dfd6a884df0a1295856c203df9">More...</a><br /></td></tr>
<tr class="separator:ga3d1901dfd6a884df0a1295856c203df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb63c87901fc6242102349fb245581f6"><td class="memTemplParams" colspan="2">template&lt;typename B &gt; </td></tr>
<tr class="memitem:gafb63c87901fc6242102349fb245581f6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#gafb63c87901fc6242102349fb245581f6">mm_print_entry</a> (const B &amp;entry, std::size_t rowidx, std::size_t colidx, std::ostream &amp;ostr)</td></tr>
<tr class="separator:gafb63c87901fc6242102349fb245581f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa308293be3836cb24c981bcd2d270bf5"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:gaa308293be3836cb24c981bcd2d270bf5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#gaa308293be3836cb24c981bcd2d270bf5">mm_print_vector_entry</a> (const V &amp;entry, std::ostream &amp;ostr, const std::integral_constant&lt; int, 1 &gt; &amp;, size_t lane)</td></tr>
<tr class="separator:gaa308293be3836cb24c981bcd2d270bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0233e0c56e727d0e3fa63a79ffcdeb3"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:gaf0233e0c56e727d0e3fa63a79ffcdeb3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#gaf0233e0c56e727d0e3fa63a79ffcdeb3">mm_print_vector_entry</a> (const V &amp;vector, std::ostream &amp;ostr, const std::integral_constant&lt; int, 0 &gt; &amp;, size_t lane)</td></tr>
<tr class="separator:gaf0233e0c56e727d0e3fa63a79ffcdeb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26b91d6c608f5dc37407dfdbb84eb7d1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:ga26b91d6c608f5dc37407dfdbb84eb7d1"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga26b91d6c608f5dc37407dfdbb84eb7d1">countEntries</a> (const <a class="el" href="a01239.html">BlockVector</a>&lt; T, A &gt; &amp;vector)</td></tr>
<tr class="separator:ga26b91d6c608f5dc37407dfdbb84eb7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ffd3c490badd2df43eb4a6d0e0119c4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A , int i&gt; </td></tr>
<tr class="memitem:ga4ffd3c490badd2df43eb4a6d0e0119c4"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga4ffd3c490badd2df43eb4a6d0e0119c4">countEntries</a> (const <a class="el" href="a01239.html">BlockVector</a>&lt; FieldVector&lt; T, i &gt;, A &gt; &amp;vector)</td></tr>
<tr class="separator:ga4ffd3c490badd2df43eb4a6d0e0119c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e94fcf7e81237a8f132a0f6a3ddaf21"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:ga2e94fcf7e81237a8f132a0f6a3ddaf21"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga2e94fcf7e81237a8f132a0f6a3ddaf21">writeMatrixMarket</a> (const V &amp;vector, std::ostream &amp;ostr, const std::integral_constant&lt; int, 0 &gt; &amp;)</td></tr>
<tr class="separator:ga2e94fcf7e81237a8f132a0f6a3ddaf21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf37b15dbfaeb5fa5639d38b560407c4b"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:gaf37b15dbfaeb5fa5639d38b560407c4b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#gaf37b15dbfaeb5fa5639d38b560407c4b">writeMatrixMarket</a> (const M &amp;matrix, std::ostream &amp;ostr, const std::integral_constant&lt; int, 1 &gt; &amp;)</td></tr>
<tr class="separator:gaf37b15dbfaeb5fa5639d38b560407c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8da01d126c9f37e57fa4f719e1d05487"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:ga8da01d126c9f37e57fa4f719e1d05487"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga8da01d126c9f37e57fa4f719e1d05487">writeMatrixMarket</a> (const M &amp;matrix, std::ostream &amp;ostr)</td></tr>
<tr class="memdesc:ga8da01d126c9f37e57fa4f719e1d05487"><td class="mdescLeft">&#160;</td><td class="mdescRight">writes a <a class="el" href="a00254.html">ISTL</a> matrix or vector to a stream in matrix market format.  <a href="a00249.html#ga8da01d126c9f37e57fa4f719e1d05487">More...</a><br /></td></tr>
<tr class="separator:ga8da01d126c9f37e57fa4f719e1d05487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1064c670426a98617b9e048a40f50a8c"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:ga1064c670426a98617b9e048a40f50a8c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga1064c670426a98617b9e048a40f50a8c">storeMatrixMarket</a> (const M &amp;matrix, std::string filename, int prec=<a class="el" href="a00249.html#gab36dc22122e5b7f555b64ef9f418d329">default_precision</a>)</td></tr>
<tr class="memdesc:ga1064c670426a98617b9e048a40f50a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a parallel matrix/vector in matrix market format in a file.  <a href="a00249.html#ga1064c670426a98617b9e048a40f50a8c">More...</a><br /></td></tr>
<tr class="separator:ga1064c670426a98617b9e048a40f50a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0c687a6e0c2feb4351f3364e4cbbce6"><td class="memTemplParams" colspan="2">template&lt;typename M , typename G , typename L &gt; </td></tr>
<tr class="memitem:gac0c687a6e0c2feb4351f3364e4cbbce6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#gac0c687a6e0c2feb4351f3364e4cbbce6">storeMatrixMarket</a> (const M &amp;matrix, std::string filename, const <a class="el" href="a01963.html">OwnerOverlapCopyCommunication</a>&lt; G, L &gt; &amp;comm, bool storeIndices=true, int prec=<a class="el" href="a00249.html#gab36dc22122e5b7f555b64ef9f418d329">default_precision</a>)</td></tr>
<tr class="memdesc:gac0c687a6e0c2feb4351f3364e4cbbce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a parallel matrix/vector in matrix market format in a file.  <a href="a00249.html#gac0c687a6e0c2feb4351f3364e4cbbce6">More...</a><br /></td></tr>
<tr class="separator:gac0c687a6e0c2feb4351f3364e4cbbce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bc5b5677a5be24d72a7d95214fd0d30"><td class="memTemplParams" colspan="2">template&lt;typename M , typename G , typename L &gt; </td></tr>
<tr class="memitem:ga1bc5b5677a5be24d72a7d95214fd0d30"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#ga1bc5b5677a5be24d72a7d95214fd0d30">loadMatrixMarket</a> (M &amp;matrix, const std::string &amp;filename, <a class="el" href="a01963.html">OwnerOverlapCopyCommunication</a>&lt; G, L &gt; &amp;comm, bool readIndices=true)</td></tr>
<tr class="memdesc:ga1bc5b5677a5be24d72a7d95214fd0d30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a parallel matrix/vector stored in matrix market format.  <a href="a00249.html#ga1bc5b5677a5be24d72a7d95214fd0d30">More...</a><br /></td></tr>
<tr class="separator:ga1bc5b5677a5be24d72a7d95214fd0d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac23bb6abb2a5b397781ea75c0ba134d8"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:gac23bb6abb2a5b397781ea75c0ba134d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00249.html#gac23bb6abb2a5b397781ea75c0ba134d8">loadMatrixMarket</a> (M &amp;matrix, const std::string &amp;filename)</td></tr>
<tr class="memdesc:gac23bb6abb2a5b397781ea75c0ba134d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a matrix/vector stored in matrix market format.  <a href="a00249.html#gac23bb6abb2a5b397781ea75c0ba134d8">More...</a><br /></td></tr>
<tr class="separator:gac23bb6abb2a5b397781ea75c0ba134d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74b699cb2d43dc8d89a507df207ff832"><td class="memTemplParams" colspan="2">template&lt;class T , class A , class A1 , class A2 , int n, int m, int k&gt; </td></tr>
<tr class="memitem:ga74b699cb2d43dc8d89a507df207ff832"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00240.html#ga74b699cb2d43dc8d89a507df207ff832">matMultTransposeMat</a> (<a class="el" href="a01155.html">BCRSMatrix</a>&lt; <a class="el" href="a01719.html">FieldMatrix</a>&lt; T, n, k &gt;, A &gt; &amp;res, const <a class="el" href="a01155.html">BCRSMatrix</a>&lt; <a class="el" href="a01719.html">FieldMatrix</a>&lt; T, n, m &gt;, A1 &gt; &amp;<a class="el" href="a00240.html#ga7051f2cf6a74fbd2d74ef52b1389cb0d">mat</a>, const <a class="el" href="a01155.html">BCRSMatrix</a>&lt; <a class="el" href="a01719.html">FieldMatrix</a>&lt; T, k, m &gt;, A2 &gt; &amp;matt, [[maybe_unused]] bool tryHard=false)</td></tr>
<tr class="memdesc:ga74b699cb2d43dc8d89a507df207ff832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate product of a sparse matrix with a transposed sparse matrices ( <img class="formulaInl" alt="$C=A*B^T$" src="form_30.png"/>).  <a href="a00240.html#ga74b699cb2d43dc8d89a507df207ff832">More...</a><br /></td></tr>
<tr class="separator:ga74b699cb2d43dc8d89a507df207ff832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1829a6141ae2cae5a1ecab7e0207123d"><td class="memTemplParams" colspan="2">template&lt;class T , class A , class A1 , class A2 , int n, int m, int k&gt; </td></tr>
<tr class="memitem:ga1829a6141ae2cae5a1ecab7e0207123d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00240.html#ga1829a6141ae2cae5a1ecab7e0207123d">matMultMat</a> (<a class="el" href="a01155.html">BCRSMatrix</a>&lt; <a class="el" href="a01719.html">FieldMatrix</a>&lt; T, n, m &gt;, A &gt; &amp;res, const <a class="el" href="a01155.html">BCRSMatrix</a>&lt; <a class="el" href="a01719.html">FieldMatrix</a>&lt; T, n, k &gt;, A1 &gt; &amp;<a class="el" href="a00240.html#ga7051f2cf6a74fbd2d74ef52b1389cb0d">mat</a>, const <a class="el" href="a01155.html">BCRSMatrix</a>&lt; <a class="el" href="a01719.html">FieldMatrix</a>&lt; T, k, m &gt;, A2 &gt; &amp;matt, bool tryHard=false)</td></tr>
<tr class="memdesc:ga1829a6141ae2cae5a1ecab7e0207123d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate product of two sparse matrices ( <img class="formulaInl" alt="$C=A*B$" src="form_29.png"/>).  <a href="a00240.html#ga1829a6141ae2cae5a1ecab7e0207123d">More...</a><br /></td></tr>
<tr class="separator:ga1829a6141ae2cae5a1ecab7e0207123d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac55861f0d592348e259984077e14960e"><td class="memTemplParams" colspan="2">template&lt;class T , class A , class A1 , class A2 , int n, int m, int k&gt; </td></tr>
<tr class="memitem:gac55861f0d592348e259984077e14960e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00240.html#gac55861f0d592348e259984077e14960e">transposeMatMultMat</a> (<a class="el" href="a01155.html">BCRSMatrix</a>&lt; <a class="el" href="a01719.html">FieldMatrix</a>&lt; T, n, m &gt;, A &gt; &amp;res, const <a class="el" href="a01155.html">BCRSMatrix</a>&lt; <a class="el" href="a01719.html">FieldMatrix</a>&lt; T, k, n &gt;, A1 &gt; &amp;<a class="el" href="a00240.html#ga7051f2cf6a74fbd2d74ef52b1389cb0d">mat</a>, const <a class="el" href="a01155.html">BCRSMatrix</a>&lt; <a class="el" href="a01719.html">FieldMatrix</a>&lt; T, k, m &gt;, A2 &gt; &amp;matt, [[maybe_unused]] bool tryHard=false)</td></tr>
<tr class="memdesc:gac55861f0d592348e259984077e14960e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate product of a transposed sparse matrix with another sparse matrices ( <img class="formulaInl" alt="$C=A^T*B$" src="form_31.png"/>).  <a href="a00240.html#gac55861f0d592348e259984077e14960e">More...</a><br /></td></tr>
<tr class="separator:gac55861f0d592348e259984077e14960e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e2af44500c49cc412112bcc645c7bd"><td class="memTemplParams" colspan="2">template&lt;typename M , typename C &gt; </td></tr>
<tr class="memitem:a63e2af44500c49cc412112bcc645c7bd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00252.html#a63e2af44500c49cc412112bcc645c7bd">redistributeSparsityPattern</a> (M &amp;origMatrix, M &amp;newMatrix, C &amp;origComm, C &amp;newComm, <a class="el" href="a01675.html">RedistributeInformation</a>&lt; C &gt; &amp;ri)</td></tr>
<tr class="separator:a63e2af44500c49cc412112bcc645c7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f63ab17e9c1235103a0512bda341ca2"><td class="memTemplParams" colspan="2">template&lt;typename M , typename C &gt; </td></tr>
<tr class="memitem:a3f63ab17e9c1235103a0512bda341ca2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00252.html#a3f63ab17e9c1235103a0512bda341ca2">redistributeMatrixEntries</a> (M &amp;origMatrix, M &amp;newMatrix, C &amp;origComm, C &amp;newComm, <a class="el" href="a01675.html">RedistributeInformation</a>&lt; C &gt; &amp;ri)</td></tr>
<tr class="separator:a3f63ab17e9c1235103a0512bda341ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59fe4d0a58ea0575b42993d7563d34b"><td class="memTemplParams" colspan="2">template&lt;typename M , typename C &gt; </td></tr>
<tr class="memitem:ab59fe4d0a58ea0575b42993d7563d34b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00252.html#ab59fe4d0a58ea0575b42993d7563d34b">redistributeMatrix</a> (M &amp;origMatrix, M &amp;newMatrix, C &amp;origComm, C &amp;newComm, <a class="el" href="a01675.html">RedistributeInformation</a>&lt; C &gt; &amp;ri)</td></tr>
<tr class="memdesc:ab59fe4d0a58ea0575b42993d7563d34b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redistribute a matrix according to given domain decompositions.  <a href="a00252.html#ab59fe4d0a58ea0575b42993d7563d34b">More...</a><br /></td></tr>
<tr class="separator:ab59fe4d0a58ea0575b42993d7563d34b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a706b106c6123e900b004a90d4dcf42c7"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:a706b106c6123e900b004a90d4dcf42c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00252.html#a706b106c6123e900b004a90d4dcf42c7">redistributeMatrixEntries</a> (M &amp;origMatrix, M &amp;newMatrix, <a class="el" href="a02411.html">Dune::Amg::SequentialInformation</a> &amp;origComm, <a class="el" href="a02411.html">Dune::Amg::SequentialInformation</a> &amp;newComm, <a class="el" href="a01675.html">RedistributeInformation</a>&lt; <a class="el" href="a02411.html">Dune::Amg::SequentialInformation</a> &gt; &amp;ri)</td></tr>
<tr class="separator:a706b106c6123e900b004a90d4dcf42c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345908acc30a0bf6affab15d04fcd0a8"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:a345908acc30a0bf6affab15d04fcd0a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00252.html#a345908acc30a0bf6affab15d04fcd0a8">redistributeMatrix</a> (M &amp;origMatrix, M &amp;newMatrix, <a class="el" href="a02411.html">Dune::Amg::SequentialInformation</a> &amp;origComm, <a class="el" href="a02411.html">Dune::Amg::SequentialInformation</a> &amp;newComm, <a class="el" href="a01675.html">RedistributeInformation</a>&lt; <a class="el" href="a02411.html">Dune::Amg::SequentialInformation</a> &gt; &amp;ri)</td></tr>
<tr class="separator:a345908acc30a0bf6affab15d04fcd0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dc83143ecd9d259d220a655d7a850bd"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:ga3dc83143ecd9d259d220a655d7a850bd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00240.html#ga3dc83143ecd9d259d220a655d7a850bd">countNonZeros</a> (const M &amp;, [[maybe_unused]] typename std::enable_if_t&lt; Dune::IsNumber&lt; M &gt;::value &gt; *sfinae=nullptr)</td></tr>
<tr class="memdesc:ga3dc83143ecd9d259d220a655d7a850bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of nonzero fields in the matrix.  <a href="a00240.html#ga3dc83143ecd9d259d220a655d7a850bd">More...</a><br /></td></tr>
<tr class="separator:ga3dc83143ecd9d259d220a655d7a850bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab71a994a1885eda6a663e8fa22535ce6"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:gab71a994a1885eda6a663e8fa22535ce6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00240.html#gab71a994a1885eda6a663e8fa22535ce6">countNonZeros</a> (const M &amp;matrix, [[maybe_unused]] typename std::enable_if_t&lt;!Dune::IsNumber&lt; M &gt;::value &gt; *sfinae=nullptr)</td></tr>
<tr class="separator:gab71a994a1885eda6a663e8fa22535ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131e13bda7cee7fa0c8e4a96e8d46801"><td class="memTemplParams" colspan="2">template&lt;class M , class C &gt; </td></tr>
<tr class="memitem:a131e13bda7cee7fa0c8e4a96e8d46801"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00252.html#a131e13bda7cee7fa0c8e4a96e8d46801">printGlobalSparseMatrix</a> (const M &amp;<a class="el" href="a00240.html#ga7051f2cf6a74fbd2d74ef52b1389cb0d">mat</a>, C &amp;ooc, std::ostream &amp;os)</td></tr>
<tr class="separator:a131e13bda7cee7fa0c8e4a96e8d46801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5681a3ce128d5db798ddb4c6dcdfb1c6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename... Args&gt; </td></tr>
<tr class="memitem:ga5681a3ce128d5db798ddb4c6dcdfb1c6"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00240.html#ga5681a3ce128d5db798ddb4c6dcdfb1c6">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="a01179.html">MultiTypeBlockMatrix</a>&lt; T1, Args... &gt; &amp;m)</td></tr>
<tr class="memdesc:ga5681a3ce128d5db798ddb4c6dcdfb1c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt;&lt; operator for a <a class="el" href="a01179.html" title="A Matrix class to support different block types.">MultiTypeBlockMatrix</a>  <a href="a00240.html#ga5681a3ce128d5db798ddb4c6dcdfb1c6">More...</a><br /></td></tr>
<tr class="separator:ga5681a3ce128d5db798ddb4c6dcdfb1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4de74df39eaede5eddcd10b898e380a"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:gaa4de74df39eaede5eddcd10b898e380a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00240.html#gaa4de74df39eaede5eddcd10b898e380a">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="a01175.html">MultiTypeBlockVector</a>&lt; Args... &gt; &amp;v)</td></tr>
<tr class="memdesc:gaa4de74df39eaede5eddcd10b898e380a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send <a class="el" href="a01175.html" title="A Vector class to support different block types.">MultiTypeBlockVector</a> to an outstream.  <a href="a00240.html#gaa4de74df39eaede5eddcd10b898e380a">More...</a><br /></td></tr>
<tr class="separator:gaa4de74df39eaede5eddcd10b898e380a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1d7465bf71a0549ed5596e9b142f7f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00252.html#a9f1d7465bf71a0549ed5596e9b142f7f">DUNE_REGISTER_PRECONDITIONER</a> (&quot;amg&quot;, AMGCreator())</td></tr>
<tr class="separator:a9f1d7465bf71a0549ed5596e9b142f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405d30f54803def97082030c715c8791"><td class="memTemplParams" colspan="2">template&lt;typename G , typename EP , typename VM , typename EM &gt; </td></tr>
<tr class="memitem:a405d30f54803def97082030c715c8791"><td class="memTemplItemLeft" align="right" valign="top">PropertyMapTypeSelector&lt; <a class="el" href="a02415.html">Amg::VertexVisitedTag</a>, <a class="el" href="a02315.html">Amg::PropertiesGraph</a>&lt; G, <a class="el" href="a02175.html">Amg::VertexProperties</a>, EP, VM, EM &gt; &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00252.html#a405d30f54803def97082030c715c8791">get</a> ([[maybe_unused]] const <a class="el" href="a02415.html">Amg::VertexVisitedTag</a> &amp;tag, <a class="el" href="a02315.html">Amg::PropertiesGraph</a>&lt; G, <a class="el" href="a02175.html">Amg::VertexProperties</a>, EP, VM, EM &gt; &amp;graph)</td></tr>
<tr class="separator:a405d30f54803def97082030c715c8791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31161bee90db194d09f233f00ab4de9c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga31161bee90db194d09f233f00ab4de9c">DUNE_REGISTER_PRECONDITIONER</a> (&quot;ssor&quot;, defaultPreconditionerBlockLevelCreator&lt; <a class="el" href="a02591.html">Dune::SeqSSOR</a> &gt;())</td></tr>
<tr class="separator:ga31161bee90db194d09f233f00ab4de9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84e1da868870a635c00649be4e1d101b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga84e1da868870a635c00649be4e1d101b">DUNE_REGISTER_PRECONDITIONER</a> (&quot;sor&quot;, defaultPreconditionerBlockLevelCreator&lt; <a class="el" href="a02595.html">Dune::SeqSOR</a> &gt;())</td></tr>
<tr class="separator:ga84e1da868870a635c00649be4e1d101b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08abf358156090136c1433291819a194"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga08abf358156090136c1433291819a194">DUNE_REGISTER_PRECONDITIONER</a> (&quot;gs&quot;, defaultPreconditionerBlockLevelCreator&lt; <a class="el" href="a00245.html#gaf04e8521e43d7b1c8fdb3a412210b36d">Dune::SeqGS</a> &gt;())</td></tr>
<tr class="separator:ga08abf358156090136c1433291819a194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e0768493ba56650387ef7f1171d2620"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga8e0768493ba56650387ef7f1171d2620">DUNE_REGISTER_PRECONDITIONER</a> (&quot;jac&quot;, defaultPreconditionerBlockLevelCreator&lt; <a class="el" href="a02599.html">Dune::SeqJac</a> &gt;())</td></tr>
<tr class="separator:ga8e0768493ba56650387ef7f1171d2620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdfc9bd7597c826fa723af53d0cb0e2d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#gabdfc9bd7597c826fa723af53d0cb0e2d">DUNE_REGISTER_PRECONDITIONER</a> (&quot;ilu&quot;, defaultPreconditionerBlockLevelCreator&lt; <a class="el" href="a02603.html">Dune::SeqILU</a> &gt;())</td></tr>
<tr class="separator:gabdfc9bd7597c826fa723af53d0cb0e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c0383c6a267d2dd7bdf0425463c95dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga6c0383c6a267d2dd7bdf0425463c95dc">DUNE_REGISTER_PRECONDITIONER</a> (&quot;richardson&quot;, [](auto tl, const auto &amp;, const ParameterTree &amp;config){ using D=typename Dune::TypeListElement&lt; 1, decltype(tl)&gt;::type;using R=typename Dune::TypeListElement&lt; 2, decltype(tl)&gt;::type;return std::make_shared&lt; <a class="el" href="a02607.html">Richardson</a>&lt; D, R &gt;&gt;(config);})</td></tr>
<tr class="separator:ga6c0383c6a267d2dd7bdf0425463c95dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada61707dc136db5a195bef80037d5246"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#gada61707dc136db5a195bef80037d5246">DUNE_REGISTER_PRECONDITIONER</a> (&quot;ildl&quot;, defaultPreconditionerCreator&lt; <a class="el" href="a02611.html">Dune::SeqILDL</a> &gt;())</td></tr>
<tr class="separator:gada61707dc136db5a195bef80037d5246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62bc57d5768b1bc98357bac259795327"><td class="memTemplParams" colspan="2">template&lt;class G , class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a62bc57d5768b1bc98357bac259795327"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00252.html#a62bc57d5768b1bc98357bac259795327">fillIndexSetHoles</a> (const G &amp;graph, <a class="el" href="a01963.html">Dune::OwnerOverlapCopyCommunication</a>&lt; T1, T2 &gt; &amp;oocomm)</td></tr>
<tr class="memdesc:a62bc57d5768b1bc98357bac259795327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the holes in an index set.  <a href="a00252.html#a62bc57d5768b1bc98357bac259795327">More...</a><br /></td></tr>
<tr class="separator:a62bc57d5768b1bc98357bac259795327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfad52fbb6f783a2ce3c01aefa7838c"><td class="memTemplParams" colspan="2">template&lt;class G , class T1 , class T2 &gt; </td></tr>
<tr class="memitem:aecfad52fbb6f783a2ce3c01aefa7838c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00252.html#aecfad52fbb6f783a2ce3c01aefa7838c">buildCommunication</a> (const G &amp;graph, std::vector&lt; int &gt; &amp;realparts, <a class="el" href="a01963.html">Dune::OwnerOverlapCopyCommunication</a>&lt; T1, T2 &gt; &amp;oocomm, std::shared_ptr&lt; <a class="el" href="a01963.html">Dune::OwnerOverlapCopyCommunication</a>&lt; T1, T2 &gt;&gt; &amp;outcomm, <a class="el" href="a02619.html">RedistributeInterface</a> &amp;redistInf, bool verbose=false)</td></tr>
<tr class="separator:aecfad52fbb6f783a2ce3c01aefa7838c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fd07ea3f22cb47275859d39d7bdffef"><td class="memTemplParams" colspan="2">template&lt;class S , class T &gt; </td></tr>
<tr class="memitem:a8fd07ea3f22cb47275859d39d7bdffef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00252.html#a8fd07ea3f22cb47275859d39d7bdffef">print_carray</a> (S &amp;os, T *array, std::size_t l)</td></tr>
<tr class="separator:a8fd07ea3f22cb47275859d39d7bdffef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa754fe56e078eb1b50db4ace1e7fc1b1"><td class="memTemplParams" colspan="2">template&lt;class S , class T &gt; </td></tr>
<tr class="memitem:aa754fe56e078eb1b50db4ace1e7fc1b1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00252.html#aa754fe56e078eb1b50db4ace1e7fc1b1">isValidGraph</a> (std::size_t noVtx, std::size_t gnoVtx, S noEdges, T *xadj, T *adjncy, bool checkSymmetry)</td></tr>
<tr class="separator:aa754fe56e078eb1b50db4ace1e7fc1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba345909b93e7811c7b937e3de3bf381"><td class="memTemplParams" colspan="2">template&lt;class M , class T1 , class T2 &gt; </td></tr>
<tr class="memitem:aba345909b93e7811c7b937e3de3bf381"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00252.html#aba345909b93e7811c7b937e3de3bf381">commGraphRepartition</a> (const M &amp;<a class="el" href="a00240.html#ga7051f2cf6a74fbd2d74ef52b1389cb0d">mat</a>, <a class="el" href="a01963.html">Dune::OwnerOverlapCopyCommunication</a>&lt; T1, T2 &gt; &amp;oocomm, <a class="el" href="a00268.html#ab1b879eebd5d32701c7b5879bbe64a17">Metis::idx_t</a> nparts, std::shared_ptr&lt; <a class="el" href="a01963.html">Dune::OwnerOverlapCopyCommunication</a>&lt; T1, T2 &gt;&gt; &amp;outcomm, <a class="el" href="a02619.html">RedistributeInterface</a> &amp;redistInf, bool verbose=false)</td></tr>
<tr class="separator:aba345909b93e7811c7b937e3de3bf381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8217b8a1761fe09e89c8cfd8a84f21ff"><td class="memTemplParams" colspan="2">template&lt;class G , class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a8217b8a1761fe09e89c8cfd8a84f21ff"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00252.html#a8217b8a1761fe09e89c8cfd8a84f21ff">graphRepartition</a> (const G &amp;graph, <a class="el" href="a01963.html">Dune::OwnerOverlapCopyCommunication</a>&lt; T1, T2 &gt; &amp;oocomm, <a class="el" href="a00268.html#ab1b879eebd5d32701c7b5879bbe64a17">Metis::idx_t</a> nparts, std::shared_ptr&lt; <a class="el" href="a01963.html">Dune::OwnerOverlapCopyCommunication</a>&lt; T1, T2 &gt;&gt; &amp;outcomm, <a class="el" href="a02619.html">RedistributeInterface</a> &amp;redistInf, bool verbose=false)</td></tr>
<tr class="memdesc:a8217b8a1761fe09e89c8cfd8a84f21ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">execute a graph repartition for a giving graph and indexset.  <a href="a00252.html#a8217b8a1761fe09e89c8cfd8a84f21ff">More...</a><br /></td></tr>
<tr class="separator:a8217b8a1761fe09e89c8cfd8a84f21ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f43ac2f62e510522f7cdb07828a41f"><td class="memTemplParams" colspan="2">template&lt;class X , class Comm &gt; </td></tr>
<tr class="memitem:a13f43ac2f62e510522f7cdb07828a41f"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="a02639.html">ScalarProduct</a>&lt; X &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00252.html#a13f43ac2f62e510522f7cdb07828a41f">makeScalarProduct</a> (std::shared_ptr&lt; const Comm &gt; comm, <a class="el" href="a02703.html#ae061380ac961490be6ee353cf0dc1733">SolverCategory::Category</a> category)</td></tr>
<tr class="memdesc:a13f43ac2f62e510522f7cdb07828a41f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose the approriate scalar product for a solver category.  <a href="a00252.html#a13f43ac2f62e510522f7cdb07828a41f">More...</a><br /></td></tr>
<tr class="separator:a13f43ac2f62e510522f7cdb07828a41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf47e66b019fa82bce1ea1abfba6080"><td class="memTemplParams" colspan="2">template&lt;class X , class Comm &gt; </td></tr>
<tr class="memitem:afaf47e66b019fa82bce1ea1abfba6080"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="a02639.html">ScalarProduct</a>&lt; X &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00252.html#afaf47e66b019fa82bce1ea1abfba6080">createScalarProduct</a> (const Comm &amp;comm, <a class="el" href="a02703.html#ae061380ac961490be6ee353cf0dc1733">SolverCategory::Category</a> category)</td></tr>
<tr class="separator:afaf47e66b019fa82bce1ea1abfba6080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cd87704fdf718eb91e0438ece40dc90"><td class="memTemplParams" colspan="2">template&lt;class O , class Preconditioner &gt; </td></tr>
<tr class="memitem:ga8cd87704fdf718eb91e0438ece40dc90"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="a02583.html">Preconditioner</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00250.html#ga8cd87704fdf718eb91e0438ece40dc90">wrapPreconditioner4Parallel</a> (const std::shared_ptr&lt; <a class="el" href="a02583.html">Preconditioner</a> &gt; &amp;prec, const O &amp;)</td></tr>
<tr class="separator:ga8cd87704fdf718eb91e0438ece40dc90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaa45f8d22a9e430403dc0a933c40718"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class C , class Preconditioner &gt; </td></tr>
<tr class="memitem:gacaa45f8d22a9e430403dc0a933c40718"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="a02583.html">Preconditioner</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00250.html#gacaa45f8d22a9e430403dc0a933c40718">wrapPreconditioner4Parallel</a> (const std::shared_ptr&lt; <a class="el" href="a02583.html">Preconditioner</a> &gt; &amp;prec, const std::shared_ptr&lt; <a class="el" href="a02143.html">OverlappingSchwarzOperator</a>&lt; M, X, Y, C &gt; &gt; &amp;op)</td></tr>
<tr class="separator:gacaa45f8d22a9e430403dc0a933c40718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3ab5a656b6ac5e2f52304689e535597"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class C , class Preconditioner &gt; </td></tr>
<tr class="memitem:gae3ab5a656b6ac5e2f52304689e535597"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="a02583.html">Preconditioner</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00250.html#gae3ab5a656b6ac5e2f52304689e535597">wrapPreconditioner4Parallel</a> (const std::shared_ptr&lt; <a class="el" href="a02583.html">Preconditioner</a> &gt; &amp;prec, const std::shared_ptr&lt; <a class="el" href="a01807.html">NonoverlappingSchwarzOperator</a>&lt; M, X, Y, C &gt; &gt; &amp;op)</td></tr>
<tr class="separator:gae3ab5a656b6ac5e2f52304689e535597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffc9f5f8d427f2d98dbef49624117634"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y &gt; </td></tr>
<tr class="memitem:gaffc9f5f8d427f2d98dbef49624117634"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="a02639.html">ScalarProduct</a>&lt; X &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00250.html#gaffc9f5f8d427f2d98dbef49624117634">createScalarProduct</a> (const std::shared_ptr&lt; <a class="el" href="a01827.html">MatrixAdapter</a>&lt; M, X, Y &gt; &gt; &amp;)</td></tr>
<tr class="separator:gaffc9f5f8d427f2d98dbef49624117634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga569512130000aa1e72d00b1427407201"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class C &gt; </td></tr>
<tr class="memitem:ga569512130000aa1e72d00b1427407201"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="a02639.html">ScalarProduct</a>&lt; X &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00250.html#ga569512130000aa1e72d00b1427407201">createScalarProduct</a> (const std::shared_ptr&lt; <a class="el" href="a02143.html">OverlappingSchwarzOperator</a>&lt; M, X, Y, C &gt; &gt; &amp;op)</td></tr>
<tr class="separator:ga569512130000aa1e72d00b1427407201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab48d6cf38494913a86506075ee00388d"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , class C &gt; </td></tr>
<tr class="memitem:gab48d6cf38494913a86506075ee00388d"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="a02639.html">ScalarProduct</a>&lt; X &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00250.html#gab48d6cf38494913a86506075ee00388d">createScalarProduct</a> (const std::shared_ptr&lt; <a class="el" href="a01807.html">NonoverlappingSchwarzOperator</a>&lt; M, X, Y, C &gt; &gt; &amp;op)</td></tr>
<tr class="separator:gab48d6cf38494913a86506075ee00388d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ce543e29164b14be8dcfdf63197f3dd"><td class="memTemplParams" colspan="2">template&lt;class Operator &gt; </td></tr>
<tr class="memitem:ga1ce543e29164b14be8dcfdf63197f3dd"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="a02679.html">InverseOperator</a>&lt; typename Operator::domain_type, typename Operator::range_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00250.html#ga1ce543e29164b14be8dcfdf63197f3dd">getSolverFromFactory</a> (std::shared_ptr&lt; Operator &gt; op, const ParameterTree &amp;config, std::shared_ptr&lt; <a class="el" href="a02583.html">Preconditioner</a>&lt; typename Operator::domain_type, typename Operator::range_type &gt;&gt; prec=nullptr)</td></tr>
<tr class="memdesc:ga1ce543e29164b14be8dcfdf63197f3dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates an <code><a class="el" href="a02679.html" title="Abstract base class for all solvers.">InverseOperator</a></code> from an Operator and a configuration given as a ParameterTree.  <a href="a00250.html#ga1ce543e29164b14be8dcfdf63197f3dd">More...</a><br /></td></tr>
<tr class="separator:ga1ce543e29164b14be8dcfdf63197f3dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga335dd7b0d29e9493a7f193c9f07767bf"><td class="memTemplParams" colspan="2">template&lt;template&lt; class, class, class, int &gt;class Preconditioner, int blockLevel = 1&gt; </td></tr>
<tr class="memitem:ga335dd7b0d29e9493a7f193c9f07767bf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00250.html#ga335dd7b0d29e9493a7f193c9f07767bf">defaultPreconditionerBlockLevelCreator</a> ()</td></tr>
<tr class="separator:ga335dd7b0d29e9493a7f193c9f07767bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf82ab9baa6ac2e24bb927e953ffb4fb"><td class="memTemplParams" colspan="2">template&lt;template&lt; class, class, class &gt;class Preconditioner&gt; </td></tr>
<tr class="memitem:gaaf82ab9baa6ac2e24bb927e953ffb4fb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00250.html#gaaf82ab9baa6ac2e24bb927e953ffb4fb">defaultPreconditionerCreator</a> ()</td></tr>
<tr class="separator:gaaf82ab9baa6ac2e24bb927e953ffb4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a5d86e17fb4ce0299537c0704264996"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt;class Solver&gt; </td></tr>
<tr class="memitem:ga2a5d86e17fb4ce0299537c0704264996"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00250.html#ga2a5d86e17fb4ce0299537c0704264996">defaultIterativeSolverCreator</a> ()</td></tr>
<tr class="separator:ga2a5d86e17fb4ce0299537c0704264996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd2045a9be5c024d2c92e3f4cdfa3eb2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00237.html#gabd2045a9be5c024d2c92e3f4cdfa3eb2">DUNE_REGISTER_ITERATIVE_SOLVER</a> (&quot;loopsolver&quot;, defaultIterativeSolverCreator&lt; <a class="el" href="a02735.html">Dune::LoopSolver</a> &gt;())</td></tr>
<tr class="separator:gabd2045a9be5c024d2c92e3f4cdfa3eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c66a86b003ab534cdd42cad22508ef6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00237.html#ga3c66a86b003ab534cdd42cad22508ef6">DUNE_REGISTER_ITERATIVE_SOLVER</a> (&quot;gradientsolver&quot;, defaultIterativeSolverCreator&lt; <a class="el" href="a02739.html">Dune::GradientSolver</a> &gt;())</td></tr>
<tr class="separator:ga3c66a86b003ab534cdd42cad22508ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab43f1b948010bb468503c277c15f8eb5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00237.html#gab43f1b948010bb468503c277c15f8eb5">DUNE_REGISTER_ITERATIVE_SOLVER</a> (&quot;cgsolver&quot;, defaultIterativeSolverCreator&lt; <a class="el" href="a02743.html">Dune::CGSolver</a> &gt;())</td></tr>
<tr class="separator:gab43f1b948010bb468503c277c15f8eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac041cf0b9a9364c1844ef5b3d2528d30"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00237.html#gac041cf0b9a9364c1844ef5b3d2528d30">DUNE_REGISTER_ITERATIVE_SOLVER</a> (&quot;bicgstabsolver&quot;, defaultIterativeSolverCreator&lt; <a class="el" href="a02747.html">Dune::BiCGSTABSolver</a> &gt;())</td></tr>
<tr class="separator:gac041cf0b9a9364c1844ef5b3d2528d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa120eff85c543a03ef1772f13de8684f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00237.html#gaa120eff85c543a03ef1772f13de8684f">DUNE_REGISTER_ITERATIVE_SOLVER</a> (&quot;minressolver&quot;, defaultIterativeSolverCreator&lt; <a class="el" href="a02751.html">Dune::MINRESSolver</a> &gt;())</td></tr>
<tr class="separator:gaa120eff85c543a03ef1772f13de8684f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cc4a9320ba7c35fae50b4360d80ecf4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00237.html#ga7cc4a9320ba7c35fae50b4360d80ecf4">DUNE_REGISTER_ITERATIVE_SOLVER</a> (&quot;restartedgmressolver&quot;, defaultIterativeSolverCreator&lt; <a class="el" href="a02755.html">Dune::RestartedGMResSolver</a> &gt;())</td></tr>
<tr class="separator:ga7cc4a9320ba7c35fae50b4360d80ecf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8845c190b12bb823c017a8dfe514706b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00237.html#ga8845c190b12bb823c017a8dfe514706b">DUNE_REGISTER_ITERATIVE_SOLVER</a> (&quot;restartedflexiblegmressolver&quot;, defaultIterativeSolverCreator&lt; <a class="el" href="a02759.html">Dune::RestartedFlexibleGMResSolver</a> &gt;())</td></tr>
<tr class="separator:ga8845c190b12bb823c017a8dfe514706b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga311f32233cd4c7b3458590c6e12a4317"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00237.html#ga311f32233cd4c7b3458590c6e12a4317">DUNE_REGISTER_ITERATIVE_SOLVER</a> (&quot;generalizedpcgsolver&quot;, defaultIterativeSolverCreator&lt; <a class="el" href="a02763.html">Dune::GeneralizedPCGSolver</a> &gt;())</td></tr>
<tr class="separator:ga311f32233cd4c7b3458590c6e12a4317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa79e6ce5a91a1bec65fff22b187143b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00237.html#gaaa79e6ce5a91a1bec65fff22b187143b">DUNE_REGISTER_ITERATIVE_SOLVER</a> (&quot;restartedfcgsolver&quot;, defaultIterativeSolverCreator&lt; <a class="el" href="a02767.html">Dune::RestartedFCGSolver</a> &gt;())</td></tr>
<tr class="separator:gaaa79e6ce5a91a1bec65fff22b187143b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6cceb219c9cb222a7be9729f616e09b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00237.html#gaf6cceb219c9cb222a7be9729f616e09b">DUNE_REGISTER_ITERATIVE_SOLVER</a> (&quot;completefcgsolver&quot;, defaultIterativeSolverCreator&lt; <a class="el" href="a02771.html">Dune::CompleteFCGSolver</a> &gt;())</td></tr>
<tr class="separator:gaf6cceb219c9cb222a7be9729f616e09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee2b8c91109cd15b0ee757e98eac25f3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00236.html#gaee2b8c91109cd15b0ee757e98eac25f3">DUNE_REGISTER_DIRECT_SOLVER</a> (&quot;spqr&quot;, Dune::SPQRCreator())</td></tr>
<tr class="separator:gaee2b8c91109cd15b0ee757e98eac25f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ff6f6d268c3f382e470135e978eabf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00252.html#ad6ff6f6d268c3f382e470135e978eabf">DUNE_REGISTER_DIRECT_SOLVER</a> (&quot;superlu&quot;, SuperLUCreator())</td></tr>
<tr class="separator:ad6ff6f6d268c3f382e470135e978eabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0960774f62ee399c3f9c2b57781e4fde"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00236.html#ga0960774f62ee399c3f9c2b57781e4fde">DUNE_REGISTER_DIRECT_SOLVER</a> (&quot;umfpack&quot;, Dune::UMFPackCreator())</td></tr>
<tr class="separator:ga0960774f62ee399c3f9c2b57781e4fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gab36dc22122e5b7f555b64ef9f418d329"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00249.html#gab36dc22122e5b7f555b64ef9f418d329">default_precision</a> = -1</td></tr>
<tr class="separator:gab36dc22122e5b7f555b64ef9f418d329"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a9ab4e8c72359591b27aede17f5ec6615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab4e8c72359591b27aede17f5ec6615">&#9670;&nbsp;</a></span>AllocatorType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00252.html#a9ab4e8c72359591b27aede17f5ec6615">Dune::AllocatorType</a> = typedef typename <a class="el" href="a01099.html">AllocatorTraits</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9020314eeb58ec32f6fab5ef0c196674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9020314eeb58ec32f6fab5ef0c196674">&#9670;&nbsp;</a></span>ReboundAllocatorType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00252.html#a9020314eeb58ec32f6fab5ef0c196674">Dune::ReboundAllocatorType</a> = typedef typename std::allocator_traits&lt;typename <a class="el" href="a01099.html">AllocatorTraits</a>&lt;T&gt;::type&gt;::template rebind_alloc&lt;X&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae801cb0f5df40c48568bc703f8c802b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae801cb0f5df40c48568bc703f8c802b6">&#9670;&nbsp;</a></span>bildl_backsolve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Dune::bildl_backsolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01451.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Y &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isLowerTriangular</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a07a0ae9d92f1458eceb71778d88b9429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a0ae9d92f1458eceb71778d88b9429">&#9670;&nbsp;</a></span>bildl_decompose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Dune::bildl_decompose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01451.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute ILDL decomposition of a symmetric matrix A </p>
<dl class="section author"><dt>Author</dt><dd>Martin Nolte</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td>matrix to decompose</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>A is overwritten by the factorization. </dd>
<dd>
Only the lower half of A is used. </dd></dl>

</div>
</div>
<a id="af8de6b1951fa7f95a3e9f89973579115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8de6b1951fa7f95a3e9f89973579115">&#9670;&nbsp;</a></span>bildl_subtractBCT() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , int m, int n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Dune::bildl_subtractBCT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01719.html">FieldMatrix</a>&lt; K, m, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01719.html">FieldMatrix</a>&lt; K, m, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>CT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01719.html">FieldMatrix</a>&lt; K, m, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3f5c61e1bb13aaae63f8229ca8fcf17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f5c61e1bb13aaae63f8229ca8fcf17">&#9670;&nbsp;</a></span>bildl_subtractBCT() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Dune::bildl_subtractBCT </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>CT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">K &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if_t&lt; Dune::IsNumber&lt; K &gt;::value &gt; *&#160;</td>
          <td class="paramname"><em>sfinae</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8a3af34e2b0e78906f8ac136b8a77b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8a3af34e2b0e78906f8ac136b8a77b9">&#9670;&nbsp;</a></span>bildl_subtractBCT() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Dune::bildl_subtractBCT </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01451.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01451.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>CT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01451.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if_t&lt;!Dune::IsNumber&lt; <a class="el" href="a01451.html">Matrix</a> &gt;::value &gt; *&#160;</td>
          <td class="paramname"><em>sfinae</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae67699f4a1392779203441b91402a834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae67699f4a1392779203441b91402a834">&#9670;&nbsp;</a></span>bilu0_decomposition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::bilu0_decomposition </td>
          <td>(</td>
          <td class="paramtype">M &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="a00234.html#_deprecated000002">Deprecated:</a></b></dt><dd>"Will be removed after release 2.8. Use ILU::blockILU0Decomposition." <br  />
 </dd></dl>

</div>
</div>
<a id="a9a874f8e0ab8b1bd84d6e615f7cde9ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a874f8e0ab8b1bd84d6e615f7cde9ee">&#9670;&nbsp;</a></span>bilu_backsolve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::bilu_backsolve </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Y &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="a00234.html#_deprecated000003">Deprecated:</a></b></dt><dd>"Will be removed after release 2.8. Use ILU::blockILUBacksolve." <br  />
 </dd></dl>

</div>
</div>
<a id="acfbd5513917454e0e1423e5be13cda74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfbd5513917454e0e1423e5be13cda74">&#9670;&nbsp;</a></span>bilu_decomposition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::bilu_decomposition </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&#160;</td>
          <td class="paramname"><em>ilu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="a00234.html#_deprecated000005">Deprecated:</a></b></dt><dd>"Will be removed after release 2.8. Use ILU::blockILUDecomposition." <br  />
 </dd></dl>

</div>
</div>
<a id="a477c671e3966936ca929dee4be2dcf95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a477c671e3966936ca929dee4be2dcf95">&#9670;&nbsp;</a></span>blockLevel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t Dune::blockLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the block level of a possibly nested vector/matrix type. </p>

</div>
</div>
<a id="aecfad52fbb6f783a2ce3c01aefa7838c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecfad52fbb6f783a2ce3c01aefa7838c">&#9670;&nbsp;</a></span>buildCommunication()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G , class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Dune::buildCommunication </td>
          <td>(</td>
          <td class="paramtype">const G &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>realparts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01963.html">Dune::OwnerOverlapCopyCommunication</a>&lt; T1, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>oocomm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="a01963.html">Dune::OwnerOverlapCopyCommunication</a>&lt; T1, T2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>outcomm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a02619.html">RedistributeInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>redistInf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aba345909b93e7811c7b937e3de3bf381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba345909b93e7811c7b937e3de3bf381">&#9670;&nbsp;</a></span>commGraphRepartition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Dune::commGraphRepartition </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01963.html">Dune::OwnerOverlapCopyCommunication</a>&lt; T1, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>oocomm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00268.html#ab1b879eebd5d32701c7b5879bbe64a17">Metis::idx_t</a>&#160;</td>
          <td class="paramname"><em>nparts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="a01963.html">Dune::OwnerOverlapCopyCommunication</a>&lt; T1, T2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>outcomm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a02619.html">RedistributeInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>redistInf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afaf47e66b019fa82bce1ea1abfba6080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaf47e66b019fa82bce1ea1abfba6080">&#9670;&nbsp;</a></span>createScalarProduct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Comm &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="a02639.html">ScalarProduct</a>&lt;X&gt; &gt; Dune::createScalarProduct </td>
          <td>(</td>
          <td class="paramtype">const Comm &amp;&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a02703.html#ae061380ac961490be6ee353cf0dc1733">SolverCategory::Category</a>&#160;</td>
          <td class="paramname"><em>category</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="section note"><dt>Note</dt><dd>Using this helper, you are responsible for the life-time management of comm </dd></dl>

</div>
</div>
<a id="ad6ff6f6d268c3f382e470135e978eabf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6ff6f6d268c3f382e470135e978eabf">&#9670;&nbsp;</a></span>DUNE_REGISTER_DIRECT_SOLVER()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_REGISTER_DIRECT_SOLVER </td>
          <td>(</td>
          <td class="paramtype">&quot;superlu&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a02851.html">SuperLUCreator</a>()&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f1d7465bf71a0549ed5596e9b142f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f1d7465bf71a0549ed5596e9b142f7f">&#9670;&nbsp;</a></span>DUNE_REGISTER_PRECONDITIONER()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_REGISTER_PRECONDITIONER </td>
          <td>(</td>
          <td class="paramtype">&quot;amg&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a02103.html">AMGCreator</a>()&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a62bc57d5768b1bc98357bac259795327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62bc57d5768b1bc98357bac259795327">&#9670;&nbsp;</a></span>fillIndexSetHoles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G , class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::fillIndexSetHoles </td>
          <td>(</td>
          <td class="paramtype">const G &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01963.html">Dune::OwnerOverlapCopyCommunication</a>&lt; T1, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>oocomm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the holes in an index set. </p>
<p>In general the index set only needs to know those indices where communication my occur. In usual FE computations these are just those near the processor boundaries.</p>
<p>For the repartitioning we need to know all all indices for which data is stored. The missing indices will be created in this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The graph to reparition. </td></tr>
    <tr><td class="paramname">oocomm</td><td>The communication information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3410aebbe1151eaaf477a6229321bbdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3410aebbe1151eaaf477a6229321bbdb">&#9670;&nbsp;</a></span>firstmatrixelement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) Dune::firstmatrixelement </td>
          <td>(</td>
          <td class="paramtype">M &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="a00234.html#_deprecated000004">Deprecated:</a></b></dt><dd>"Will be removed after release 2.8. Use ILU::firstMatrixElement." <br  />
 </dd></dl>

</div>
</div>
<a id="af2f3b70931de2f8f81b08a30865a17c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2f3b70931de2f8f81b08a30865a17c2">&#9670;&nbsp;</a></span>flatMatrixForEach()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::size_t,std::size_t&gt; Dune::flatMatrixForEach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01451.html">Matrix</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>rowOffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>colOffset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverse a blocked matrix and call a functor at each scalar entry. </p>
<p>The functor <code>f</code> is assumed to have the signature</p>
<p>void(auto&amp;&amp; entry, std::size_t rowOffset, std::size_t colOffset)</p>
<p>taking a scalar entry and the current flat offset (index) of both row and column.</p>
<p>The restrictions on the matrix are:</p><ul>
<li>well aligned blocks (otherwise there is no sense in the total number of scalar rows/cols)</li>
<li>all blocks have positive non-zero column / row number</li>
<li>at least one entry must be present if dynamic matrix types are wrapped within other dynamic matrix types</li>
<li>if the block size of a sparse matrix is statically known at compile time, the matrix can be empty</li>
</ul>
<p>The return value is a pair of the total number of scalar rows and columns of the matrix. </p>

</div>
</div>
<a id="a7a87108c26ee37e7e43de1e8b15e4e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a87108c26ee37e7e43de1e8b15e4e67">&#9670;&nbsp;</a></span>flatVectorForEach()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vector , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Dune::flatVectorForEach </td>
          <td>(</td>
          <td class="paramtype">Vector &amp;&amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverse a blocked vector and call a functor at each scalar entry. </p>
<p>The functor <code>f</code> is assumed to have the signature</p>
<p>void(auto&amp;&amp; entry, std::size_t offset)</p>
<p>taking a scalar entry and the current flat offset (index) of this position.</p>
<p>It returns the total number of scalar entries. Similar to <code>dimension()</code> for some DUNE vector types. </p>

</div>
</div>
<a id="a405d30f54803def97082030c715c8791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a405d30f54803def97082030c715c8791">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G , typename EP , typename VM , typename EM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PropertyMapTypeSelector&lt;<a class="el" href="a02415.html">Amg::VertexVisitedTag</a>,<a class="el" href="a02315.html">Amg::PropertiesGraph</a>&lt;G,<a class="el" href="a02175.html">Amg::VertexProperties</a>,EP,VM,EM&gt; &gt;::Type Dune::get </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] const <a class="el" href="a02415.html">Amg::VertexVisitedTag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a02315.html">Amg::PropertiesGraph</a>&lt; G, <a class="el" href="a02175.html">Amg::VertexProperties</a>, EP, VM, EM &gt; &amp;&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8217b8a1761fe09e89c8cfd8a84f21ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8217b8a1761fe09e89c8cfd8a84f21ff">&#9670;&nbsp;</a></span>graphRepartition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G , class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Dune::graphRepartition </td>
          <td>(</td>
          <td class="paramtype">const G &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01963.html">Dune::OwnerOverlapCopyCommunication</a>&lt; T1, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>oocomm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00268.html#ab1b879eebd5d32701c7b5879bbe64a17">Metis::idx_t</a>&#160;</td>
          <td class="paramname"><em>nparts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="a01963.html">Dune::OwnerOverlapCopyCommunication</a>&lt; T1, T2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>outcomm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a02619.html">RedistributeInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>redistInf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>execute a graph repartition for a giving graph and indexset. </p>
<p>This function provides repartition functionality using the PARMETIS library</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">graph</td><td>The given graph to repartition </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">oocomm</td><td>The parallel information about the graph. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nparts</td><td>The number of domains the repartitioning should achieve. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outcomm</td><td>Pointer store the parallel information of the redistributed domains in. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">redistInf</td><td>Redistribute interface </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">verbose</td><td>Verbosity flag to give out additional information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d487fafa117ba8beb053d1c3417dee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d487fafa117ba8beb053d1c3417dee1">&#9670;&nbsp;</a></span>hasUniqueBlockLevel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool Dune::hasUniqueBlockLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if a vector/matrix has a uniquely determinable block level. </p>

</div>
</div>
<a id="aa754fe56e078eb1b50db4ace1e7fc1b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa754fe56e078eb1b50db4ace1e7fc1b1">&#9670;&nbsp;</a></span>isValidGraph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Dune::isValidGraph </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>noVtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>gnoVtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>noEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>xadj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>adjncy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkSymmetry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a13f43ac2f62e510522f7cdb07828a41f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13f43ac2f62e510522f7cdb07828a41f">&#9670;&nbsp;</a></span>makeScalarProduct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Comm &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="a02639.html">ScalarProduct</a>&lt;X&gt; &gt; Dune::makeScalarProduct </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const Comm &gt;&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a02703.html#ae061380ac961490be6ee353cf0dc1733">SolverCategory::Category</a>&#160;</td>
          <td class="paramname"><em>category</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Choose the approriate scalar product for a solver category. </p>
<dl class="todo"><dt><b><a class="el" href="a00233.html#_todo000009">Todo:</a></b></dt><dd>this helper function should be replaced by a proper factory</dd></dl>
<p>As there is only one scalar product for each solver category it is possible to choose the appropriate product at compile time.</p>
<p>In each specialization of the this struct there will be a typedef <a class="el" href="a02639.html" title="Base class for scalar product and norm computation.">ScalarProduct</a> available the defines the type of the scalar product. </p>

</div>
</div>
<a id="a33fa4c0298cf146aa9589b519344907f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33fa4c0298cf146aa9589b519344907f">&#9670;&nbsp;</a></span>maxBlockLevel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t Dune::maxBlockLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the maximum block level of a possibly nested vector/matrix type. </p>

</div>
</div>
<a id="a93a728a69e20c62c789c9e4b616208d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93a728a69e20c62c789c9e4b616208d6">&#9670;&nbsp;</a></span>minBlockLevel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t Dune::minBlockLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the minimum block level of a possibly nested vector/matrix type. </p>

</div>
</div>
<a id="a2d6c22497a84e2ec8803ba78a7e2e988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d6c22497a84e2ec8803ba78a7e2e988">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Dune::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01239.html">BlockVector</a>&lt; K, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send <a class="el" href="a01239.html" title="A vector of blocks with memory management.">BlockVector</a> to an output stream. </p>

</div>
</div>
<a id="a8fd07ea3f22cb47275859d39d7bdffef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fd07ea3f22cb47275859d39d7bdffef">&#9670;&nbsp;</a></span>print_carray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Dune::print_carray </td>
          <td>(</td>
          <td class="paramtype">S &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a131e13bda7cee7fa0c8e4a96e8d46801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a131e13bda7cee7fa0c8e4a96e8d46801">&#9670;&nbsp;</a></span>printGlobalSparseMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::printGlobalSparseMatrix </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>ooc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab59fe4d0a58ea0575b42993d7563d34b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab59fe4d0a58ea0575b42993d7563d34b">&#9670;&nbsp;</a></span>redistributeMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::redistributeMatrix </td>
          <td>(</td>
          <td class="paramtype">M &amp;&#160;</td>
          <td class="paramname"><em>origMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&#160;</td>
          <td class="paramname"><em>newMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>origComm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>newComm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01675.html">RedistributeInformation</a>&lt; C &gt; &amp;&#160;</td>
          <td class="paramname"><em>ri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Redistribute a matrix according to given domain decompositions. </p>
<p>All the parameters for this function can be obtained by calling graphRepartition with the graph of the original matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origMatrix</td><td>The matrix on the original partitioning. </td></tr>
    <tr><td class="paramname">newMatrix</td><td>An empty matrix to store the new redistributed matrix in. </td></tr>
    <tr><td class="paramname">origComm</td><td>The parallel information of the original partitioning. </td></tr>
    <tr><td class="paramname">newComm</td><td>The parallel information of the new partitioning. </td></tr>
    <tr><td class="paramname">ri</td><td>The remote index information between the original and the new partitioning. Upon exit of this method it will be prepared for copying from owner to owner vertices for data redistribution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The matrix type. It is assumed to be sparse. E.g. <a class="el" href="a01155.html" title="A sparse block matrix with compressed row storage.">BCRSMatrix</a>. </td></tr>
    <tr><td class="paramname">C</td><td>The type of the parallel information, see <a class="el" href="a01963.html" title="A class setting up standard communication for a two-valued attribute set with owner/overlap/copy sema...">OwnerOverlapCopyCommunication</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a345908acc30a0bf6affab15d04fcd0a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a345908acc30a0bf6affab15d04fcd0a8">&#9670;&nbsp;</a></span>redistributeMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::redistributeMatrix </td>
          <td>(</td>
          <td class="paramtype">M &amp;&#160;</td>
          <td class="paramname"><em>origMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&#160;</td>
          <td class="paramname"><em>newMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a02411.html">Dune::Amg::SequentialInformation</a> &amp;&#160;</td>
          <td class="paramname"><em>origComm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a02411.html">Dune::Amg::SequentialInformation</a> &amp;&#160;</td>
          <td class="paramname"><em>newComm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01675.html">RedistributeInformation</a>&lt; <a class="el" href="a02411.html">Dune::Amg::SequentialInformation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f63ab17e9c1235103a0512bda341ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f63ab17e9c1235103a0512bda341ca2">&#9670;&nbsp;</a></span>redistributeMatrixEntries() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::redistributeMatrixEntries </td>
          <td>(</td>
          <td class="paramtype">M &amp;&#160;</td>
          <td class="paramname"><em>origMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&#160;</td>
          <td class="paramname"><em>newMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>origComm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>newComm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01675.html">RedistributeInformation</a>&lt; C &gt; &amp;&#160;</td>
          <td class="paramname"><em>ri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a706b106c6123e900b004a90d4dcf42c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a706b106c6123e900b004a90d4dcf42c7">&#9670;&nbsp;</a></span>redistributeMatrixEntries() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::redistributeMatrixEntries </td>
          <td>(</td>
          <td class="paramtype">M &amp;&#160;</td>
          <td class="paramname"><em>origMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&#160;</td>
          <td class="paramname"><em>newMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a02411.html">Dune::Amg::SequentialInformation</a> &amp;&#160;</td>
          <td class="paramname"><em>origComm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a02411.html">Dune::Amg::SequentialInformation</a> &amp;&#160;</td>
          <td class="paramname"><em>newComm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01675.html">RedistributeInformation</a>&lt; <a class="el" href="a02411.html">Dune::Amg::SequentialInformation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a63e2af44500c49cc412112bcc645c7bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63e2af44500c49cc412112bcc645c7bd">&#9670;&nbsp;</a></span>redistributeSparsityPattern()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::redistributeSparsityPattern </td>
          <td>(</td>
          <td class="paramtype">M &amp;&#160;</td>
          <td class="paramname"><em>origMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&#160;</td>
          <td class="paramname"><em>newMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>origComm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>newComm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01675.html">RedistributeInformation</a>&lt; C &gt; &amp;&#160;</td>
          <td class="paramname"><em>ri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
