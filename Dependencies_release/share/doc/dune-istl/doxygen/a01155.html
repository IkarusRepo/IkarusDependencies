<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>dune-istl: Dune::BCRSMatrix&lt; B, A &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">dune-istl
   &#160;<span id="projectnumber">2.8.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00252.html">Dune</a></li><li class="navelem"><a class="el" href="a01155.html">BCRSMatrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="a01152.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Dune::BCRSMatrix&lt; B, A &gt; Class Template Reference<div class="ingroups"><a class="el" href="a00236.html">Iterative Solvers Template Library (ISTL)</a> &raquo; <a class="el" href="a00240.html">Sparse Matrix and Vector classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A sparse block matrix with compressed row storage.  
 <a href="a01155.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00020_source.html">dune/istl/bcrsmatrix.hh</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Dune::BCRSMatrix&lt; B, A &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="a01154.png" border="0" usemap="#a_dune_1_1_b_c_r_s_matrix_3_01_b_00_01_a_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="a_dune_1_1_b_c_r_s_matrix_3_01_b_00_01_a_01_4_inherit__map" id="a_dune_1_1_b_c_r_s_matrix_3_01_b_00_01_a_01_4_inherit__map">
<area shape="rect" title="A sparse block matrix with compressed row storage." alt="" coords="92,5,275,32"/>
<area shape="rect" href="a01155.html" title=" " alt="" coords="105,109,262,151"/>
<area shape="rect" href="a01171.html" title="A block&#45;diagonal matrix." alt="" coords="5,200,169,227"/>
<area shape="rect" href="a01215.html" title="A block&#45;tridiagonal matrix." alt="" coords="194,200,365,227"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01163.html">CreateIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator class for sequential creation of blocks  <a href="a01163.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01167.html">Deallocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class used by shared_ptr to deallocate memory using the proper allocator.  <a href="a01167.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01159.html">RealRowIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator access to matrix rows  <a href="a01159.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab9b0acf9f9613dedc7d93f857c4ae2b7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#ab9b0acf9f9613dedc7d93f857c4ae2b7">BuildStage</a> { <br />
&#160;&#160;<a class="el" href="a01155.html#ab9b0acf9f9613dedc7d93f857c4ae2b7a31ccbde5d5bf1931d8aa6342b887e4d9">notbuilt</a> =0
, <a class="el" href="a01155.html#ab9b0acf9f9613dedc7d93f857c4ae2b7ab598bbcf6b1be00f3e86737ec4b32770">notAllocated</a> =0
, <a class="el" href="a01155.html#ab9b0acf9f9613dedc7d93f857c4ae2b7ab8ebe0b91a94788eadfe7dd910c8114f">building</a> =1
, <a class="el" href="a01155.html#ab9b0acf9f9613dedc7d93f857c4ae2b7a0d4ce3a26588f45f4661065dd7968976">rowSizesBuilt</a> =2
, <br />
&#160;&#160;<a class="el" href="a01155.html#ab9b0acf9f9613dedc7d93f857c4ae2b7a2c7de4fa501570a5a65b74b112c3af51">built</a> =3
<br />
 }</td></tr>
<tr class="separator:ab9b0acf9f9613dedc7d93f857c4ae2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f09a4c408e14428d3a62ad00ceac9ec"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a6f09a4c408e14428d3a62ad00ceac9ec">BuildMode</a> { <a class="el" href="a01155.html#a6f09a4c408e14428d3a62ad00ceac9ecaf7c450c73d8588d16cf4c65552b0ff18">row_wise</a>
, <a class="el" href="a01155.html#a6f09a4c408e14428d3a62ad00ceac9ecad05f70b8e286d23abee639a8d50552e3">random</a>
, <a class="el" href="a01155.html#a6f09a4c408e14428d3a62ad00ceac9eca0b6109e215775999912e5634a2fff10d">implicit</a>
, <a class="el" href="a01155.html#a6f09a4c408e14428d3a62ad00ceac9eca92b68407d7d0300588b1279b91838917">unknown</a>
 }</td></tr>
<tr class="memdesc:a6f09a4c408e14428d3a62ad00ceac9ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">we support two modes  <a href="a01155.html#a6f09a4c408e14428d3a62ad00ceac9ec">More...</a><br /></td></tr>
<tr class="separator:a6f09a4c408e14428d3a62ad00ceac9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036327219e82429eb5056cdcb8029325"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a036327219e82429eb5056cdcb8029325">field_type</a> = typename Imp::BlockTraits&lt; B &gt;::<a class="el" href="a01155.html#a036327219e82429eb5056cdcb8029325">field_type</a></td></tr>
<tr class="memdesc:a036327219e82429eb5056cdcb8029325"><td class="mdescLeft">&#160;</td><td class="mdescRight">export the type representing the field  <a href="a01155.html#a036327219e82429eb5056cdcb8029325">More...</a><br /></td></tr>
<tr class="separator:a036327219e82429eb5056cdcb8029325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27f92bda3724989a12c908d5b0bb355"><td class="memItemLeft" align="right" valign="top">typedef B&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#ac27f92bda3724989a12c908d5b0bb355">block_type</a></td></tr>
<tr class="memdesc:ac27f92bda3724989a12c908d5b0bb355"><td class="mdescLeft">&#160;</td><td class="mdescRight">export the type representing the components  <a href="a01155.html#ac27f92bda3724989a12c908d5b0bb355">More...</a><br /></td></tr>
<tr class="separator:ac27f92bda3724989a12c908d5b0bb355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbabf44198dc84c120bd577ef6166d09"><td class="memItemLeft" align="right" valign="top">typedef A&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#afbabf44198dc84c120bd577ef6166d09">allocator_type</a></td></tr>
<tr class="memdesc:afbabf44198dc84c120bd577ef6166d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">export the allocator type  <a href="a01155.html#afbabf44198dc84c120bd577ef6166d09">More...</a><br /></td></tr>
<tr class="separator:afbabf44198dc84c120bd577ef6166d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81a157954e0da4d4f1b80ad432a5fd4"><td class="memItemLeft" align="right" valign="top">typedef Imp::CompressedBlockVectorWindow&lt; B, A &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#ab81a157954e0da4d4f1b80ad432a5fd4">row_type</a></td></tr>
<tr class="memdesc:ab81a157954e0da4d4f1b80ad432a5fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">implement row_type with compressed vector  <a href="a01155.html#ab81a157954e0da4d4f1b80ad432a5fd4">More...</a><br /></td></tr>
<tr class="separator:ab81a157954e0da4d4f1b80ad432a5fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92dcd5f5afa082cf7c70ca745117108b"><td class="memItemLeft" align="right" valign="top">typedef A::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a></td></tr>
<tr class="memdesc:a92dcd5f5afa082cf7c70ca745117108b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type for the index access and the size.  <a href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">More...</a><br /></td></tr>
<tr class="separator:a92dcd5f5afa082cf7c70ca745117108b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78acdc4dca86c07dbbdf1a779d22a7c0"><td class="memItemLeft" align="right" valign="top">typedef ::<a class="el" href="a01143.html">Dune::CompressionStatistics</a>&lt; <a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a78acdc4dca86c07dbbdf1a779d22a7c0">CompressionStatistics</a></td></tr>
<tr class="memdesc:a78acdc4dca86c07dbbdf1a779d22a7c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type for the statistics object returned by <a class="el" href="a01155.html#ad8da8508e9f65564f91ea6f00934bc3b" title="Finishes the buildstage in implicit mode.">compress()</a>  <a href="a01155.html#a78acdc4dca86c07dbbdf1a779d22a7c0">More...</a><br /></td></tr>
<tr class="separator:a78acdc4dca86c07dbbdf1a779d22a7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6426ed2b23a28e0b942ceb88cad77259"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a01159.html">RealRowIterator</a>&lt; <a class="el" href="a01155.html#ab81a157954e0da4d4f1b80ad432a5fd4">row_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a6426ed2b23a28e0b942ceb88cad77259">iterator</a></td></tr>
<tr class="memdesc:a6426ed2b23a28e0b942ceb88cad77259"><td class="mdescLeft">&#160;</td><td class="mdescRight">The iterator over the (mutable matrix rows.  <a href="a01155.html#a6426ed2b23a28e0b942ceb88cad77259">More...</a><br /></td></tr>
<tr class="separator:a6426ed2b23a28e0b942ceb88cad77259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dbba06948485933958ce9bd74642828"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a01159.html">RealRowIterator</a>&lt; <a class="el" href="a01155.html#ab81a157954e0da4d4f1b80ad432a5fd4">row_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a5dbba06948485933958ce9bd74642828">Iterator</a></td></tr>
<tr class="separator:a5dbba06948485933958ce9bd74642828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2efdf9ce2539b8aead490775ba26dac0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a01155.html#a5dbba06948485933958ce9bd74642828">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a2efdf9ce2539b8aead490775ba26dac0">RowIterator</a></td></tr>
<tr class="memdesc:a2efdf9ce2539b8aead490775ba26dac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">rename the iterators for easier access  <a href="a01155.html#a2efdf9ce2539b8aead490775ba26dac0">More...</a><br /></td></tr>
<tr class="separator:a2efdf9ce2539b8aead490775ba26dac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a2230f988557dfbbc5a2bb7d688fd35"><td class="memItemLeft" align="right" valign="top">typedef row_type::Iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a8a2230f988557dfbbc5a2bb7d688fd35">ColIterator</a></td></tr>
<tr class="memdesc:a8a2230f988557dfbbc5a2bb7d688fd35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator for the entries of each row.  <a href="a01155.html#a8a2230f988557dfbbc5a2bb7d688fd35">More...</a><br /></td></tr>
<tr class="separator:a8a2230f988557dfbbc5a2bb7d688fd35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cec23735a4b8543c573e7b7e01a9bd5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a01159.html">RealRowIterator</a>&lt; const <a class="el" href="a01155.html#ab81a157954e0da4d4f1b80ad432a5fd4">row_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a1cec23735a4b8543c573e7b7e01a9bd5">const_iterator</a></td></tr>
<tr class="memdesc:a1cec23735a4b8543c573e7b7e01a9bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const iterator over the matrix rows.  <a href="a01155.html#a1cec23735a4b8543c573e7b7e01a9bd5">More...</a><br /></td></tr>
<tr class="separator:a1cec23735a4b8543c573e7b7e01a9bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7c8d9c5b05609459f46042339623c6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a01159.html">RealRowIterator</a>&lt; const <a class="el" href="a01155.html#ab81a157954e0da4d4f1b80ad432a5fd4">row_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a6a7c8d9c5b05609459f46042339623c6">ConstIterator</a></td></tr>
<tr class="separator:a6a7c8d9c5b05609459f46042339623c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55aab1eeee5f07e1a1a19318cf196c7c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a01155.html#a6a7c8d9c5b05609459f46042339623c6">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a55aab1eeee5f07e1a1a19318cf196c7c">ConstRowIterator</a></td></tr>
<tr class="memdesc:a55aab1eeee5f07e1a1a19318cf196c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">rename the const row iterator for easier access  <a href="a01155.html#a55aab1eeee5f07e1a1a19318cf196c7c">More...</a><br /></td></tr>
<tr class="separator:a55aab1eeee5f07e1a1a19318cf196c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76d2016ee31d3781ec5d48925251d3b"><td class="memItemLeft" align="right" valign="top">typedef row_type::ConstIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#aa76d2016ee31d3781ec5d48925251d3b">ConstColIterator</a></td></tr>
<tr class="memdesc:aa76d2016ee31d3781ec5d48925251d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const iterator to the entries of a row.  <a href="a01155.html#aa76d2016ee31d3781ec5d48925251d3b">More...</a><br /></td></tr>
<tr class="separator:aa76d2016ee31d3781ec5d48925251d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9a455ff0bc014b25b29a7aca924ee5b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01155.html#ab81a157954e0da4d4f1b80ad432a5fd4">row_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a9a455ff0bc014b25b29a7aca924ee5b8">operator[]</a> (<a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> i)</td></tr>
<tr class="memdesc:a9a455ff0bc014b25b29a7aca924ee5b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">random access to the rows  <a href="a01155.html#a9a455ff0bc014b25b29a7aca924ee5b8">More...</a><br /></td></tr>
<tr class="separator:a9a455ff0bc014b25b29a7aca924ee5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6af1511525cd421479f487fd44ef2b9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a01155.html#ab81a157954e0da4d4f1b80ad432a5fd4">row_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#ac6af1511525cd421479f487fd44ef2b9">operator[]</a> (<a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> i) const</td></tr>
<tr class="memdesc:ac6af1511525cd421479f487fd44ef2b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">same for read only access  <a href="a01155.html#ac6af1511525cd421479f487fd44ef2b9">More...</a><br /></td></tr>
<tr class="separator:ac6af1511525cd421479f487fd44ef2b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad9c5258e0c65fde36f8793fdc96413"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01155.html#a5dbba06948485933958ce9bd74642828">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a0ad9c5258e0c65fde36f8793fdc96413">begin</a> ()</td></tr>
<tr class="memdesc:a0ad9c5258e0c65fde36f8793fdc96413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get iterator to first row.  <a href="a01155.html#a0ad9c5258e0c65fde36f8793fdc96413">More...</a><br /></td></tr>
<tr class="separator:a0ad9c5258e0c65fde36f8793fdc96413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801d09e6e79eba0e588d633e6d9d5049"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01155.html#a5dbba06948485933958ce9bd74642828">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a801d09e6e79eba0e588d633e6d9d5049">end</a> ()</td></tr>
<tr class="memdesc:a801d09e6e79eba0e588d633e6d9d5049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get iterator to one beyond last row.  <a href="a01155.html#a801d09e6e79eba0e588d633e6d9d5049">More...</a><br /></td></tr>
<tr class="separator:a801d09e6e79eba0e588d633e6d9d5049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b470c5f794f9fc941ebc49e8631951"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01155.html#a5dbba06948485933958ce9bd74642828">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#aa4b470c5f794f9fc941ebc49e8631951">beforeEnd</a> ()</td></tr>
<tr class="separator:aa4b470c5f794f9fc941ebc49e8631951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a80e2c47e10c0881b03d78213ab583b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01155.html#a5dbba06948485933958ce9bd74642828">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a6a80e2c47e10c0881b03d78213ab583b">beforeBegin</a> ()</td></tr>
<tr class="separator:a6a80e2c47e10c0881b03d78213ab583b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af721176754c07eab9b0f23824cc52418"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01155.html#a6a7c8d9c5b05609459f46042339623c6">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#af721176754c07eab9b0f23824cc52418">begin</a> () const</td></tr>
<tr class="memdesc:af721176754c07eab9b0f23824cc52418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get const iterator to first row.  <a href="a01155.html#af721176754c07eab9b0f23824cc52418">More...</a><br /></td></tr>
<tr class="separator:af721176754c07eab9b0f23824cc52418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57e3dcf6621aa88b9545fb432ef6b26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01155.html#a6a7c8d9c5b05609459f46042339623c6">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#af57e3dcf6621aa88b9545fb432ef6b26">end</a> () const</td></tr>
<tr class="memdesc:af57e3dcf6621aa88b9545fb432ef6b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get const iterator to one beyond last row.  <a href="a01155.html#af57e3dcf6621aa88b9545fb432ef6b26">More...</a><br /></td></tr>
<tr class="separator:af57e3dcf6621aa88b9545fb432ef6b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8d80654ea7151f9f74f73e1e2b6f0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01155.html#a6a7c8d9c5b05609459f46042339623c6">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#aff8d80654ea7151f9f74f73e1e2b6f0c">beforeEnd</a> () const</td></tr>
<tr class="separator:aff8d80654ea7151f9f74f73e1e2b6f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69042d0e88c4633d0350368629a1985d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01155.html#a6a7c8d9c5b05609459f46042339623c6">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a69042d0e88c4633d0350368629a1985d">beforeBegin</a> () const</td></tr>
<tr class="separator:a69042d0e88c4633d0350368629a1985d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b65fb52b4b7da95999604d8fabba92"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a34b65fb52b4b7da95999604d8fabba92">BCRSMatrix</a> ()</td></tr>
<tr class="memdesc:a34b65fb52b4b7da95999604d8fabba92"><td class="mdescLeft">&#160;</td><td class="mdescRight">an empty matrix  <a href="a01155.html#a34b65fb52b4b7da95999604d8fabba92">More...</a><br /></td></tr>
<tr class="separator:a34b65fb52b4b7da95999604d8fabba92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76bc4d8de5595e723c623f2fc6bb3122"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a76bc4d8de5595e723c623f2fc6bb3122">BCRSMatrix</a> (<a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> _n, <a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> _m, <a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> _nnz, <a class="el" href="a01155.html#a6f09a4c408e14428d3a62ad00ceac9ec">BuildMode</a> bm)</td></tr>
<tr class="memdesc:a76bc4d8de5595e723c623f2fc6bb3122"><td class="mdescLeft">&#160;</td><td class="mdescRight">matrix with known number of nonzeroes  <a href="a01155.html#a76bc4d8de5595e723c623f2fc6bb3122">More...</a><br /></td></tr>
<tr class="separator:a76bc4d8de5595e723c623f2fc6bb3122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbe4d1f81bc548f3be507d6e9a45bff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#acdbe4d1f81bc548f3be507d6e9a45bff">BCRSMatrix</a> (<a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> _n, <a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> _m, <a class="el" href="a01155.html#a6f09a4c408e14428d3a62ad00ceac9ec">BuildMode</a> bm)</td></tr>
<tr class="memdesc:acdbe4d1f81bc548f3be507d6e9a45bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">matrix with unknown number of nonzeroes  <a href="a01155.html#acdbe4d1f81bc548f3be507d6e9a45bff">More...</a><br /></td></tr>
<tr class="separator:acdbe4d1f81bc548f3be507d6e9a45bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d56fd3642d319a2ba06d45b7455e78"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a98d56fd3642d319a2ba06d45b7455e78">BCRSMatrix</a> (<a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> _n, <a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> _m, <a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> _avg, double compressionBufferSize, <a class="el" href="a01155.html#a6f09a4c408e14428d3a62ad00ceac9ec">BuildMode</a> bm)</td></tr>
<tr class="memdesc:a98d56fd3642d319a2ba06d45b7455e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct matrix with a known average number of entries per row  <a href="a01155.html#a98d56fd3642d319a2ba06d45b7455e78">More...</a><br /></td></tr>
<tr class="separator:a98d56fd3642d319a2ba06d45b7455e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a0f0d9b34cada933c1c919cd67416b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a79a0f0d9b34cada933c1c919cd67416b">BCRSMatrix</a> (const <a class="el" href="a01155.html">BCRSMatrix</a> &amp;Mat)</td></tr>
<tr class="memdesc:a79a0f0d9b34cada933c1c919cd67416b"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor  <a href="a01155.html#a79a0f0d9b34cada933c1c919cd67416b">More...</a><br /></td></tr>
<tr class="separator:a79a0f0d9b34cada933c1c919cd67416b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2afb5571f80472c948bd0db3b7440f8f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a2afb5571f80472c948bd0db3b7440f8f">~BCRSMatrix</a> ()</td></tr>
<tr class="memdesc:a2afb5571f80472c948bd0db3b7440f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor  <a href="a01155.html#a2afb5571f80472c948bd0db3b7440f8f">More...</a><br /></td></tr>
<tr class="separator:a2afb5571f80472c948bd0db3b7440f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae747343dfc94f181f31471ceed7e5d4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#ae747343dfc94f181f31471ceed7e5d4a">setBuildMode</a> (<a class="el" href="a01155.html#a6f09a4c408e14428d3a62ad00ceac9ec">BuildMode</a> bm)</td></tr>
<tr class="memdesc:ae747343dfc94f181f31471ceed7e5d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the build mode of the matrix.  <a href="a01155.html#ae747343dfc94f181f31471ceed7e5d4a">More...</a><br /></td></tr>
<tr class="separator:ae747343dfc94f181f31471ceed7e5d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89150f5ae2f2927657bddfb78610e55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#ae89150f5ae2f2927657bddfb78610e55">setSize</a> (<a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> rows, <a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> columns, <a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> nnz=0)</td></tr>
<tr class="memdesc:ae89150f5ae2f2927657bddfb78610e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the size of the matrix.  <a href="a01155.html#ae89150f5ae2f2927657bddfb78610e55">More...</a><br /></td></tr>
<tr class="separator:ae89150f5ae2f2927657bddfb78610e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7ebace380a42cd240d1b65118384a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#acc7ebace380a42cd240d1b65118384a6">setImplicitBuildModeParameters</a> (<a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> _avg, double compressionBufferSize)</td></tr>
<tr class="memdesc:acc7ebace380a42cd240d1b65118384a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set parameters needed for creation in implicit build mode.  <a href="a01155.html#acc7ebace380a42cd240d1b65118384a6">More...</a><br /></td></tr>
<tr class="separator:acc7ebace380a42cd240d1b65118384a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bdbdfb1376f047a9b45fa357ab13861"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01155.html">BCRSMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a2bdbdfb1376f047a9b45fa357ab13861">operator=</a> (const <a class="el" href="a01155.html">BCRSMatrix</a> &amp;Mat)</td></tr>
<tr class="memdesc:a2bdbdfb1376f047a9b45fa357ab13861"><td class="mdescLeft">&#160;</td><td class="mdescRight">assignment  <a href="a01155.html#a2bdbdfb1376f047a9b45fa357ab13861">More...</a><br /></td></tr>
<tr class="separator:a2bdbdfb1376f047a9b45fa357ab13861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb3dea50ab1eac4cb2ab8955af19e82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01155.html">BCRSMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#abcb3dea50ab1eac4cb2ab8955af19e82">operator=</a> (const <a class="el" href="a01155.html#a036327219e82429eb5056cdcb8029325">field_type</a> &amp;k)</td></tr>
<tr class="memdesc:abcb3dea50ab1eac4cb2ab8955af19e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment from a scalar.  <a href="a01155.html#abcb3dea50ab1eac4cb2ab8955af19e82">More...</a><br /></td></tr>
<tr class="separator:abcb3dea50ab1eac4cb2ab8955af19e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9217545ae9d4ea1e3950cf21e6899c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01163.html">CreateIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#ab9217545ae9d4ea1e3950cf21e6899c4">createbegin</a> ()</td></tr>
<tr class="memdesc:ab9217545ae9d4ea1e3950cf21e6899c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">get initial create iterator  <a href="a01155.html#ab9217545ae9d4ea1e3950cf21e6899c4">More...</a><br /></td></tr>
<tr class="separator:ab9217545ae9d4ea1e3950cf21e6899c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0839499f658a2d3e7a5ea908cc86130"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01163.html">CreateIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#aa0839499f658a2d3e7a5ea908cc86130">createend</a> ()</td></tr>
<tr class="memdesc:aa0839499f658a2d3e7a5ea908cc86130"><td class="mdescLeft">&#160;</td><td class="mdescRight">get create iterator pointing to one after the last block  <a href="a01155.html#aa0839499f658a2d3e7a5ea908cc86130">More...</a><br /></td></tr>
<tr class="separator:aa0839499f658a2d3e7a5ea908cc86130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8fdcc48798af5363b9fd8cdf2a4dac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a5a8fdcc48798af5363b9fd8cdf2a4dac">setrowsize</a> (<a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> i, <a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> s)</td></tr>
<tr class="memdesc:a5a8fdcc48798af5363b9fd8cdf2a4dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set number of indices in row i to s.  <a href="a01155.html#a5a8fdcc48798af5363b9fd8cdf2a4dac">More...</a><br /></td></tr>
<tr class="separator:a5a8fdcc48798af5363b9fd8cdf2a4dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf307bf8ed209291680918218906ac6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#aadf307bf8ed209291680918218906ac6">getrowsize</a> (<a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> i) const</td></tr>
<tr class="memdesc:aadf307bf8ed209291680918218906ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">get current number of indices in row i  <a href="a01155.html#aadf307bf8ed209291680918218906ac6">More...</a><br /></td></tr>
<tr class="separator:aadf307bf8ed209291680918218906ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e41b7274abb109855e80f76a66f4d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a41e41b7274abb109855e80f76a66f4d7">incrementrowsize</a> (<a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> i, <a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> s=1)</td></tr>
<tr class="memdesc:a41e41b7274abb109855e80f76a66f4d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">increment size of row i by s (1 by default)  <a href="a01155.html#a41e41b7274abb109855e80f76a66f4d7">More...</a><br /></td></tr>
<tr class="separator:a41e41b7274abb109855e80f76a66f4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebc537e4755cf1ab02ea0dd93c942fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a3ebc537e4755cf1ab02ea0dd93c942fb">endrowsizes</a> ()</td></tr>
<tr class="memdesc:a3ebc537e4755cf1ab02ea0dd93c942fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicate that size of all rows is defined  <a href="a01155.html#a3ebc537e4755cf1ab02ea0dd93c942fb">More...</a><br /></td></tr>
<tr class="separator:a3ebc537e4755cf1ab02ea0dd93c942fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d12c2fa3e3e956e4257aed1bf247ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a82d12c2fa3e3e956e4257aed1bf247ec">addindex</a> (<a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> row, <a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> <a class="el" href="a00240.html#ga67ae04c7e7c030370f82da49ab2b98d1">col</a>)</td></tr>
<tr class="memdesc:a82d12c2fa3e3e956e4257aed1bf247ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">add index (row,col) to the matrix  <a href="a01155.html#a82d12c2fa3e3e956e4257aed1bf247ec">More...</a><br /></td></tr>
<tr class="separator:a82d12c2fa3e3e956e4257aed1bf247ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813bb1a256498169c9e384847721f4a5"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:a813bb1a256498169c9e384847721f4a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01155.html#a813bb1a256498169c9e384847721f4a5">setIndices</a> (<a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> row, It <a class="el" href="a01155.html#a0ad9c5258e0c65fde36f8793fdc96413">begin</a>, It <a class="el" href="a01155.html#a801d09e6e79eba0e588d633e6d9d5049">end</a>)</td></tr>
<tr class="memdesc:a813bb1a256498169c9e384847721f4a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all column indices for row from the given iterator range.  <a href="a01155.html#a813bb1a256498169c9e384847721f4a5">More...</a><br /></td></tr>
<tr class="separator:a813bb1a256498169c9e384847721f4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceeae57760ab2b4c297f19ac8522eef6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#aceeae57760ab2b4c297f19ac8522eef6">endindices</a> ()</td></tr>
<tr class="memdesc:aceeae57760ab2b4c297f19ac8522eef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicate that all indices are defined, check consistency  <a href="a01155.html#aceeae57760ab2b4c297f19ac8522eef6">More...</a><br /></td></tr>
<tr class="separator:aceeae57760ab2b4c297f19ac8522eef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcd06dccd4a9d7350df5c0fbb6d2db8"><td class="memItemLeft" align="right" valign="top">B &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#adbcd06dccd4a9d7350df5c0fbb6d2db8">entry</a> (<a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> row, <a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> <a class="el" href="a00240.html#ga67ae04c7e7c030370f82da49ab2b98d1">col</a>)</td></tr>
<tr class="memdesc:adbcd06dccd4a9d7350df5c0fbb6d2db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to entry (row,col) of the matrix.  <a href="a01155.html#adbcd06dccd4a9d7350df5c0fbb6d2db8">More...</a><br /></td></tr>
<tr class="separator:adbcd06dccd4a9d7350df5c0fbb6d2db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8da8508e9f65564f91ea6f00934bc3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01155.html#a78acdc4dca86c07dbbdf1a779d22a7c0">CompressionStatistics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#ad8da8508e9f65564f91ea6f00934bc3b">compress</a> ()</td></tr>
<tr class="memdesc:ad8da8508e9f65564f91ea6f00934bc3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes the buildstage in implicit mode.  <a href="a01155.html#ad8da8508e9f65564f91ea6f00934bc3b">More...</a><br /></td></tr>
<tr class="separator:ad8da8508e9f65564f91ea6f00934bc3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59f6d33e271ed3acd9223b9535913a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01155.html">BCRSMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#ad59f6d33e271ed3acd9223b9535913a4">operator*=</a> (const <a class="el" href="a01155.html#a036327219e82429eb5056cdcb8029325">field_type</a> &amp;k)</td></tr>
<tr class="memdesc:ad59f6d33e271ed3acd9223b9535913a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector space multiplication with scalar  <a href="a01155.html#ad59f6d33e271ed3acd9223b9535913a4">More...</a><br /></td></tr>
<tr class="separator:ad59f6d33e271ed3acd9223b9535913a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7177e68fadef1d8054c232815759b595"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01155.html">BCRSMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a7177e68fadef1d8054c232815759b595">operator/=</a> (const <a class="el" href="a01155.html#a036327219e82429eb5056cdcb8029325">field_type</a> &amp;k)</td></tr>
<tr class="memdesc:a7177e68fadef1d8054c232815759b595"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector space division by scalar  <a href="a01155.html#a7177e68fadef1d8054c232815759b595">More...</a><br /></td></tr>
<tr class="separator:a7177e68fadef1d8054c232815759b595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa326dc908b26901ec421d3894904f366"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01155.html">BCRSMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#aa326dc908b26901ec421d3894904f366">operator+=</a> (const <a class="el" href="a01155.html">BCRSMatrix</a> &amp;b)</td></tr>
<tr class="memdesc:aa326dc908b26901ec421d3894904f366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the entries of another matrix to this one.  <a href="a01155.html#aa326dc908b26901ec421d3894904f366">More...</a><br /></td></tr>
<tr class="separator:aa326dc908b26901ec421d3894904f366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef4af977012c9eb300262c32079f48f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01155.html">BCRSMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#acef4af977012c9eb300262c32079f48f">operator-=</a> (const <a class="el" href="a01155.html">BCRSMatrix</a> &amp;b)</td></tr>
<tr class="memdesc:acef4af977012c9eb300262c32079f48f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract the entries of another matrix from this one.  <a href="a01155.html#acef4af977012c9eb300262c32079f48f">More...</a><br /></td></tr>
<tr class="separator:acef4af977012c9eb300262c32079f48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16961c0bc920e87cb3d488deed54c63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01155.html">BCRSMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#aa16961c0bc920e87cb3d488deed54c63">axpy</a> (<a class="el" href="a01155.html#a036327219e82429eb5056cdcb8029325">field_type</a> alpha, const <a class="el" href="a01155.html">BCRSMatrix</a> &amp;b)</td></tr>
<tr class="memdesc:aa16961c0bc920e87cb3d488deed54c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the scaled entries of another matrix to this one.  <a href="a01155.html#aa16961c0bc920e87cb3d488deed54c63">More...</a><br /></td></tr>
<tr class="separator:aa16961c0bc920e87cb3d488deed54c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1aed9a57f822ad924d482cfe51cf5fc"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:ac1aed9a57f822ad924d482cfe51cf5fc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01155.html#ac1aed9a57f822ad924d482cfe51cf5fc">mv</a> (const X &amp;x, Y &amp;y) const</td></tr>
<tr class="memdesc:ac1aed9a57f822ad924d482cfe51cf5fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">y = A x  <a href="a01155.html#ac1aed9a57f822ad924d482cfe51cf5fc">More...</a><br /></td></tr>
<tr class="separator:ac1aed9a57f822ad924d482cfe51cf5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92b996f0db8954bd178109e6b5ecca0"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:ac92b996f0db8954bd178109e6b5ecca0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01155.html#ac92b996f0db8954bd178109e6b5ecca0">umv</a> (const X &amp;x, Y &amp;y) const</td></tr>
<tr class="memdesc:ac92b996f0db8954bd178109e6b5ecca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">y += A x  <a href="a01155.html#ac92b996f0db8954bd178109e6b5ecca0">More...</a><br /></td></tr>
<tr class="separator:ac92b996f0db8954bd178109e6b5ecca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf88fa7c6056933790ef9ef3beed9d0c"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:abf88fa7c6056933790ef9ef3beed9d0c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01155.html#abf88fa7c6056933790ef9ef3beed9d0c">mmv</a> (const X &amp;x, Y &amp;y) const</td></tr>
<tr class="memdesc:abf88fa7c6056933790ef9ef3beed9d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">y -= A x  <a href="a01155.html#abf88fa7c6056933790ef9ef3beed9d0c">More...</a><br /></td></tr>
<tr class="separator:abf88fa7c6056933790ef9ef3beed9d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1c771ee60aaa04f581a2e15f3a5cef"><td class="memTemplParams" colspan="2">template&lt;class X , class Y , class F &gt; </td></tr>
<tr class="memitem:aaa1c771ee60aaa04f581a2e15f3a5cef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01155.html#aaa1c771ee60aaa04f581a2e15f3a5cef">usmv</a> (F &amp;&amp;alpha, const X &amp;x, Y &amp;y) const</td></tr>
<tr class="memdesc:aaa1c771ee60aaa04f581a2e15f3a5cef"><td class="mdescLeft">&#160;</td><td class="mdescRight">y += alpha A x  <a href="a01155.html#aaa1c771ee60aaa04f581a2e15f3a5cef">More...</a><br /></td></tr>
<tr class="separator:aaa1c771ee60aaa04f581a2e15f3a5cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c93a4ea67b7f82d91f614eddd898d3"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a48c93a4ea67b7f82d91f614eddd898d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01155.html#a48c93a4ea67b7f82d91f614eddd898d3">mtv</a> (const X &amp;x, Y &amp;y) const</td></tr>
<tr class="memdesc:a48c93a4ea67b7f82d91f614eddd898d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">y = A^T x  <a href="a01155.html#a48c93a4ea67b7f82d91f614eddd898d3">More...</a><br /></td></tr>
<tr class="separator:a48c93a4ea67b7f82d91f614eddd898d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15301031ed46d3f3d0055a5dc34bb14e"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a15301031ed46d3f3d0055a5dc34bb14e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01155.html#a15301031ed46d3f3d0055a5dc34bb14e">umtv</a> (const X &amp;x, Y &amp;y) const</td></tr>
<tr class="memdesc:a15301031ed46d3f3d0055a5dc34bb14e"><td class="mdescLeft">&#160;</td><td class="mdescRight">y += A^T x  <a href="a01155.html#a15301031ed46d3f3d0055a5dc34bb14e">More...</a><br /></td></tr>
<tr class="separator:a15301031ed46d3f3d0055a5dc34bb14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5fefc567a0dd5cd15cc39c2152f74be"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:ac5fefc567a0dd5cd15cc39c2152f74be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01155.html#ac5fefc567a0dd5cd15cc39c2152f74be">mmtv</a> (const X &amp;x, Y &amp;y) const</td></tr>
<tr class="memdesc:ac5fefc567a0dd5cd15cc39c2152f74be"><td class="mdescLeft">&#160;</td><td class="mdescRight">y -= A^T x  <a href="a01155.html#ac5fefc567a0dd5cd15cc39c2152f74be">More...</a><br /></td></tr>
<tr class="separator:ac5fefc567a0dd5cd15cc39c2152f74be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b1a2d615e1b61e0782675e24d3c8f0"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a66b1a2d615e1b61e0782675e24d3c8f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01155.html#a66b1a2d615e1b61e0782675e24d3c8f0">usmtv</a> (const <a class="el" href="a01155.html#a036327219e82429eb5056cdcb8029325">field_type</a> &amp;alpha, const X &amp;x, Y &amp;y) const</td></tr>
<tr class="memdesc:a66b1a2d615e1b61e0782675e24d3c8f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">y += alpha A^T x  <a href="a01155.html#a66b1a2d615e1b61e0782675e24d3c8f0">More...</a><br /></td></tr>
<tr class="separator:a66b1a2d615e1b61e0782675e24d3c8f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49553869d73e239258d2b52653900537"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a49553869d73e239258d2b52653900537"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01155.html#a49553869d73e239258d2b52653900537">umhv</a> (const X &amp;x, Y &amp;y) const</td></tr>
<tr class="memdesc:a49553869d73e239258d2b52653900537"><td class="mdescLeft">&#160;</td><td class="mdescRight">y += A^H x  <a href="a01155.html#a49553869d73e239258d2b52653900537">More...</a><br /></td></tr>
<tr class="separator:a49553869d73e239258d2b52653900537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c57682346c2da57f43b2277244de95"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a10c57682346c2da57f43b2277244de95"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01155.html#a10c57682346c2da57f43b2277244de95">mmhv</a> (const X &amp;x, Y &amp;y) const</td></tr>
<tr class="memdesc:a10c57682346c2da57f43b2277244de95"><td class="mdescLeft">&#160;</td><td class="mdescRight">y -= A^H x  <a href="a01155.html#a10c57682346c2da57f43b2277244de95">More...</a><br /></td></tr>
<tr class="separator:a10c57682346c2da57f43b2277244de95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1351c6ecbca38afaf5c6b7b2da6b48c9"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a1351c6ecbca38afaf5c6b7b2da6b48c9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01155.html#a1351c6ecbca38afaf5c6b7b2da6b48c9">usmhv</a> (const <a class="el" href="a01155.html#a036327219e82429eb5056cdcb8029325">field_type</a> &amp;alpha, const X &amp;x, Y &amp;y) const</td></tr>
<tr class="memdesc:a1351c6ecbca38afaf5c6b7b2da6b48c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">y += alpha A^H x  <a href="a01155.html#a1351c6ecbca38afaf5c6b7b2da6b48c9">More...</a><br /></td></tr>
<tr class="separator:a1351c6ecbca38afaf5c6b7b2da6b48c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719f3e2bbb745700d089a6e56c7ecaaa"><td class="memItemLeft" align="right" valign="top">FieldTraits&lt; <a class="el" href="a01155.html#a036327219e82429eb5056cdcb8029325">field_type</a> &gt;::real_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a719f3e2bbb745700d089a6e56c7ecaaa">frobenius_norm2</a> () const</td></tr>
<tr class="memdesc:a719f3e2bbb745700d089a6e56c7ecaaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">square of frobenius norm, need for block recursion  <a href="a01155.html#a719f3e2bbb745700d089a6e56c7ecaaa">More...</a><br /></td></tr>
<tr class="separator:a719f3e2bbb745700d089a6e56c7ecaaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02263c6c7dfbe056b758fdd4c7f400d1"><td class="memItemLeft" align="right" valign="top">FieldTraits&lt; <a class="el" href="a01155.html#a036327219e82429eb5056cdcb8029325">field_type</a> &gt;::real_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a02263c6c7dfbe056b758fdd4c7f400d1">frobenius_norm</a> () const</td></tr>
<tr class="memdesc:a02263c6c7dfbe056b758fdd4c7f400d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">frobenius norm: sqrt(sum over squared values of entries)  <a href="a01155.html#a02263c6c7dfbe056b758fdd4c7f400d1">More...</a><br /></td></tr>
<tr class="separator:a02263c6c7dfbe056b758fdd4c7f400d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc927f0078c3ec53ac788f8a813f4bb"><td class="memTemplParams" colspan="2">template&lt;typename ft  = field_type, typename std::enable_if&lt;!HasNaN&lt; ft &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a8dc927f0078c3ec53ac788f8a813f4bb"><td class="memTemplItemLeft" align="right" valign="top">FieldTraits&lt; ft &gt;::real_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01155.html#a8dc927f0078c3ec53ac788f8a813f4bb">infinity_norm</a> () const</td></tr>
<tr class="memdesc:a8dc927f0078c3ec53ac788f8a813f4bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">infinity norm (row sum norm, how to generalize for blocks?)  <a href="a01155.html#a8dc927f0078c3ec53ac788f8a813f4bb">More...</a><br /></td></tr>
<tr class="separator:a8dc927f0078c3ec53ac788f8a813f4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c0fd5308531c96ab0fba4cc1077f82"><td class="memTemplParams" colspan="2">template&lt;typename ft  = field_type, typename std::enable_if&lt;!HasNaN&lt; ft &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a52c0fd5308531c96ab0fba4cc1077f82"><td class="memTemplItemLeft" align="right" valign="top">FieldTraits&lt; ft &gt;::real_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01155.html#a52c0fd5308531c96ab0fba4cc1077f82">infinity_norm_real</a> () const</td></tr>
<tr class="memdesc:a52c0fd5308531c96ab0fba4cc1077f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">simplified infinity norm (uses Manhattan norm for complex values)  <a href="a01155.html#a52c0fd5308531c96ab0fba4cc1077f82">More...</a><br /></td></tr>
<tr class="separator:a52c0fd5308531c96ab0fba4cc1077f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc927f0078c3ec53ac788f8a813f4bb"><td class="memTemplParams" colspan="2">template&lt;typename ft  = field_type, typename std::enable_if&lt; HasNaN&lt; ft &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a8dc927f0078c3ec53ac788f8a813f4bb"><td class="memTemplItemLeft" align="right" valign="top">FieldTraits&lt; ft &gt;::real_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01155.html#a8dc927f0078c3ec53ac788f8a813f4bb">infinity_norm</a> () const</td></tr>
<tr class="memdesc:a8dc927f0078c3ec53ac788f8a813f4bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">infinity norm (row sum norm, how to generalize for blocks?)  <a href="a01155.html#a8dc927f0078c3ec53ac788f8a813f4bb">More...</a><br /></td></tr>
<tr class="separator:a8dc927f0078c3ec53ac788f8a813f4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c0fd5308531c96ab0fba4cc1077f82"><td class="memTemplParams" colspan="2">template&lt;typename ft  = field_type, typename std::enable_if&lt; HasNaN&lt; ft &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a52c0fd5308531c96ab0fba4cc1077f82"><td class="memTemplItemLeft" align="right" valign="top">FieldTraits&lt; ft &gt;::real_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01155.html#a52c0fd5308531c96ab0fba4cc1077f82">infinity_norm_real</a> () const</td></tr>
<tr class="memdesc:a52c0fd5308531c96ab0fba4cc1077f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">simplified infinity norm (uses Manhattan norm for complex values)  <a href="a01155.html#a52c0fd5308531c96ab0fba4cc1077f82">More...</a><br /></td></tr>
<tr class="separator:a52c0fd5308531c96ab0fba4cc1077f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae640c4fc5a9343b8836b30733b98f9b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#ae640c4fc5a9343b8836b30733b98f9b4">N</a> () const</td></tr>
<tr class="memdesc:ae640c4fc5a9343b8836b30733b98f9b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of rows (counted in blocks)  <a href="a01155.html#ae640c4fc5a9343b8836b30733b98f9b4">More...</a><br /></td></tr>
<tr class="separator:ae640c4fc5a9343b8836b30733b98f9b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a70ec04bff3b0413020ca6ee2d11c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#ab2a70ec04bff3b0413020ca6ee2d11c9">M</a> () const</td></tr>
<tr class="memdesc:ab2a70ec04bff3b0413020ca6ee2d11c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of columns (counted in blocks)  <a href="a01155.html#ab2a70ec04bff3b0413020ca6ee2d11c9">More...</a><br /></td></tr>
<tr class="separator:ab2a70ec04bff3b0413020ca6ee2d11c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50486320ea446b5c7d37c5dfb5c6ee18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a50486320ea446b5c7d37c5dfb5c6ee18">nonzeroes</a> () const</td></tr>
<tr class="memdesc:a50486320ea446b5c7d37c5dfb5c6ee18"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of blocks that are stored (the number of blocks that possibly are nonzero)  <a href="a01155.html#a50486320ea446b5c7d37c5dfb5c6ee18">More...</a><br /></td></tr>
<tr class="separator:a50486320ea446b5c7d37c5dfb5c6ee18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d86fafc4fcefcadff13ae41a757cc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01155.html#ab9b0acf9f9613dedc7d93f857c4ae2b7">BuildStage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a06d86fafc4fcefcadff13ae41a757cc3">buildStage</a> () const</td></tr>
<tr class="memdesc:a06d86fafc4fcefcadff13ae41a757cc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current build stage of the matrix.  <a href="a01155.html#a06d86fafc4fcefcadff13ae41a757cc3">More...</a><br /></td></tr>
<tr class="separator:a06d86fafc4fcefcadff13ae41a757cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc93aa9afe0bac637589a9cd42a35bcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01155.html#a6f09a4c408e14428d3a62ad00ceac9ec">BuildMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#abc93aa9afe0bac637589a9cd42a35bcf">buildMode</a> () const</td></tr>
<tr class="memdesc:abc93aa9afe0bac637589a9cd42a35bcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The currently selected build mode of the matrix.  <a href="a01155.html#abc93aa9afe0bac637589a9cd42a35bcf">More...</a><br /></td></tr>
<tr class="separator:abc93aa9afe0bac637589a9cd42a35bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ce55f7a7a81dec25717dd9e8fb54e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a05ce55f7a7a81dec25717dd9e8fb54e2">exists</a> (<a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> i, <a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> j) const</td></tr>
<tr class="memdesc:a05ce55f7a7a81dec25717dd9e8fb54e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">return true if (i,j) is in pattern  <a href="a01155.html#a05ce55f7a7a81dec25717dd9e8fb54e2">More...</a><br /></td></tr>
<tr class="separator:a05ce55f7a7a81dec25717dd9e8fb54e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a210d1cadcde1eb99c6f33ee21f52fb5f"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a210d1cadcde1eb99c6f33ee21f52fb5f">blocklevel</a> = <a class="el" href="a00252.html#a477c671e3966936ca929dee4be2dcf95">blockLevel</a>&lt;B&gt;()+1</td></tr>
<tr class="memdesc:a210d1cadcde1eb99c6f33ee21f52fb5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">increment block level counter  <a href="a01155.html#a210d1cadcde1eb99c6f33ee21f52fb5f">More...</a><br /></td></tr>
<tr class="separator:a210d1cadcde1eb99c6f33ee21f52fb5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a846eeb91adc53152aa32531e4621c564"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::pair&lt; <a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>, <a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> &gt;, B &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a846eeb91adc53152aa32531e4621c564">OverflowType</a></td></tr>
<tr class="separator:a846eeb91adc53152aa32531e4621c564"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aec4d821c4ffdb8eaa8e358914be9cd68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#aec4d821c4ffdb8eaa8e358914be9cd68">setWindowPointers</a> (<a class="el" href="a01155.html#a55aab1eeee5f07e1a1a19318cf196c7c">ConstRowIterator</a> row)</td></tr>
<tr class="separator:aec4d821c4ffdb8eaa8e358914be9cd68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af263809fff8f4c4949ad0c364e8f6c55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#af263809fff8f4c4949ad0c364e8f6c55">setColumnPointers</a> (<a class="el" href="a01155.html#a55aab1eeee5f07e1a1a19318cf196c7c">ConstRowIterator</a> row)</td></tr>
<tr class="memdesc:af263809fff8f4c4949ad0c364e8f6c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy row sizes from iterator range starting at row and set column index pointers for all rows.  <a href="a01155.html#af263809fff8f4c4949ad0c364e8f6c55">More...</a><br /></td></tr>
<tr class="separator:af263809fff8f4c4949ad0c364e8f6c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adefb501cd2953cf91eb676db12751482"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#adefb501cd2953cf91eb676db12751482">setDataPointers</a> ()</td></tr>
<tr class="memdesc:adefb501cd2953cf91eb676db12751482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set data pointers for all rows.  <a href="a01155.html#adefb501cd2953cf91eb676db12751482">More...</a><br /></td></tr>
<tr class="separator:adefb501cd2953cf91eb676db12751482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e4b236ed04fd3da227b931312c68386"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a0e4b236ed04fd3da227b931312c68386">copyWindowStructure</a> (const <a class="el" href="a01155.html">BCRSMatrix</a> &amp;Mat)</td></tr>
<tr class="memdesc:a0e4b236ed04fd3da227b931312c68386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the window structure from another matrix.  <a href="a01155.html#a0e4b236ed04fd3da227b931312c68386">More...</a><br /></td></tr>
<tr class="separator:a0e4b236ed04fd3da227b931312c68386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ced2acc98894c921da00d0fbe1bfc87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a2ced2acc98894c921da00d0fbe1bfc87">deallocate</a> (bool deallocateRows=true)</td></tr>
<tr class="memdesc:a2ced2acc98894c921da00d0fbe1bfc87"><td class="mdescLeft">&#160;</td><td class="mdescRight">deallocate memory of the matrix.  <a href="a01155.html#a2ced2acc98894c921da00d0fbe1bfc87">More...</a><br /></td></tr>
<tr class="separator:a2ced2acc98894c921da00d0fbe1bfc87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23538fdea1991446d5ea83d67c11bb70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a23538fdea1991446d5ea83d67c11bb70">allocate</a> (<a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> rows, <a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> columns, <a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> allocationSize, bool allocateRows, bool allocate_data)</td></tr>
<tr class="memdesc:a23538fdea1991446d5ea83d67c11bb70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory for the matrix structure.  <a href="a01155.html#a23538fdea1991446d5ea83d67c11bb70">More...</a><br /></td></tr>
<tr class="separator:a23538fdea1991446d5ea83d67c11bb70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c39e3488286138661eeb60c2a0ff861"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a2c39e3488286138661eeb60c2a0ff861">allocateData</a> ()</td></tr>
<tr class="separator:a2c39e3488286138661eeb60c2a0ff861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc53e4119b13405269be63a31350afcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#acc53e4119b13405269be63a31350afcb">implicit_allocate</a> (<a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> _n, <a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> _m)</td></tr>
<tr class="memdesc:acc53e4119b13405269be63a31350afcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">organizes allocation implicit mode calculates correct array size to be allocated and sets the the window pointers to their correct positions for insertion. internally uses <a class="el" href="a01155.html#a23538fdea1991446d5ea83d67c11bb70" title="Allocate memory for the matrix structure.">allocate()</a> for the real allocation.  <a href="a01155.html#acc53e4119b13405269be63a31350afcb">More...</a><br /></td></tr>
<tr class="separator:acc53e4119b13405269be63a31350afcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a59d53fafbc0e1d8365f374781a542f26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01155.html#a6f09a4c408e14428d3a62ad00ceac9ec">BuildMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a59d53fafbc0e1d8365f374781a542f26">build_mode</a></td></tr>
<tr class="separator:a59d53fafbc0e1d8365f374781a542f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594b2bf93f559ed7c77f9f28e1338462"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01155.html#ab9b0acf9f9613dedc7d93f857c4ae2b7">BuildStage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a594b2bf93f559ed7c77f9f28e1338462">ready</a></td></tr>
<tr class="separator:a594b2bf93f559ed7c77f9f28e1338462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae143d5cdc0f58455669df8cedf8c519b"><td class="memItemLeft" align="right" valign="top">std::allocator_traits&lt; A &gt;::template rebind_alloc&lt; B &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#ae143d5cdc0f58455669df8cedf8c519b">allocator_</a></td></tr>
<tr class="separator:ae143d5cdc0f58455669df8cedf8c519b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04cdd06e79648de953faf5c34a4784c0"><td class="memItemLeft" align="right" valign="top">std::allocator_traits&lt; A &gt;::template rebind_alloc&lt; <a class="el" href="a01155.html#ab81a157954e0da4d4f1b80ad432a5fd4">row_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a04cdd06e79648de953faf5c34a4784c0">rowAllocator_</a></td></tr>
<tr class="separator:a04cdd06e79648de953faf5c34a4784c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c50a313360dd3919050574a2617bef"><td class="memItemLeft" align="right" valign="top">std::allocator_traits&lt; A &gt;::template rebind_alloc&lt; <a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a63c50a313360dd3919050574a2617bef">sizeAllocator_</a></td></tr>
<tr class="separator:a63c50a313360dd3919050574a2617bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab647dfcec2e9b6d7eb859e323d6fed66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#ab647dfcec2e9b6d7eb859e323d6fed66">n</a></td></tr>
<tr class="separator:ab647dfcec2e9b6d7eb859e323d6fed66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a629cfcdbb749dba27ad6bb972e033f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a1a629cfcdbb749dba27ad6bb972e033f">m</a></td></tr>
<tr class="separator:a1a629cfcdbb749dba27ad6bb972e033f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e7991647a57776d254edc890384c0c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a5e7991647a57776d254edc890384c0c1">nnz_</a></td></tr>
<tr class="separator:a5e7991647a57776d254edc890384c0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5227a5dc09391af92221bb06ea12bb31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a5227a5dc09391af92221bb06ea12bb31">allocationSize_</a></td></tr>
<tr class="separator:a5227a5dc09391af92221bb06ea12bb31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811ac6c78bf57efe0f8e6204b486aba6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01155.html#ab81a157954e0da4d4f1b80ad432a5fd4">row_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a811ac6c78bf57efe0f8e6204b486aba6">r</a></td></tr>
<tr class="separator:a811ac6c78bf57efe0f8e6204b486aba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bdbfcac679b19d10ea4b18856ed7798"><td class="memItemLeft" align="right" valign="top">B *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a6bdbfcac679b19d10ea4b18856ed7798">a</a></td></tr>
<tr class="separator:a6bdbfcac679b19d10ea4b18856ed7798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90823e0ce3127042e0c915deeab9b73"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#ae90823e0ce3127042e0c915deeab9b73">j_</a></td></tr>
<tr class="separator:ae90823e0ce3127042e0c915deeab9b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d599e322adb15721b8492d29aee808"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#ac8d599e322adb15721b8492d29aee808">avg</a></td></tr>
<tr class="separator:ac8d599e322adb15721b8492d29aee808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5d660b0ed40ea2cac31d0098c83991"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a1a5d660b0ed40ea2cac31d0098c83991">compressionBufferSize_</a></td></tr>
<tr class="separator:a1a5d660b0ed40ea2cac31d0098c83991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b4f211ba9f8639329fbc3a14e8233b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01155.html#a846eeb91adc53152aa32531e4621c564">OverflowType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01155.html#a96b4f211ba9f8639329fbc3a14e8233b">overflow</a></td></tr>
<tr class="separator:a96b4f211ba9f8639329fbc3a14e8233b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class B, class A = std::allocator&lt;B&gt;&gt;<br />
class Dune::BCRSMatrix&lt; B, A &gt;</h3>

<p>A sparse block matrix with compressed row storage. </p>
<p>Implements a block compressed row storage scheme. The block type B can be any type implementing the matrix interface.</p>
<p>Different ways to build up a compressed row storage matrix are supported:</p>
<ol type="1">
<li>Row-wise scheme</li>
<li>Random scheme</li>
<li>implicit scheme</li>
</ol>
<p>Error checking: no error checking is provided normally. Setting the compile time switch DUNE_ISTL_WITH_CHECKING enables error checking.</p>
<p>Details:</p>
<ol type="1">
<li>Row-wise scheme</li>
</ol>
<p>Rows are built up in sequential order. Size of the row and the column indices are defined. A row can be used as soon as it is initialized. With respect to memory there are two variants of this scheme: (a) number of non-zeroes known in advance (application finite difference schemes), (b) number of non-zeroes not known in advance (application: Sparse LU, ILU(n)).</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include&lt;dune/common/fmatrix.hh&gt;</span></div>
<div class="line"><span class="preprocessor">#include&lt;<a class="code" href="a00020.html">dune/istl/bcrsmatrix.hh</a>&gt;</span></div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">typedef FieldMatrix&lt;double,2,2&gt; <a class="code" href="a01155.html#ab2a70ec04bff3b0413020ca6ee2d11c9">M</a>;</div>
<div class="line"><span class="comment">// third parameter is an optional upper bound for the number</span></div>
<div class="line"><span class="comment">// of nonzeros. If given the matrix will use one array for all values</span></div>
<div class="line"><span class="comment">// as opposed to one for each row.</span></div>
<div class="line">BCRSMatrix&lt;M&gt; B(4,4,12,<a class="code" href="a01155.html#a6f09a4c408e14428d3a62ad00ceac9ecaf7c450c73d8588d16cf4c65552b0ff18">BCRSMatrix&lt;M&gt;::row_wise</a>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="a01155.html#a0e3d1a15a1c40f30085bd50393372d7b">BCRSMatrix&lt;M&gt;::CreateIterator</a> Iter;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(Iter row=B.createbegin(); row!=B.createend(); ++row){</div>
<div class="line">  <span class="comment">// Add nonzeros for left neighbour, diagonal and right neighbour</span></div>
<div class="line">  <span class="keywordflow">if</span>(row.index()&gt;0)</div>
<div class="line">    row.insert(row.index()-1);</div>
<div class="line">  row.insert(row.index());</div>
<div class="line">  <span class="keywordflow">if</span>(row.index()&lt;B.N()-1)</div>
<div class="line">    row.insert(row.index()+1);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now the sparsity pattern is fully set up and we can add values</span></div>
<div class="line"> </div>
<div class="line">B[0][0]=2;</div>
<div class="line">...</div>
<div class="ttc" id="aa00020_html"><div class="ttname"><a href="a00020.html">bcrsmatrix.hh</a></div><div class="ttdoc">Implementation of the BCRSMatrix class.</div></div>
<div class="ttc" id="aa01155_html_a0e3d1a15a1c40f30085bd50393372d7b"><div class="ttname"><a href="a01155.html#a0e3d1a15a1c40f30085bd50393372d7b">Dune::BCRSMatrix::CreateIterator</a></div><div class="ttdeci">friend class CreateIterator</div><div class="ttdoc">allow CreateIterator to access internal data</div><div class="ttdef"><b>Definition:</b> bcrsmatrix.hh:1092</div></div>
<div class="ttc" id="aa01155_html_a6f09a4c408e14428d3a62ad00ceac9ecaf7c450c73d8588d16cf4c65552b0ff18"><div class="ttname"><a href="a01155.html#a6f09a4c408e14428d3a62ad00ceac9ecaf7c450c73d8588d16cf4c65552b0ff18">Dune::BCRSMatrix::row_wise</a></div><div class="ttdeci">@ row_wise</div><div class="ttdoc">Build in a row-wise manner.</div><div class="ttdef"><b>Definition:</b> bcrsmatrix.hh:519</div></div>
<div class="ttc" id="aa01155_html_ab2a70ec04bff3b0413020ca6ee2d11c9"><div class="ttname"><a href="a01155.html#ab2a70ec04bff3b0413020ca6ee2d11c9">Dune::BCRSMatrix::M</a></div><div class="ttdeci">size_type M() const</div><div class="ttdoc">number of columns (counted in blocks)</div><div class="ttdef"><b>Definition:</b> bcrsmatrix.hh:1976</div></div>
</div><!-- fragment --><ol type="1">
<li>Random scheme</li>
</ol>
<p>For general finite element implementations the number of rows n is known, the number of non-zeroes might also be known (e.g. #edges + #nodes for P2) but the size of a row and the indices of a row can not be defined in sequential order.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include&lt;dune/common/fmatrix.hh&gt;</span></div>
<div class="line"><span class="preprocessor">#include&lt;<a class="code" href="a00020.html">dune/istl/bcrsmatrix.hh</a>&gt;</span></div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">typedef FieldMatrix&lt;double,2,2&gt; <a class="code" href="a01155.html#ab2a70ec04bff3b0413020ca6ee2d11c9">M</a>;</div>
<div class="line">BCRSMatrix&lt;M&gt; B(4,4,<a class="code" href="a01155.html#a6f09a4c408e14428d3a62ad00ceac9ecad05f70b8e286d23abee639a8d50552e3">BCRSMatrix&lt;M&gt;::random</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// initially set row size for each row</span></div>
<div class="line">B.setrowsize(0,1);</div>
<div class="line">B.setrowsize(3,4);</div>
<div class="line">B.setrowsize(2,1);</div>
<div class="line">B.setrowsize(1,1);</div>
<div class="line"><span class="comment">// increase row size for row 2</span></div>
<div class="line">B.incrementrowsize(2);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// finalize row setup phase</span></div>
<div class="line">B.endrowsizes();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// add column entries to rows</span></div>
<div class="line">B.addindex(0,0);</div>
<div class="line">B.addindex(3,1);</div>
<div class="line">B.addindex(2,2);</div>
<div class="line">B.addindex(1,1);</div>
<div class="line">B.addindex(2,0);</div>
<div class="line">B.addindex(3,2);</div>
<div class="line">B.addindex(3,0);</div>
<div class="line">B.addindex(3,3);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// finalize column setup phase</span></div>
<div class="line">B.endindices();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// set entries using the random access operator</span></div>
<div class="line">B[0][0] = 1;</div>
<div class="line">B[1][1] = 2;</div>
<div class="line">B[2][0] = 3;</div>
<div class="line">B[2][2] = 4;</div>
<div class="line">B[3][1] = 5;</div>
<div class="line">B[3][2] = 6;</div>
<div class="line">B[3][0] = 7;</div>
<div class="line">B[3][3] = 8;</div>
<div class="ttc" id="aa01155_html_a6f09a4c408e14428d3a62ad00ceac9ecad05f70b8e286d23abee639a8d50552e3"><div class="ttname"><a href="a01155.html#a6f09a4c408e14428d3a62ad00ceac9ecad05f70b8e286d23abee639a8d50552e3">Dune::BCRSMatrix::random</a></div><div class="ttdeci">@ random</div><div class="ttdoc">Build entries randomly.</div><div class="ttdef"><b>Definition:</b> bcrsmatrix.hh:528</div></div>
</div><!-- fragment --><ol type="1">
<li>implicit scheme</li>
</ol>
<p>With the 'random scheme` described above, the sparsity pattern has to be determined and stored before the matrix is assembled. This requires a dedicated iteration over the grid elements, which can be costly in terms of time. Also, additional memory is needed to store the pattern before it can be given to the 'random' build mode.</p>
<p>On the other hand, often one has good a priori knowledge about the number of entries a row contains on average. The <code>implicit</code> mode tries to make use of that knowledge, and allows the setup of matrix pattern and numerical values together.</p>
<p>Constructing and filling a <a class="el" href="a01155.html" title="A sparse block matrix with compressed row storage.">BCRSMatrix</a> with the 'implicit' mode is performed in two steps: In a setup phase, matrix entries with numerical values can be inserted into the matrix. Then, a compression algorithm is called which defragments and optimizes the memory layout. After this compression step, the matrix is ready to be used, and no further nonzero entries can be added.</p>
<p>To use this mode, either construct a matrix object via</p>
<ul>
<li><a class="el" href="a01155.html#a98d56fd3642d319a2ba06d45b7455e78" title="construct matrix with a known average number of entries per row">BCRSMatrix(size_type _n, size_type _m, size_type _avg, double compressionBufferSize, BuildMode bm)</a></li>
</ul>
<p>or default-construct the matrix and then call</p><ul>
<li><a class="el" href="a01155.html#acc7ebace380a42cd240d1b65118384a6" title="Set parameters needed for creation in implicit build mode.">setImplicitBuildModeParameters(size_type _avg, double compressionBufferSize)</a></li>
<li>setSize(size_type rows, size_type columns, size_type nnz=0)</li>
</ul>
<p>The parameter <code>_avg</code> specifies the expected number of (block) entries per matrix row.</p>
<p>When the <a class="el" href="a01155.html" title="A sparse block matrix with compressed row storage.">BCRSMatrix</a> object is first constructed with the 'implicit' build mode, two areas for matrix entry storage are allocated:</p>
<p>1) A large continuous chunk of memory that can hold the expected number of entries. In addition, this chunk contains an extra part of memory called the 'compression buffer', located before the memory for the matrix itself. The size of this buffer will be <code>_avg * _n * compressionBufferSize</code>.</p>
<p>2) An associative container indexed by <img class="formulaInl" alt="$i,j$" src="form_19.png"/>-pairs, which will hold surplus matrix entries during the setup phase (the 'overflow area'). Its content is merged into the main memory during compression.</p>
<p>You can then start filling your matrix by calling <a class="el" href="a01155.html#adbcd06dccd4a9d7350df5c0fbb6d2db8" title="Returns reference to entry (row,col) of the matrix.">entry(size_type row, size_type col)</a>, which returns the corresponding matrix entry, creating it on the fly if it does not exist yet. The matrix pattern is hence created implicitly by simply accessing nonzero entries during the initial matrix assembly. Note that new entries are not zero-initialized, though, and hence the first operation on each entry has to be an assignment.</p>
<p>If a row contains more non-zero entries than what was specified in the _avg parameter, the surplus entries are stored in the 'overflow area' during the initial setup phase. After all indices are added, call <a class="el" href="a01155.html#ad8da8508e9f65564f91ea6f00934bc3b" title="Finishes the buildstage in implicit mode.">compress()</a> to trigger the compression step that optimizes the matrix and integrates any entries from the overflow area into the standard BCRS storage. This compression step builds up the final memory layout row by row. It will fail with an exception if the compression buffer is not large enough, which would lead to compressed rows overwriting uncompressed ones. More precisely, if <img class="formulaInl" alt="$\textrm{nnz}_j$" src="form_20.png"/> denotes the number of non-zeros in the <img class="formulaInl" alt="$j$" src="form_21.png"/>-th row, then the compression algorithm will succeed if the maximal number of non-zeros in the <img class="formulaInl" alt="$i$" src="form_22.png"/>-th row is </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ M_i = \textrm{avg} + A + \sum_{j&lt;i} (\textrm{avg} - \textrm{nnz}_j) \]" src="form_23.png"/>
</p>
<p> for all <img class="formulaInl" alt="$i$" src="form_22.png"/>, where <img class="formulaInl" alt="$ A = \textrm{avg}(n \cdot \textrm{compressionBufferSize}) $" src="form_24.png"/> is the total size of the compression buffer determined by the parameters explained above.</p>
<p>The data of the matrix is now located at the beginning of the allocated area, and covers what used to be the compression buffer. In exchange, there is now unused space at the end of the large allocated piece of memory. This will go unused and cannot be freed during the lifetime of the matrix, but it has no negative impact on run-time performance. No matrix entries may be added after the compression step.</p>
<p>The <a class="el" href="a01155.html#ad8da8508e9f65564f91ea6f00934bc3b" title="Finishes the buildstage in implicit mode.">compress()</a> method returns a value of type <a class="el" href="a01143.html" title="Statistics about compression achieved in implicit mode.">Dune::CompressionStatistics</a>, which you can inspect to tune the construction parameters <code>_avg</code> and <code>compressionBufferSize</code>.</p>
<p>Use of copy constructor, assignment operator and matrix vector arithmetics are not supported until the matrix is fully built.</p>
<p>The following sample code constructs a <img class="formulaInl" alt="$ 10 \times 10$" src="form_25.png"/> matrix, with an expected number of two entries per matrix row. The compression buffer size is set to 0.4. Hence the main chunk of allocated memory will be able to hold <code>10 * 2</code> entries in the matrix rows, and <code>10 * 2 * 0.4</code> entries in the compression buffer. In total that's 28 entries. </p><div class="fragment"><div class="line"><span class="preprocessor">#include&lt;<a class="code" href="a00020.html">dune/istl/bcrsmatrix.hh</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="a01155.html">Dune::BCRSMatrix&lt;double&gt;</a> <a class="code" href="a01155.html#ab2a70ec04bff3b0413020ca6ee2d11c9">M</a>;</div>
<div class="line"><a class="code" href="a01155.html#ab2a70ec04bff3b0413020ca6ee2d11c9">M</a> <a class="code" href="a01155.html#a1a629cfcdbb749dba27ad6bb972e033f">m</a>(10, 10, 2, 0.4, M::implicit);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fill in some arbitrary entries; the order is irrelevant.</span></div>
<div class="line"><span class="comment">// Even operations on these would be possible, you get a reference to the entry!</span></div>
<div class="line"><a class="code" href="a01155.html#a1a629cfcdbb749dba27ad6bb972e033f">m</a>.entry(0,0) = 0.;</div>
<div class="line"><a class="code" href="a01155.html#a1a629cfcdbb749dba27ad6bb972e033f">m</a>.entry(8,0) = 0.;</div>
<div class="line"><a class="code" href="a01155.html#a1a629cfcdbb749dba27ad6bb972e033f">m</a>.entry(1,8) = 0.; <a class="code" href="a01155.html#a1a629cfcdbb749dba27ad6bb972e033f">m</a>.entry(1,0) = 0.; <a class="code" href="a01155.html#a1a629cfcdbb749dba27ad6bb972e033f">m</a>.entry(1,5) = 0.;</div>
<div class="line"><a class="code" href="a01155.html#a1a629cfcdbb749dba27ad6bb972e033f">m</a>.entry(2,0) = 0.;</div>
<div class="line"><a class="code" href="a01155.html#a1a629cfcdbb749dba27ad6bb972e033f">m</a>.entry(3,5) = 0.; <a class="code" href="a01155.html#a1a629cfcdbb749dba27ad6bb972e033f">m</a>.entry(3,0) = 0.;  <a class="code" href="a01155.html#a1a629cfcdbb749dba27ad6bb972e033f">m</a>.entry(3,8) = 0.;</div>
<div class="line"><a class="code" href="a01155.html#a1a629cfcdbb749dba27ad6bb972e033f">m</a>.entry(4,0) = 0.;</div>
<div class="line"><a class="code" href="a01155.html#a1a629cfcdbb749dba27ad6bb972e033f">m</a>.entry(9,0) = 0.; <a class="code" href="a01155.html#a1a629cfcdbb749dba27ad6bb972e033f">m</a>.entry(9,5) = 0.; <a class="code" href="a01155.html#a1a629cfcdbb749dba27ad6bb972e033f">m</a>.entry(9,8) = 0.;</div>
<div class="line"><a class="code" href="a01155.html#a1a629cfcdbb749dba27ad6bb972e033f">m</a>.entry(5,0) = 0.; <a class="code" href="a01155.html#a1a629cfcdbb749dba27ad6bb972e033f">m</a>.entry(5,5) = 0.; <a class="code" href="a01155.html#a1a629cfcdbb749dba27ad6bb972e033f">m</a>.entry(5,8) = 0.;</div>
<div class="line"><a class="code" href="a01155.html#a1a629cfcdbb749dba27ad6bb972e033f">m</a>.entry(6,0) = 0.;</div>
<div class="line"><a class="code" href="a01155.html#a1a629cfcdbb749dba27ad6bb972e033f">m</a>.entry(7,0) = 0.; <a class="code" href="a01155.html#a1a629cfcdbb749dba27ad6bb972e033f">m</a>.entry(7,5) = 0.; <a class="code" href="a01155.html#a1a629cfcdbb749dba27ad6bb972e033f">m</a>.entry(7,8) = 0.;</div>
<div class="ttc" id="aa01155_html"><div class="ttname"><a href="a01155.html">Dune::BCRSMatrix</a></div><div class="ttdoc">A sparse block matrix with compressed row storage.</div><div class="ttdef"><b>Definition:</b> bcrsmatrix.hh:464</div></div>
<div class="ttc" id="aa01155_html_a1a629cfcdbb749dba27ad6bb972e033f"><div class="ttname"><a href="a01155.html#a1a629cfcdbb749dba27ad6bb972e033f">Dune::BCRSMatrix::m</a></div><div class="ttdeci">size_type m</div><div class="ttdef"><b>Definition:</b> bcrsmatrix.hh:2029</div></div>
</div><!-- fragment --><p>Internally the index array now looks like this: </p><div class="fragment"><div class="line"><span class="comment">// xxxxxxxx0x800x500x050x050x05</span></div>
<div class="line"><span class="comment">// ........|.|.|.|.|.|.|.|.|.|.</span></div>
</div><!-- fragment --><p> The second row denotes the beginnings of the matrix rows. The eight 'x' on the left are the compression buffer. The overflow area contains the entries (1,5,0.0), (3,8,0.0), (5,8,0.0), (7,8,0.0), and (9,8,0.0). These are entries of rows 1, 3, 5, 7, and 9, which have three entries each, even though only two were anticipated.</p>
<div class="fragment"><div class="line"><span class="comment">//finish building by compressing the array</span></div>
<div class="line"><a class="code" href="a01143.html">Dune::CompressionStatistics&lt;M::size_type&gt;</a> stats = <a class="code" href="a01155.html#a1a629cfcdbb749dba27ad6bb972e033f">m</a>.compress();</div>
<div class="ttc" id="aa01143_html"><div class="ttname"><a href="a01143.html">Dune::CompressionStatistics</a></div><div class="ttdoc">Statistics about compression achieved in implicit mode.</div><div class="ttdef"><b>Definition:</b> bcrsmatrix.hh:86</div></div>
</div><!-- fragment --><p>Internally the index array now looks like this: </p><div class="fragment"><div class="line"><span class="comment">// 00580058005800580058xxxxxxxx</span></div>
<div class="line"><span class="comment">// ||..||..||..||..||..........</span></div>
</div><!-- fragment --><p> The compression buffer on the left is gone now, and the matrix has a real CRS layout. The 'x' on the right will be unused for the rest of the matrix' lifetime. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="afbabf44198dc84c120bd577ef6166d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbabf44198dc84c120bd577ef6166d09">&#9670;&nbsp;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef A <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::<a class="el" href="a01155.html#afbabf44198dc84c120bd577ef6166d09">allocator_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>export the allocator type </p>

</div>
</div>
<a id="ac27f92bda3724989a12c908d5b0bb355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac27f92bda3724989a12c908d5b0bb355">&#9670;&nbsp;</a></span>block_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef B <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::<a class="el" href="a01155.html#ac27f92bda3724989a12c908d5b0bb355">block_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>export the type representing the components </p>

</div>
</div>
<a id="a8a2230f988557dfbbc5a2bb7d688fd35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a2230f988557dfbbc5a2bb7d688fd35">&#9670;&nbsp;</a></span>ColIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef row_type::Iterator <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::<a class="el" href="a01155.html#a8a2230f988557dfbbc5a2bb7d688fd35">ColIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator for the entries of each row. </p>

</div>
</div>
<a id="a78acdc4dca86c07dbbdf1a779d22a7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78acdc4dca86c07dbbdf1a779d22a7c0">&#9670;&nbsp;</a></span>CompressionStatistics</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ::<a class="el" href="a01143.html">Dune::CompressionStatistics</a>&lt;<a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&gt; <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::<a class="el" href="a01155.html#a78acdc4dca86c07dbbdf1a779d22a7c0">CompressionStatistics</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type for the statistics object returned by <a class="el" href="a01155.html#ad8da8508e9f65564f91ea6f00934bc3b" title="Finishes the buildstage in implicit mode.">compress()</a> </p>

</div>
</div>
<a id="a1cec23735a4b8543c573e7b7e01a9bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cec23735a4b8543c573e7b7e01a9bd5">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a01159.html">RealRowIterator</a>&lt;const <a class="el" href="a01155.html#ab81a157954e0da4d4f1b80ad432a5fd4">row_type</a>&gt; <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::<a class="el" href="a01155.html#a1cec23735a4b8543c573e7b7e01a9bd5">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The const iterator over the matrix rows. </p>

</div>
</div>
<a id="aa76d2016ee31d3781ec5d48925251d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa76d2016ee31d3781ec5d48925251d3b">&#9670;&nbsp;</a></span>ConstColIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef row_type::ConstIterator <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::<a class="el" href="a01155.html#aa76d2016ee31d3781ec5d48925251d3b">ConstColIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const iterator to the entries of a row. </p>

</div>
</div>
<a id="a6a7c8d9c5b05609459f46042339623c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a7c8d9c5b05609459f46042339623c6">&#9670;&nbsp;</a></span>ConstIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a01159.html">RealRowIterator</a>&lt;const <a class="el" href="a01155.html#ab81a157954e0da4d4f1b80ad432a5fd4">row_type</a>&gt; <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::<a class="el" href="a01155.html#a6a7c8d9c5b05609459f46042339623c6">ConstIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a55aab1eeee5f07e1a1a19318cf196c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55aab1eeee5f07e1a1a19318cf196c7c">&#9670;&nbsp;</a></span>ConstRowIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a01155.html#a6a7c8d9c5b05609459f46042339623c6">ConstIterator</a> <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::<a class="el" href="a01155.html#a55aab1eeee5f07e1a1a19318cf196c7c">ConstRowIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>rename the const row iterator for easier access </p>

</div>
</div>
<a id="a036327219e82429eb5056cdcb8029325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036327219e82429eb5056cdcb8029325">&#9670;&nbsp;</a></span>field_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::<a class="el" href="a01155.html#a036327219e82429eb5056cdcb8029325">field_type</a> =  typename Imp::BlockTraits&lt;B&gt;::<a class="el" href="a01155.html#a036327219e82429eb5056cdcb8029325">field_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>export the type representing the field </p>

</div>
</div>
<a id="a6426ed2b23a28e0b942ceb88cad77259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6426ed2b23a28e0b942ceb88cad77259">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a01159.html">RealRowIterator</a>&lt;<a class="el" href="a01155.html#ab81a157954e0da4d4f1b80ad432a5fd4">row_type</a>&gt; <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::<a class="el" href="a01155.html#a6426ed2b23a28e0b942ceb88cad77259">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The iterator over the (mutable matrix rows. </p>

</div>
</div>
<a id="a5dbba06948485933958ce9bd74642828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dbba06948485933958ce9bd74642828">&#9670;&nbsp;</a></span>Iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a01159.html">RealRowIterator</a>&lt;<a class="el" href="a01155.html#ab81a157954e0da4d4f1b80ad432a5fd4">row_type</a>&gt; <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::<a class="el" href="a01155.html#a5dbba06948485933958ce9bd74642828">Iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a846eeb91adc53152aa32531e4621c564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a846eeb91adc53152aa32531e4621c564">&#9670;&nbsp;</a></span>OverflowType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::pair&lt;<a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>,<a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&gt;, B&gt; <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::<a class="el" href="a01155.html#a846eeb91adc53152aa32531e4621c564">OverflowType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab81a157954e0da4d4f1b80ad432a5fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab81a157954e0da4d4f1b80ad432a5fd4">&#9670;&nbsp;</a></span>row_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Imp::CompressedBlockVectorWindow&lt;B,A&gt; <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::<a class="el" href="a01155.html#ab81a157954e0da4d4f1b80ad432a5fd4">row_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>implement row_type with compressed vector </p>

</div>
</div>
<a id="a2efdf9ce2539b8aead490775ba26dac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2efdf9ce2539b8aead490775ba26dac0">&#9670;&nbsp;</a></span>RowIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a01155.html#a5dbba06948485933958ce9bd74642828">Iterator</a> <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::<a class="el" href="a01155.html#a2efdf9ce2539b8aead490775ba26dac0">RowIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>rename the iterators for easier access </p>

</div>
</div>
<a id="a92dcd5f5afa082cf7c70ca745117108b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92dcd5f5afa082cf7c70ca745117108b">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef A::size_type <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::<a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type for the index access and the size. </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a6f09a4c408e14428d3a62ad00ceac9ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f09a4c408e14428d3a62ad00ceac9ec">&#9670;&nbsp;</a></span>BuildMode</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a01155.html#a6f09a4c408e14428d3a62ad00ceac9ec">Dune::BCRSMatrix::BuildMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>we support two modes </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6f09a4c408e14428d3a62ad00ceac9ecaf7c450c73d8588d16cf4c65552b0ff18"></a>row_wise&#160;</td><td class="fielddoc"><p>Build in a row-wise manner. </p>
<p>Rows are built up in sequential order. Size of the row and the column indices are defined. A row can be used as soon as it is initialized. With respect to memory there are two variants of this scheme: (a) number of non-zeroes known in advance (application finite difference schemes), (b) number of non-zeroes not known in advance (application: Sparse LU, ILU(n)). </p>
</td></tr>
<tr><td class="fieldname"><a id="a6f09a4c408e14428d3a62ad00ceac9ecad05f70b8e286d23abee639a8d50552e3"></a>random&#160;</td><td class="fielddoc"><p>Build entries randomly. </p>
<p>For general finite element implementations the number of rows n is known, the number of non-zeroes might also be known (e.g. #edges + #nodes for P2) but the size of a row and the indices of a row cannot be defined in sequential order. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6f09a4c408e14428d3a62ad00ceac9eca0b6109e215775999912e5634a2fff10d"></a>implicit&#160;</td><td class="fielddoc"><p>Build entries randomly with an educated guess for the number of entries per row. </p>
<p>Allows random order generation as in random mode, but row sizes do not need to be given first. Instead an average number of non-zeroes per row is passed to the constructor. <a class="el" href="a01451.html" title="A generic dynamic dense matrix.">Matrix</a> setup is finished with <a class="el" href="a01155.html#ad8da8508e9f65564f91ea6f00934bc3b" title="Finishes the buildstage in implicit mode.">compress()</a>, full data access during build stage is possible. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6f09a4c408e14428d3a62ad00ceac9eca92b68407d7d0300588b1279b91838917"></a>unknown&#160;</td><td class="fielddoc"><p>Build mode not set! </p>
</td></tr>
</table>

</div>
</div>
<a id="ab9b0acf9f9613dedc7d93f857c4ae2b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9b0acf9f9613dedc7d93f857c4ae2b7">&#9670;&nbsp;</a></span>BuildStage</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a01155.html#ab9b0acf9f9613dedc7d93f857c4ae2b7">Dune::BCRSMatrix::BuildStage</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab9b0acf9f9613dedc7d93f857c4ae2b7a31ccbde5d5bf1931d8aa6342b887e4d9"></a>notbuilt&#160;</td><td class="fielddoc"><p><a class="el" href="a01451.html" title="A generic dynamic dense matrix.">Matrix</a> is not built at all, no memory has been allocated, build mode and size can still be set. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab9b0acf9f9613dedc7d93f857c4ae2b7ab598bbcf6b1be00f3e86737ec4b32770"></a>notAllocated&#160;</td><td class="fielddoc"><p><a class="el" href="a01451.html" title="A generic dynamic dense matrix.">Matrix</a> is not built at all, no memory has been allocated, build mode and size can still be set. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab9b0acf9f9613dedc7d93f857c4ae2b7ab8ebe0b91a94788eadfe7dd910c8114f"></a>building&#160;</td><td class="fielddoc"><p><a class="el" href="a01451.html" title="A generic dynamic dense matrix.">Matrix</a> is currently being built, some memory has been allocated, build mode and size are fixed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab9b0acf9f9613dedc7d93f857c4ae2b7a0d4ce3a26588f45f4661065dd7968976"></a>rowSizesBuilt&#160;</td><td class="fielddoc"><p>The row sizes of the matrix are known. </p>
<pre class="fragment"> Only used in random mode.
</pre> </td></tr>
<tr><td class="fieldname"><a id="ab9b0acf9f9613dedc7d93f857c4ae2b7a2c7de4fa501570a5a65b74b112c3af51"></a>built&#160;</td><td class="fielddoc"><p>The matrix structure is fully built. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a34b65fb52b4b7da95999604d8fabba92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34b65fb52b4b7da95999604d8fabba92">&#9670;&nbsp;</a></span>BCRSMatrix() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::<a class="el" href="a01155.html">BCRSMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>an empty matrix </p>

</div>
</div>
<a id="a76bc4d8de5595e723c623f2fc6bb3122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76bc4d8de5595e723c623f2fc6bb3122">&#9670;&nbsp;</a></span>BCRSMatrix() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::<a class="el" href="a01155.html">BCRSMatrix</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td>
          <td class="paramname"><em>_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td>
          <td class="paramname"><em>_m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td>
          <td class="paramname"><em>_nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01155.html#a6f09a4c408e14428d3a62ad00ceac9ec">BuildMode</a>&#160;</td>
          <td class="paramname"><em>bm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>matrix with known number of nonzeroes </p>

</div>
</div>
<a id="acdbe4d1f81bc548f3be507d6e9a45bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdbe4d1f81bc548f3be507d6e9a45bff">&#9670;&nbsp;</a></span>BCRSMatrix() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::<a class="el" href="a01155.html">BCRSMatrix</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td>
          <td class="paramname"><em>_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td>
          <td class="paramname"><em>_m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01155.html#a6f09a4c408e14428d3a62ad00ceac9ec">BuildMode</a>&#160;</td>
          <td class="paramname"><em>bm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>matrix with unknown number of nonzeroes </p>

</div>
</div>
<a id="a98d56fd3642d319a2ba06d45b7455e78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d56fd3642d319a2ba06d45b7455e78">&#9670;&nbsp;</a></span>BCRSMatrix() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::<a class="el" href="a01155.html">BCRSMatrix</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td>
          <td class="paramname"><em>_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td>
          <td class="paramname"><em>_m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td>
          <td class="paramname"><em>_avg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>compressionBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01155.html#a6f09a4c408e14428d3a62ad00ceac9ec">BuildMode</a>&#160;</td>
          <td class="paramname"><em>bm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>construct matrix with a known average number of entries per row </p>
<p>Constructs a matrix in implicit buildmode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_n</td><td>number of rows of the matrix </td></tr>
    <tr><td class="paramname">_m</td><td>number of columns of the matrix </td></tr>
    <tr><td class="paramname">_avg</td><td>expected average number of entries per row </td></tr>
    <tr><td class="paramname">compressionBufferSize</td><td>fraction of _n*_avg which is expected to be needed for elements that exceed _avg entries per row. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79a0f0d9b34cada933c1c919cd67416b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79a0f0d9b34cada933c1c919cd67416b">&#9670;&nbsp;</a></span>BCRSMatrix() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::<a class="el" href="a01155.html">BCRSMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01155.html">BCRSMatrix</a>&lt; B, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>Mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy constructor </p>
<p>Does a deep copy as expected. </p>

</div>
</div>
<a id="a2afb5571f80472c948bd0db3b7440f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2afb5571f80472c948bd0db3b7440f8f">&#9670;&nbsp;</a></span>~BCRSMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::~<a class="el" href="a01155.html">BCRSMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>destructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a82d12c2fa3e3e956e4257aed1bf247ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82d12c2fa3e3e956e4257aed1bf247ec">&#9670;&nbsp;</a></span>addindex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::addindex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add index (row,col) to the matrix </p>
<p>This method can only be used when building the <a class="el" href="a01155.html" title="A sparse block matrix with compressed row storage.">BCRSMatrix</a> in random mode.</p>
<p>addindex adds a new column entry to the row. If this column entry already exists, nothing is done.</p>
<p>Don't call addindex after the setup phase is finished (after endindices is called). </p>

</div>
</div>
<a id="a23538fdea1991446d5ea83d67c11bb70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23538fdea1991446d5ea83d67c11bb70">&#9670;&nbsp;</a></span>allocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td>
          <td class="paramname"><em>allocationSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allocateRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allocate_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate memory for the matrix structure. </p>
<p>Sets the number of rows and columns of the matrix and allocates the memory needed for the storage of the matrix entries.</p>
<dl class="section warning"><dt>Warning</dt><dd>After calling this methods on an already allocated (and probably setup matrix) results in all the structure and data being lost. Please call <a class="el" href="a01155.html#a2ced2acc98894c921da00d0fbe1bfc87" title="deallocate memory of the matrix.">deallocate()</a> before calling allocate in this case.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>The number of rows the matrix should contain. </td></tr>
    <tr><td class="paramname">columns</td><td>the number of columns the matrix should contain. </td></tr>
    <tr><td class="paramname">allocationSize</td><td>The number of nonzero entries the matrix should hold (if omitted defaults to 0). </td></tr>
    <tr><td class="paramname">allocateRow</td><td>Whether we have to allocate the row pointers, too. (Defaults to true) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c39e3488286138661eeb60c2a0ff861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c39e3488286138661eeb60c2a0ff861">&#9670;&nbsp;</a></span>allocateData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::allocateData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa16961c0bc920e87cb3d488deed54c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16961c0bc920e87cb3d488deed54c63">&#9670;&nbsp;</a></span>axpy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01155.html">BCRSMatrix</a>&amp; <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::axpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01155.html#a036327219e82429eb5056cdcb8029325">field_type</a>&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01155.html">BCRSMatrix</a>&lt; B, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the scaled entries of another matrix to this one. </p>
<p><a class="el" href="a01451.html" title="A generic dynamic dense matrix.">Matrix</a> axpy operation: *this += alpha * b</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>Scaling factor. </td></tr>
    <tr><td class="paramname">b</td><td>The matrix to add to this one. Its sparsity pattern has to be subset of the sparsity pattern of this matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a80e2c47e10c0881b03d78213ab583b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a80e2c47e10c0881b03d78213ab583b">&#9670;&nbsp;</a></span>beforeBegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01155.html#a5dbba06948485933958ce9bd74642828">Iterator</a> <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::beforeBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an iterator that is positioned before the first row of the matrix. </dd></dl>

</div>
</div>
<a id="a69042d0e88c4633d0350368629a1985d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69042d0e88c4633d0350368629a1985d">&#9670;&nbsp;</a></span>beforeBegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01155.html#a6a7c8d9c5b05609459f46042339623c6">ConstIterator</a> <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::beforeBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an iterator that is positioned before the first row of the matrix. </dd></dl>

</div>
</div>
<a id="aa4b470c5f794f9fc941ebc49e8631951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b470c5f794f9fc941ebc49e8631951">&#9670;&nbsp;</a></span>beforeEnd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01155.html#a5dbba06948485933958ce9bd74642828">Iterator</a> <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::beforeEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an iterator that is positioned before the end iterator of the rows, i.e. at the last row. </dd></dl>

</div>
</div>
<a id="aff8d80654ea7151f9f74f73e1e2b6f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff8d80654ea7151f9f74f73e1e2b6f0c">&#9670;&nbsp;</a></span>beforeEnd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01155.html#a6a7c8d9c5b05609459f46042339623c6">ConstIterator</a> <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::beforeEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an iterator that is positioned before the end iterator of the rows. i.e. at the last row. </dd></dl>

</div>
</div>
<a id="a0ad9c5258e0c65fde36f8793fdc96413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad9c5258e0c65fde36f8793fdc96413">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01155.html#a5dbba06948485933958ce9bd74642828">Iterator</a> <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get iterator to first row. </p>

</div>
</div>
<a id="af721176754c07eab9b0f23824cc52418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af721176754c07eab9b0f23824cc52418">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01155.html#a6a7c8d9c5b05609459f46042339623c6">ConstIterator</a> <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get const iterator to first row. </p>

</div>
</div>
<a id="abc93aa9afe0bac637589a9cd42a35bcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc93aa9afe0bac637589a9cd42a35bcf">&#9670;&nbsp;</a></span>buildMode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01155.html#a6f09a4c408e14428d3a62ad00ceac9ec">BuildMode</a> <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::buildMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The currently selected build mode of the matrix. </p>

</div>
</div>
<a id="a06d86fafc4fcefcadff13ae41a757cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06d86fafc4fcefcadff13ae41a757cc3">&#9670;&nbsp;</a></span>buildStage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01155.html#ab9b0acf9f9613dedc7d93f857c4ae2b7">BuildStage</a> <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::buildStage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current build stage of the matrix. </p>

</div>
</div>
<a id="ad8da8508e9f65564f91ea6f00934bc3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8da8508e9f65564f91ea6f00934bc3b">&#9670;&nbsp;</a></span>compress()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01155.html#a78acdc4dca86c07dbbdf1a779d22a7c0">CompressionStatistics</a> <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::compress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finishes the buildstage in implicit mode. </p>
<p>Performs compression of index and data arrays with linear complexity in the number of nonzeroes.</p>
<p>After calling this method, the matrix is in the built state and no more entries can be added.</p>
<dl class="section return"><dt>Returns</dt><dd>An object with some statistics about the compression for future optimization. </dd></dl>

</div>
</div>
<a id="a0e4b236ed04fd3da227b931312c68386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e4b236ed04fd3da227b931312c68386">&#9670;&nbsp;</a></span>copyWindowStructure()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::copyWindowStructure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01155.html">BCRSMatrix</a>&lt; B, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>Mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the window structure from another matrix. </p>

</div>
</div>
<a id="ab9217545ae9d4ea1e3950cf21e6899c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9217545ae9d4ea1e3950cf21e6899c4">&#9670;&nbsp;</a></span>createbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01163.html">CreateIterator</a> <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::createbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get initial create iterator </p>

</div>
</div>
<a id="aa0839499f658a2d3e7a5ea908cc86130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0839499f658a2d3e7a5ea908cc86130">&#9670;&nbsp;</a></span>createend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01163.html">CreateIterator</a> <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::createend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get create iterator pointing to one after the last block </p>

</div>
</div>
<a id="a2ced2acc98894c921da00d0fbe1bfc87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ced2acc98894c921da00d0fbe1bfc87">&#9670;&nbsp;</a></span>deallocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::deallocate </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deallocateRows</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>deallocate memory of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deallocateRows</td><td>Whether we have to deallocate the row pointers, too. If false they will not be touched. (Defaults to true). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a801d09e6e79eba0e588d633e6d9d5049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a801d09e6e79eba0e588d633e6d9d5049">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01155.html#a5dbba06948485933958ce9bd74642828">Iterator</a> <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get iterator to one beyond last row. </p>

</div>
</div>
<a id="af57e3dcf6621aa88b9545fb432ef6b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af57e3dcf6621aa88b9545fb432ef6b26">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01155.html#a6a7c8d9c5b05609459f46042339623c6">ConstIterator</a> <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get const iterator to one beyond last row. </p>

</div>
</div>
<a id="aceeae57760ab2b4c297f19ac8522eef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceeae57760ab2b4c297f19ac8522eef6">&#9670;&nbsp;</a></span>endindices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::endindices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>indicate that all indices are defined, check consistency </p>

</div>
</div>
<a id="a3ebc537e4755cf1ab02ea0dd93c942fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ebc537e4755cf1ab02ea0dd93c942fb">&#9670;&nbsp;</a></span>endrowsizes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::endrowsizes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>indicate that size of all rows is defined </p>

</div>
</div>
<a id="adbcd06dccd4a9d7350df5c0fbb6d2db8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbcd06dccd4a9d7350df5c0fbb6d2db8">&#9670;&nbsp;</a></span>entry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">B&amp; <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns reference to entry (row,col) of the matrix. </p>
<p>This method can only be used when the matrix is in implicit building mode.</p>
<p>A reference to entry (row, col) of the matrix is returned. If entry (row, col) is accessed for the first time, it is created on the fly.</p>
<p>This method can only be used while building the matrix, after compression operator[] gives a much better performance. </p>

</div>
</div>
<a id="a05ce55f7a7a81dec25717dd9e8fb54e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ce55f7a7a81dec25717dd9e8fb54e2">&#9670;&nbsp;</a></span>exists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::<a class="el" href="a01087.html">exists</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return true if (i,j) is in pattern </p>

</div>
</div>
<a id="a02263c6c7dfbe056b758fdd4c7f400d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02263c6c7dfbe056b758fdd4c7f400d1">&#9670;&nbsp;</a></span>frobenius_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FieldTraits&lt;<a class="el" href="a01155.html#a036327219e82429eb5056cdcb8029325">field_type</a>&gt;::real_type <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::frobenius_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>frobenius norm: sqrt(sum over squared values of entries) </p>

</div>
</div>
<a id="a719f3e2bbb745700d089a6e56c7ecaaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719f3e2bbb745700d089a6e56c7ecaaa">&#9670;&nbsp;</a></span>frobenius_norm2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FieldTraits&lt;<a class="el" href="a01155.html#a036327219e82429eb5056cdcb8029325">field_type</a>&gt;::real_type <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::frobenius_norm2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>square of frobenius norm, need for block recursion </p>

</div>
</div>
<a id="aadf307bf8ed209291680918218906ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadf307bf8ed209291680918218906ac6">&#9670;&nbsp;</a></span>getrowsize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::getrowsize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get current number of indices in row i </p>

</div>
</div>
<a id="acc53e4119b13405269be63a31350afcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc53e4119b13405269be63a31350afcb">&#9670;&nbsp;</a></span>implicit_allocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::implicit_allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td>
          <td class="paramname"><em>_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td>
          <td class="paramname"><em>_m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>organizes allocation implicit mode calculates correct array size to be allocated and sets the the window pointers to their correct positions for insertion. internally uses <a class="el" href="a01155.html#a23538fdea1991446d5ea83d67c11bb70" title="Allocate memory for the matrix structure.">allocate()</a> for the real allocation. </p>

</div>
</div>
<a id="a41e41b7274abb109855e80f76a66f4d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41e41b7274abb109855e80f76a66f4d7">&#9670;&nbsp;</a></span>incrementrowsize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::incrementrowsize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td>
          <td class="paramname"><em>s</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>increment size of row i by s (1 by default) </p>

</div>
</div>
<a id="a8dc927f0078c3ec53ac788f8a813f4bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dc927f0078c3ec53ac788f8a813f4bb">&#9670;&nbsp;</a></span>infinity_norm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ft  = field_type, typename std::enable_if&lt;!HasNaN&lt; ft &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FieldTraits&lt;ft&gt;::real_type <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::infinity_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>infinity norm (row sum norm, how to generalize for blocks?) </p>

</div>
</div>
<a id="a8dc927f0078c3ec53ac788f8a813f4bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dc927f0078c3ec53ac788f8a813f4bb">&#9670;&nbsp;</a></span>infinity_norm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ft  = field_type, typename std::enable_if&lt; HasNaN&lt; ft &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FieldTraits&lt;ft&gt;::real_type <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::infinity_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>infinity norm (row sum norm, how to generalize for blocks?) </p>

</div>
</div>
<a id="a52c0fd5308531c96ab0fba4cc1077f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52c0fd5308531c96ab0fba4cc1077f82">&#9670;&nbsp;</a></span>infinity_norm_real() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ft  = field_type, typename std::enable_if&lt;!HasNaN&lt; ft &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FieldTraits&lt;ft&gt;::real_type <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::infinity_norm_real </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>simplified infinity norm (uses Manhattan norm for complex values) </p>

</div>
</div>
<a id="a52c0fd5308531c96ab0fba4cc1077f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52c0fd5308531c96ab0fba4cc1077f82">&#9670;&nbsp;</a></span>infinity_norm_real() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ft  = field_type, typename std::enable_if&lt; HasNaN&lt; ft &gt;::value, int &gt;::type  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FieldTraits&lt;ft&gt;::real_type <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::infinity_norm_real </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>simplified infinity norm (uses Manhattan norm for complex values) </p>

</div>
</div>
<a id="ab2a70ec04bff3b0413020ca6ee2d11c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2a70ec04bff3b0413020ca6ee2d11c9">&#9670;&nbsp;</a></span>M()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::M </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>number of columns (counted in blocks) </p>

</div>
</div>
<a id="a10c57682346c2da57f43b2277244de95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10c57682346c2da57f43b2277244de95">&#9670;&nbsp;</a></span>mmhv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::mmhv </td>
          <td>(</td>
          <td class="paramtype">const X &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>y -= A^H x </p>

</div>
</div>
<a id="ac5fefc567a0dd5cd15cc39c2152f74be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5fefc567a0dd5cd15cc39c2152f74be">&#9670;&nbsp;</a></span>mmtv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::mmtv </td>
          <td>(</td>
          <td class="paramtype">const X &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>y -= A^T x </p>

</div>
</div>
<a id="abf88fa7c6056933790ef9ef3beed9d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf88fa7c6056933790ef9ef3beed9d0c">&#9670;&nbsp;</a></span>mmv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::mmv </td>
          <td>(</td>
          <td class="paramtype">const X &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>y -= A x </p>

</div>
</div>
<a id="a48c93a4ea67b7f82d91f614eddd898d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48c93a4ea67b7f82d91f614eddd898d3">&#9670;&nbsp;</a></span>mtv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::mtv </td>
          <td>(</td>
          <td class="paramtype">const X &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>y = A^T x </p>

</div>
</div>
<a id="ac1aed9a57f822ad924d482cfe51cf5fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1aed9a57f822ad924d482cfe51cf5fc">&#9670;&nbsp;</a></span>mv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::mv </td>
          <td>(</td>
          <td class="paramtype">const X &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>y = A x </p>

</div>
</div>
<a id="ae640c4fc5a9343b8836b30733b98f9b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae640c4fc5a9343b8836b30733b98f9b4">&#9670;&nbsp;</a></span>N()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::N </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>number of rows (counted in blocks) </p>

</div>
</div>
<a id="a50486320ea446b5c7d37c5dfb5c6ee18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50486320ea446b5c7d37c5dfb5c6ee18">&#9670;&nbsp;</a></span>nonzeroes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::nonzeroes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>number of blocks that are stored (the number of blocks that possibly are nonzero) </p>

</div>
</div>
<a id="ad59f6d33e271ed3acd9223b9535913a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad59f6d33e271ed3acd9223b9535913a4">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01155.html">BCRSMatrix</a>&amp; <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01155.html#a036327219e82429eb5056cdcb8029325">field_type</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>vector space multiplication with scalar </p>

</div>
</div>
<a id="aa326dc908b26901ec421d3894904f366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa326dc908b26901ec421d3894904f366">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01155.html">BCRSMatrix</a>&amp; <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01155.html">BCRSMatrix</a>&lt; B, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the entries of another matrix to this one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The matrix to add to this one. Its sparsity pattern has to be subset of the sparsity pattern of this matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acef4af977012c9eb300262c32079f48f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acef4af977012c9eb300262c32079f48f">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01155.html">BCRSMatrix</a>&amp; <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01155.html">BCRSMatrix</a>&lt; B, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtract the entries of another matrix from this one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The matrix to subtract from this one. Its sparsity pattern has to be subset of the sparsity pattern of this matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7177e68fadef1d8054c232815759b595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7177e68fadef1d8054c232815759b595">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01155.html">BCRSMatrix</a>&amp; <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01155.html#a036327219e82429eb5056cdcb8029325">field_type</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>vector space division by scalar </p>

</div>
</div>
<a id="a2bdbdfb1376f047a9b45fa357ab13861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bdbdfb1376f047a9b45fa357ab13861">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01155.html">BCRSMatrix</a>&amp; <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01155.html">BCRSMatrix</a>&lt; B, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>Mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>assignment </p>
<p>Frees and reallocates space. Both sparsity pattern and values are set from Mat. </p>

</div>
</div>
<a id="abcb3dea50ab1eac4cb2ab8955af19e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcb3dea50ab1eac4cb2ab8955af19e82">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01155.html">BCRSMatrix</a>&amp; <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01155.html#a036327219e82429eb5056cdcb8029325">field_type</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment from a scalar. </p>

</div>
</div>
<a id="a9a455ff0bc014b25b29a7aca924ee5b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a455ff0bc014b25b29a7aca924ee5b8">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01155.html#ab81a157954e0da4d4f1b80ad432a5fd4">row_type</a>&amp; <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>random access to the rows </p>

</div>
</div>
<a id="ac6af1511525cd421479f487fd44ef2b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6af1511525cd421479f487fd44ef2b9">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a01155.html#ab81a157954e0da4d4f1b80ad432a5fd4">row_type</a>&amp; <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>same for read only access </p>

</div>
</div>
<a id="ae747343dfc94f181f31471ceed7e5d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae747343dfc94f181f31471ceed7e5d4a">&#9670;&nbsp;</a></span>setBuildMode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::setBuildMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01155.html#a6f09a4c408e14428d3a62ad00ceac9ec">BuildMode</a>&#160;</td>
          <td class="paramname"><em>bm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the build mode of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bm</td><td>The build mode to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af263809fff8f4c4949ad0c364e8f6c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af263809fff8f4c4949ad0c364e8f6c55">&#9670;&nbsp;</a></span>setColumnPointers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::setColumnPointers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01155.html#a55aab1eeee5f07e1a1a19318cf196c7c">ConstRowIterator</a>&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy row sizes from iterator range starting at row and set column index pointers for all rows. </p>
<p>This method does not modify the data pointers, as those are set only after building the pattern (to allow for a delayed allocation). </p>

</div>
</div>
<a id="adefb501cd2953cf91eb676db12751482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adefb501cd2953cf91eb676db12751482">&#9670;&nbsp;</a></span>setDataPointers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::setDataPointers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set data pointers for all rows. </p>
<p>This method assumes that column pointers and row sizes have been correctly set up by a prior call to <a class="el" href="a01155.html#af263809fff8f4c4949ad0c364e8f6c55" title="Copy row sizes from iterator range starting at row and set column index pointers for all rows.">setColumnPointers()</a>. </p>

</div>
</div>
<a id="acc7ebace380a42cd240d1b65118384a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc7ebace380a42cd240d1b65118384a6">&#9670;&nbsp;</a></span>setImplicitBuildModeParameters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::setImplicitBuildModeParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td>
          <td class="paramname"><em>_avg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>compressionBufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set parameters needed for creation in implicit build mode. </p>
<p>Use this method before <a class="el" href="a01155.html#ae89150f5ae2f2927657bddfb78610e55" title="Set the size of the matrix.">setSize()</a> to define storage behaviour of a matrix in implicit build mode </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_avg</td><td>expected average number of entries per row </td></tr>
    <tr><td class="paramname">compressionBufferSize</td><td>fraction of _n*_avg which is expected to be needed for elements that exceed _avg entries per row. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a813bb1a256498169c9e384847721f4a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a813bb1a256498169c9e384847721f4a5">&#9670;&nbsp;</a></span>setIndices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::setIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all column indices for row from the given iterator range. </p>
<p>The iterator range has to be of the same length as the previously set row size. The entries in the iterator range do not have to be in any particular order, but must not contain duplicate values.</p>
<p>Calling this method overwrites any previously set column indices! </p>

</div>
</div>
<a id="a5a8fdcc48798af5363b9fd8cdf2a4dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a8fdcc48798af5363b9fd8cdf2a4dac">&#9670;&nbsp;</a></span>setrowsize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::setrowsize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set number of indices in row i to s. </p>
<p>The number s may actually be larger than the true number of nonzero entries in row i. In that case, the extra memory goes wasted. You will receive run-time warnings about this, sent to the Dune::dwarn stream. </p>

</div>
</div>
<a id="ae89150f5ae2f2927657bddfb78610e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae89150f5ae2f2927657bddfb78610e55">&#9670;&nbsp;</a></span>setSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::setSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&#160;</td>
          <td class="paramname"><em>nnz</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the size of the matrix. </p>
<p>Sets the number of rows and columns of the matrix and allocates the memory needed for the storage of the matrix entries.</p>
<dl class="section warning"><dt>Warning</dt><dd>After calling this methods on an already allocated (and probably setup matrix) results in all the structure and data being deleted. I.~e. one has to setup the matrix again.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The number of rows the matrix should contain. </td></tr>
    <tr><td class="paramname">columns</td><td>the number of columns the matrix should contain. </td></tr>
    <tr><td class="paramname">nnz</td><td>The number of nonzero entries the matrix should hold (if omitted defaults to 0). Must be omitted in implicit mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec4d821c4ffdb8eaa8e358914be9cd68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec4d821c4ffdb8eaa8e358914be9cd68">&#9670;&nbsp;</a></span>setWindowPointers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::setWindowPointers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01155.html#a55aab1eeee5f07e1a1a19318cf196c7c">ConstRowIterator</a>&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a49553869d73e239258d2b52653900537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49553869d73e239258d2b52653900537">&#9670;&nbsp;</a></span>umhv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::umhv </td>
          <td>(</td>
          <td class="paramtype">const X &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>y += A^H x </p>

</div>
</div>
<a id="a15301031ed46d3f3d0055a5dc34bb14e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15301031ed46d3f3d0055a5dc34bb14e">&#9670;&nbsp;</a></span>umtv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::umtv </td>
          <td>(</td>
          <td class="paramtype">const X &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>y += A^T x </p>

</div>
</div>
<a id="ac92b996f0db8954bd178109e6b5ecca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac92b996f0db8954bd178109e6b5ecca0">&#9670;&nbsp;</a></span>umv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::umv </td>
          <td>(</td>
          <td class="paramtype">const X &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>y += A x </p>

</div>
</div>
<a id="a1351c6ecbca38afaf5c6b7b2da6b48c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1351c6ecbca38afaf5c6b7b2da6b48c9">&#9670;&nbsp;</a></span>usmhv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::usmhv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01155.html#a036327219e82429eb5056cdcb8029325">field_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>y += alpha A^H x </p>

</div>
</div>
<a id="a66b1a2d615e1b61e0782675e24d3c8f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b1a2d615e1b61e0782675e24d3c8f0">&#9670;&nbsp;</a></span>usmtv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::usmtv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01155.html#a036327219e82429eb5056cdcb8029325">field_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>y += alpha A^T x </p>

</div>
</div>
<a id="aaa1c771ee60aaa04f581a2e15f3a5cef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa1c771ee60aaa04f581a2e15f3a5cef">&#9670;&nbsp;</a></span>usmv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<div class="memtemplate">
template&lt;class X , class Y , class F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::usmv </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>y += alpha A x </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a6bdbfcac679b19d10ea4b18856ed7798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bdbfcac679b19d10ea4b18856ed7798">&#9670;&nbsp;</a></span>a</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">B* <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::a</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5227a5dc09391af92221bb06ea12bb31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5227a5dc09391af92221bb06ea12bb31">&#9670;&nbsp;</a></span>allocationSize_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::allocationSize_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae143d5cdc0f58455669df8cedf8c519b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae143d5cdc0f58455669df8cedf8c519b">&#9670;&nbsp;</a></span>allocator_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::allocator_traits&lt;A&gt;::template rebind_alloc&lt;B&gt; <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::allocator_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8d599e322adb15721b8492d29aee808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8d599e322adb15721b8492d29aee808">&#9670;&nbsp;</a></span>avg</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::avg</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a210d1cadcde1eb99c6f33ee21f52fb5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a210d1cadcde1eb99c6f33ee21f52fb5f">&#9670;&nbsp;</a></span>blocklevel</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned int <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::blocklevel = <a class="el" href="a00252.html#a477c671e3966936ca929dee4be2dcf95">blockLevel</a>&lt;B&gt;()+1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>increment block level counter </p>

</div>
</div>
<a id="a59d53fafbc0e1d8365f374781a542f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d53fafbc0e1d8365f374781a542f26">&#9670;&nbsp;</a></span>build_mode</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01155.html#a6f09a4c408e14428d3a62ad00ceac9ec">BuildMode</a> <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::build_mode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a5d660b0ed40ea2cac31d0098c83991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a5d660b0ed40ea2cac31d0098c83991">&#9670;&nbsp;</a></span>compressionBufferSize_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::compressionBufferSize_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae90823e0ce3127042e0c915deeab9b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90823e0ce3127042e0c915deeab9b73">&#9670;&nbsp;</a></span>j_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&gt; <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::j_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a629cfcdbb749dba27ad6bb972e033f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a629cfcdbb749dba27ad6bb972e033f">&#9670;&nbsp;</a></span>m</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::m</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab647dfcec2e9b6d7eb859e323d6fed66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab647dfcec2e9b6d7eb859e323d6fed66">&#9670;&nbsp;</a></span>n</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::n</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5e7991647a57776d254edc890384c0c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e7991647a57776d254edc890384c0c1">&#9670;&nbsp;</a></span>nnz_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a> <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::nnz_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a96b4f211ba9f8639329fbc3a14e8233b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96b4f211ba9f8639329fbc3a14e8233b">&#9670;&nbsp;</a></span>overflow</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01155.html#a846eeb91adc53152aa32531e4621c564">OverflowType</a> <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::overflow</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a811ac6c78bf57efe0f8e6204b486aba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a811ac6c78bf57efe0f8e6204b486aba6">&#9670;&nbsp;</a></span>r</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01155.html#ab81a157954e0da4d4f1b80ad432a5fd4">row_type</a>* <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::r</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a594b2bf93f559ed7c77f9f28e1338462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a594b2bf93f559ed7c77f9f28e1338462">&#9670;&nbsp;</a></span>ready</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01155.html#ab9b0acf9f9613dedc7d93f857c4ae2b7">BuildStage</a> <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::ready</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a04cdd06e79648de953faf5c34a4784c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04cdd06e79648de953faf5c34a4784c0">&#9670;&nbsp;</a></span>rowAllocator_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::allocator_traits&lt;A&gt;::template rebind_alloc&lt;<a class="el" href="a01155.html#ab81a157954e0da4d4f1b80ad432a5fd4">row_type</a>&gt; <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::rowAllocator_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a63c50a313360dd3919050574a2617bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63c50a313360dd3919050574a2617bef">&#9670;&nbsp;</a></span>sizeAllocator_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::allocator_traits&lt;A&gt;::template rebind_alloc&lt;<a class="el" href="a01155.html#a92dcd5f5afa082cf7c70ca745117108b">size_type</a>&gt; <a class="el" href="a01155.html">Dune::BCRSMatrix</a>&lt; B, A &gt;::sizeAllocator_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="a00020_source.html">bcrsmatrix.hh</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
