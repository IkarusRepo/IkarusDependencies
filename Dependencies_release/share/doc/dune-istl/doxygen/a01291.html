<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>dune-istl: Dune::PowerIteration_Algorithms&lt; BCRSMatrix, BlockVector &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">dune-istl
   &#160;<span id="projectnumber">2.8.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00252.html">Dune</a></li><li class="navelem"><a class="el" href="a01291.html">PowerIteration_Algorithms</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="a01288.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Dune::PowerIteration_Algorithms&lt; BCRSMatrix, BlockVector &gt; Class Template Reference<div class="ingroups"><a class="el" href="a00236.html">Iterative Solvers Template Library (ISTL)</a> &raquo; <a class="el" href="a00237.html">Iterative Solvers</a> &raquo; <a class="el" href="a00238.html">Eigenvalue Solvers</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Iterative eigenvalue algorithms based on power iteration.  
 <a href="a01291.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00050_source.html">dune/istl/eigenvalue/poweriteration.hh</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afe01daec21792b72fda320bf39349e88"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a01239.html#aa2debec6431c850994dc2d735fe1ce13">BlockVector::field_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01291.html#afe01daec21792b72fda320bf39349e88">Real</a></td></tr>
<tr class="memdesc:afe01daec21792b72fda320bf39349e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of underlying field.  <a href="a01291.html#afe01daec21792b72fda320bf39349e88">More...</a><br /></td></tr>
<tr class="separator:afe01daec21792b72fda320bf39349e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9e8521155195fb9257edcf705ad48a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a01291.html#a2e36be189e19690efebe810fb6a1f4b7">OperatorSum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01291.html#a8d9e8521155195fb9257edcf705ad48a">IterationOperator</a></td></tr>
<tr class="memdesc:a8d9e8521155195fb9257edcf705ad48a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of iteration operator (m_ - mu_*I)  <a href="a01291.html#a8d9e8521155195fb9257edcf705ad48a">More...</a><br /></td></tr>
<tr class="separator:a8d9e8521155195fb9257edcf705ad48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7b1f74df27c09299e7c8d65666fb4ffa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01291.html#a7b1f74df27c09299e7c8d65666fb4ffa">PowerIteration_Algorithms</a> (const <a class="el" href="a01155.html">BCRSMatrix</a> &amp;m, const unsigned int nIterationsMax=1000, const unsigned int verbosity_level=0)</td></tr>
<tr class="memdesc:a7b1f74df27c09299e7c8d65666fb4ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from required parameters.  <a href="a01291.html#a7b1f74df27c09299e7c8d65666fb4ffa">More...</a><br /></td></tr>
<tr class="separator:a7b1f74df27c09299e7c8d65666fb4ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087c57a03e57476034430ade0b449577"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01291.html#a087c57a03e57476034430ade0b449577">PowerIteration_Algorithms</a> (const <a class="el" href="a01291.html">PowerIteration_Algorithms</a> &amp;)=delete</td></tr>
<tr class="separator:a087c57a03e57476034430ade0b449577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb75b7c2b80b77aeac6a3753bc67036c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01291.html">PowerIteration_Algorithms</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01291.html#afb75b7c2b80b77aeac6a3753bc67036c">operator=</a> (const <a class="el" href="a01291.html">PowerIteration_Algorithms</a> &amp;)=delete</td></tr>
<tr class="separator:afb75b7c2b80b77aeac6a3753bc67036c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4e95a396612022814c6e72148a687d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01291.html#a7f4e95a396612022814c6e72148a687d">applyPowerIteration</a> (const <a class="el" href="a01291.html#afe01daec21792b72fda320bf39349e88">Real</a> &amp;epsilon, <a class="el" href="a01239.html">BlockVector</a> &amp;x, <a class="el" href="a01291.html#afe01daec21792b72fda320bf39349e88">Real</a> &amp;lambda) const</td></tr>
<tr class="memdesc:a7f4e95a396612022814c6e72148a687d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the power iteration algorithm to compute an approximation lambda of the dominant (i.e. largest magnitude) eigenvalue and the corresponding approximation x of an associated eigenvector.  <a href="a01291.html#a7f4e95a396612022814c6e72148a687d">More...</a><br /></td></tr>
<tr class="separator:a7f4e95a396612022814c6e72148a687d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7200e90c3095f9a5d86e88ba5f49a4"><td class="memTemplParams" colspan="2">template&lt;typename ISTLLinearSolver , bool avoidLinSolverCrime = false&gt; </td></tr>
<tr class="memitem:a3c7200e90c3095f9a5d86e88ba5f49a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01291.html#a3c7200e90c3095f9a5d86e88ba5f49a4">applyInverseIteration</a> (const <a class="el" href="a01291.html#afe01daec21792b72fda320bf39349e88">Real</a> &amp;epsilon, ISTLLinearSolver &amp;solver, <a class="el" href="a01239.html">BlockVector</a> &amp;x, <a class="el" href="a01291.html#afe01daec21792b72fda320bf39349e88">Real</a> &amp;lambda) const</td></tr>
<tr class="memdesc:a3c7200e90c3095f9a5d86e88ba5f49a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the inverse iteration algorithm to compute an approximation lambda of the least dominant (i.e. smallest magnitude) eigenvalue and the corresponding approximation x of an associated eigenvector.  <a href="a01291.html#a3c7200e90c3095f9a5d86e88ba5f49a4">More...</a><br /></td></tr>
<tr class="separator:a3c7200e90c3095f9a5d86e88ba5f49a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eab7bccc53e451c59a1f87827109bfe"><td class="memTemplParams" colspan="2">template&lt;typename ISTLLinearSolver , bool avoidLinSolverCrime = false&gt; </td></tr>
<tr class="memitem:a9eab7bccc53e451c59a1f87827109bfe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01291.html#a9eab7bccc53e451c59a1f87827109bfe">applyInverseIteration</a> (const <a class="el" href="a01291.html#afe01daec21792b72fda320bf39349e88">Real</a> &amp;gamma, const <a class="el" href="a01291.html#afe01daec21792b72fda320bf39349e88">Real</a> &amp;epsilon, ISTLLinearSolver &amp;solver, <a class="el" href="a01239.html">BlockVector</a> &amp;x, <a class="el" href="a01291.html#afe01daec21792b72fda320bf39349e88">Real</a> &amp;lambda) const</td></tr>
<tr class="memdesc:a9eab7bccc53e451c59a1f87827109bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the inverse iteration with shift algorithm to compute an approximation lambda of the eigenvalue closest to a given shift and the corresponding approximation x of an associated eigenvector.  <a href="a01291.html#a9eab7bccc53e451c59a1f87827109bfe">More...</a><br /></td></tr>
<tr class="separator:a9eab7bccc53e451c59a1f87827109bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e613b4aaf1db1ccd053e4649b9162c7"><td class="memTemplParams" colspan="2">template&lt;typename ISTLLinearSolver , bool avoidLinSolverCrime = false&gt; </td></tr>
<tr class="memitem:a9e613b4aaf1db1ccd053e4649b9162c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01291.html#a9e613b4aaf1db1ccd053e4649b9162c7">applyRayleighQuotientIteration</a> (const <a class="el" href="a01291.html#afe01daec21792b72fda320bf39349e88">Real</a> &amp;epsilon, ISTLLinearSolver &amp;solver, <a class="el" href="a01239.html">BlockVector</a> &amp;x, <a class="el" href="a01291.html#afe01daec21792b72fda320bf39349e88">Real</a> &amp;lambda) const</td></tr>
<tr class="memdesc:a9e613b4aaf1db1ccd053e4649b9162c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the Rayleigh quotient iteration algorithm to compute an approximation lambda of an eigenvalue and the corresponding approximation x of an associated eigenvector.  <a href="a01291.html#a9e613b4aaf1db1ccd053e4649b9162c7">More...</a><br /></td></tr>
<tr class="separator:a9e613b4aaf1db1ccd053e4649b9162c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d544fc0fe4fdc58af31874256c433b7"><td class="memTemplParams" colspan="2">template&lt;typename ISTLLinearSolver , bool avoidLinSolverCrime = false&gt; </td></tr>
<tr class="memitem:a3d544fc0fe4fdc58af31874256c433b7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01291.html#a3d544fc0fe4fdc58af31874256c433b7">applyTLIMEIteration</a> (const <a class="el" href="a01291.html#afe01daec21792b72fda320bf39349e88">Real</a> &amp;gamma, const <a class="el" href="a01291.html#afe01daec21792b72fda320bf39349e88">Real</a> &amp;eta, const <a class="el" href="a01291.html#afe01daec21792b72fda320bf39349e88">Real</a> &amp;epsilon, ISTLLinearSolver &amp;solver, const <a class="el" href="a01291.html#afe01daec21792b72fda320bf39349e88">Real</a> &amp;delta, const std::size_t &amp;m, bool &amp;extrnl, <a class="el" href="a01239.html">BlockVector</a> &amp;x, <a class="el" href="a01291.html#afe01daec21792b72fda320bf39349e88">Real</a> &amp;lambda) const</td></tr>
<tr class="memdesc:a3d544fc0fe4fdc58af31874256c433b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the "two-level iterative method for eigenvalue calculations
       (TLIME)" iteration algorithm presented in [Szyld, 1988] to compute an approximation lambda of an eigenvalue and the corresponding approximation x of an associated eigenvector.  <a href="a01291.html#a3d544fc0fe4fdc58af31874256c433b7">More...</a><br /></td></tr>
<tr class="separator:a3d544fc0fe4fdc58af31874256c433b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7a0a9b6f97e325b268ad4e36fe9bed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01291.html#a8d9e8521155195fb9257edcf705ad48a">IterationOperator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01291.html#aeb7a0a9b6f97e325b268ad4e36fe9bed">getIterationOperator</a> ()</td></tr>
<tr class="memdesc:aeb7a0a9b6f97e325b268ad4e36fe9bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the iteration operator (m_ - mu_*I).  <a href="a01291.html#aeb7a0a9b6f97e325b268ad4e36fe9bed">More...</a><br /></td></tr>
<tr class="separator:aeb7a0a9b6f97e325b268ad4e36fe9bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd7c46c72c333a6b8034eab612dff6f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a01155.html">BCRSMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01291.html#aabd7c46c72c333a6b8034eab612dff6f">getIterationMatrix</a> () const</td></tr>
<tr class="memdesc:aabd7c46c72c333a6b8034eab612dff6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the iteration matrix (m_ - mu_*I), provided on demand when needed (e.g. for direct solvers or preconditioning).  <a href="a01291.html#aabd7c46c72c333a6b8034eab612dff6f">More...</a><br /></td></tr>
<tr class="separator:aabd7c46c72c333a6b8034eab612dff6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbad7b52ef9f9a0329732eb17242c1a2"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01291.html#acbad7b52ef9f9a0329732eb17242c1a2">getIterationCount</a> () const</td></tr>
<tr class="memdesc:acbad7b52ef9f9a0329732eb17242c1a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of iterations in last application of an algorithm.  <a href="a01291.html#acbad7b52ef9f9a0329732eb17242c1a2">More...</a><br /></td></tr>
<tr class="separator:acbad7b52ef9f9a0329732eb17242c1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a3648a93b503ecdeb9f00acca3431c923"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a01827.html">Dune::MatrixAdapter</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>, <a class="el" href="a01239.html">BlockVector</a>, <a class="el" href="a01239.html">BlockVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01291.html#a3648a93b503ecdeb9f00acca3431c923">MatrixOperator</a></td></tr>
<tr class="separator:a3648a93b503ecdeb9f00acca3431c923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a5490f9baecb7c8f4123afbe57dfbf"><td class="memItemLeft" align="right" valign="top">typedef Impl::ScalingLinearOperator&lt; <a class="el" href="a01239.html">BlockVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01291.html#a19a5490f9baecb7c8f4123afbe57dfbf">ScalingOperator</a></td></tr>
<tr class="separator:a19a5490f9baecb7c8f4123afbe57dfbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e36be189e19690efebe810fb6a1f4b7"><td class="memItemLeft" align="right" valign="top">typedef Impl::LinearOperatorSum&lt; <a class="el" href="a01291.html#a3648a93b503ecdeb9f00acca3431c923">MatrixOperator</a>, <a class="el" href="a01291.html#a19a5490f9baecb7c8f4123afbe57dfbf">ScalingOperator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01291.html#a2e36be189e19690efebe810fb6a1f4b7">OperatorSum</a></td></tr>
<tr class="separator:a2e36be189e19690efebe810fb6a1f4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa7dc68fd37a966d7c8931e70b4e32af2"><td class="memTemplParams" colspan="2">template&lt;typename ISTLLinearSolver &gt; </td></tr>
<tr class="memitem:aa7dc68fd37a966d7c8931e70b4e32af2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01291.html#aa7dc68fd37a966d7c8931e70b4e32af2">updateShiftMu</a> (const <a class="el" href="a01291.html#afe01daec21792b72fda320bf39349e88">Real</a> &amp;mu, ISTLLinearSolver &amp;solver) const</td></tr>
<tr class="memdesc:aa7dc68fd37a966d7c8931e70b4e32af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update shift mu_, i.e. update iteration operator/matrix (m_ - mu_*I).  <a href="a01291.html#aa7dc68fd37a966d7c8931e70b4e32af2">More...</a><br /></td></tr>
<tr class="separator:aa7dc68fd37a966d7c8931e70b4e32af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a79162dbf51a80f651499bf1d996915e5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a01155.html">BCRSMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01291.html#a79162dbf51a80f651499bf1d996915e5">m_</a></td></tr>
<tr class="separator:a79162dbf51a80f651499bf1d996915e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d765090aba3e5efd96b7f96a0ea6bab"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01291.html#a7d765090aba3e5efd96b7f96a0ea6bab">nIterationsMax_</a></td></tr>
<tr class="separator:a7d765090aba3e5efd96b7f96a0ea6bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade92dd48c73f8478fca9faee11e87d69"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01291.html#ade92dd48c73f8478fca9faee11e87d69">verbosity_level_</a></td></tr>
<tr class="separator:ade92dd48c73f8478fca9faee11e87d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff488e21710d0c41ef09ca533a7c4d58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01291.html#afe01daec21792b72fda320bf39349e88">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01291.html#aff488e21710d0c41ef09ca533a7c4d58">mu_</a></td></tr>
<tr class="separator:aff488e21710d0c41ef09ca533a7c4d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb98f59eaf2926169a99812e201660b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a01291.html#a3648a93b503ecdeb9f00acca3431c923">MatrixOperator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01291.html#accb98f59eaf2926169a99812e201660b">matrixOperator_</a></td></tr>
<tr class="separator:accb98f59eaf2926169a99812e201660b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d424945ab7838e4ba2ed9862756bfb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a01291.html#a19a5490f9baecb7c8f4123afbe57dfbf">ScalingOperator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01291.html#aa5d424945ab7838e4ba2ed9862756bfb">scalingOperator_</a></td></tr>
<tr class="separator:aa5d424945ab7838e4ba2ed9862756bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c274a2a5b944210ff9d9cfa726c2037"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01291.html#a2e36be189e19690efebe810fb6a1f4b7">OperatorSum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01291.html#a4c274a2a5b944210ff9d9cfa726c2037">itOperator_</a></td></tr>
<tr class="separator:a4c274a2a5b944210ff9d9cfa726c2037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047f7fd075e2cb3ee3655af6e29094d0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="a01155.html">BCRSMatrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01291.html#a047f7fd075e2cb3ee3655af6e29094d0">itMatrix_</a></td></tr>
<tr class="separator:a047f7fd075e2cb3ee3655af6e29094d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf309dd1490b37e04268b628be23aef"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01291.html#adbf309dd1490b37e04268b628be23aef">nIterations_</a></td></tr>
<tr class="separator:adbf309dd1490b37e04268b628be23aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede475c3294d54f0e3782d99de68b16b"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01291.html#aede475c3294d54f0e3782d99de68b16b">title_</a></td></tr>
<tr class="separator:aede475c3294d54f0e3782d99de68b16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2377d6ab02c88d1aa35a21b043f5c061"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01291.html#a2377d6ab02c88d1aa35a21b043f5c061">blank_</a></td></tr>
<tr class="separator:a2377d6ab02c88d1aa35a21b043f5c061"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename BCRSMatrix, typename BlockVector&gt;<br />
class Dune::PowerIteration_Algorithms&lt; BCRSMatrix, BlockVector &gt;</h3>

<p>Iterative eigenvalue algorithms based on power iteration. </p>
<p>Given a square matrix whose eigenvalues shall be considered, this class template provides methods for performing the power iteration algorithm, the inverse iteration algorithm, the inverse iteration with shift algorithm, the Rayleigh quotient iteration algorithm and the TLIME iteration algorithm.</p>
<dl class="section note"><dt>Note</dt><dd>Note that all algorithms except the power iteration algorithm require matrix inversion via a linear solver. When using an iterative linear solver, the algorithms become inexact "inner-outer" iterative methods. It is known that the number of inner solver iterations can increase steadily as the outer eigenvalue iteration proceeds. In this case, you should consider using a "tuned preconditioner", see e.g. [Freitag and Spence, 2008].</dd>
<dd>
In the current implementation, preconditioners like Dune::SeqILUn which are based on matrix decomposition act on the initial iteration matrix in each iteration, even for methods like the Rayleigh quotient algorithm in which the iteration matrix (m_ - mu_*I) may change in each iteration. This is due to the fact that those preconditioners currently don't support to be notified about a change of the matrix object.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="a00233.html#_todo000007">Todo:</a></b></dt><dd>The current implementation is limited to DUNE-ISTL <a class="el" href="a01155.html" title="A sparse block matrix with compressed row storage.">BCRSMatrix</a> types with blocklevel 2. An extension to blocklevel &gt;= 2 might be provided in a future version.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="a01155.html" title="A sparse block matrix with compressed row storage.">BCRSMatrix</a></td><td>Type of a DUNE-ISTL <a class="el" href="a01155.html" title="A sparse block matrix with compressed row storage.">BCRSMatrix</a> whose eigenvalues shall be considered; is assumed to have blocklevel 2 with square blocks. </td></tr>
    <tr><td class="paramname"><a class="el" href="a01239.html" title="A vector of blocks with memory management.">BlockVector</a></td><td>Type of the associated vectors; compatible with the rows of a <a class="el" href="a01155.html" title="A sparse block matrix with compressed row storage.">BCRSMatrix</a> object and its columns.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Sebastian Westerheide. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a8d9e8521155195fb9257edcf705ad48a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d9e8521155195fb9257edcf705ad48a">&#9670;&nbsp;</a></span>IterationOperator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BCRSMatrix , typename BlockVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a01291.html#a2e36be189e19690efebe810fb6a1f4b7">OperatorSum</a> <a class="el" href="a01291.html">Dune::PowerIteration_Algorithms</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>, <a class="el" href="a01239.html">BlockVector</a> &gt;::<a class="el" href="a01291.html#a8d9e8521155195fb9257edcf705ad48a">IterationOperator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of iteration operator (m_ - mu_*I) </p>

</div>
</div>
<a id="a3648a93b503ecdeb9f00acca3431c923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3648a93b503ecdeb9f00acca3431c923">&#9670;&nbsp;</a></span>MatrixOperator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BCRSMatrix , typename BlockVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a01827.html">Dune::MatrixAdapter</a>&lt;<a class="el" href="a01155.html">BCRSMatrix</a>,<a class="el" href="a01239.html">BlockVector</a>,<a class="el" href="a01239.html">BlockVector</a>&gt; <a class="el" href="a01291.html">Dune::PowerIteration_Algorithms</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>, <a class="el" href="a01239.html">BlockVector</a> &gt;::<a class="el" href="a01291.html#a3648a93b503ecdeb9f00acca3431c923">MatrixOperator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e36be189e19690efebe810fb6a1f4b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e36be189e19690efebe810fb6a1f4b7">&#9670;&nbsp;</a></span>OperatorSum</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BCRSMatrix , typename BlockVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef Impl::LinearOperatorSum&lt;<a class="el" href="a01291.html#a3648a93b503ecdeb9f00acca3431c923">MatrixOperator</a>,<a class="el" href="a01291.html#a19a5490f9baecb7c8f4123afbe57dfbf">ScalingOperator</a>&gt; <a class="el" href="a01291.html">Dune::PowerIteration_Algorithms</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>, <a class="el" href="a01239.html">BlockVector</a> &gt;::<a class="el" href="a01291.html#a2e36be189e19690efebe810fb6a1f4b7">OperatorSum</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afe01daec21792b72fda320bf39349e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe01daec21792b72fda320bf39349e88">&#9670;&nbsp;</a></span>Real</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BCRSMatrix , typename BlockVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a01239.html#aa2debec6431c850994dc2d735fe1ce13">BlockVector::field_type</a> <a class="el" href="a01291.html">Dune::PowerIteration_Algorithms</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>, <a class="el" href="a01239.html">BlockVector</a> &gt;::<a class="el" href="a01291.html#afe01daec21792b72fda320bf39349e88">Real</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of underlying field. </p>

</div>
</div>
<a id="a19a5490f9baecb7c8f4123afbe57dfbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a5490f9baecb7c8f4123afbe57dfbf">&#9670;&nbsp;</a></span>ScalingOperator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BCRSMatrix , typename BlockVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef Impl::ScalingLinearOperator&lt;<a class="el" href="a01239.html">BlockVector</a>&gt; <a class="el" href="a01291.html">Dune::PowerIteration_Algorithms</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>, <a class="el" href="a01239.html">BlockVector</a> &gt;::<a class="el" href="a01291.html#a19a5490f9baecb7c8f4123afbe57dfbf">ScalingOperator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7b1f74df27c09299e7c8d65666fb4ffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b1f74df27c09299e7c8d65666fb4ffa">&#9670;&nbsp;</a></span>PowerIteration_Algorithms() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BCRSMatrix , typename BlockVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01291.html">Dune::PowerIteration_Algorithms</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>, <a class="el" href="a01239.html">BlockVector</a> &gt;::<a class="el" href="a01291.html">PowerIteration_Algorithms</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01155.html">BCRSMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>nIterationsMax</em> = <code>1000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>verbosity_level</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from required parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The square DUNE-ISTL <a class="el" href="a01155.html" title="A sparse block matrix with compressed row storage.">BCRSMatrix</a> whose eigenvalues shall be considered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nIterationsMax</td><td>The maximum number of iterations allowed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity_level</td><td>Verbosity setting; &gt;= 1: algorithms print a preamble and the final result, &gt;= 2: algorithms print information on each iteration, &gt;= 3: the final result output includes the approximated eigenvector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a087c57a03e57476034430ade0b449577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087c57a03e57476034430ade0b449577">&#9670;&nbsp;</a></span>PowerIteration_Algorithms() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BCRSMatrix , typename BlockVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01291.html">Dune::PowerIteration_Algorithms</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>, <a class="el" href="a01239.html">BlockVector</a> &gt;::<a class="el" href="a01291.html">PowerIteration_Algorithms</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01291.html">PowerIteration_Algorithms</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>, <a class="el" href="a01239.html">BlockVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>disallow copying (default copy constructor does a shallow copy, if copying was required a deep copy would have to be implemented due to member variables which hold a dynamically allocated object) </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3c7200e90c3095f9a5d86e88ba5f49a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c7200e90c3095f9a5d86e88ba5f49a4">&#9670;&nbsp;</a></span>applyInverseIteration() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BCRSMatrix , typename BlockVector &gt; </div>
<div class="memtemplate">
template&lt;typename ISTLLinearSolver , bool avoidLinSolverCrime = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01291.html">Dune::PowerIteration_Algorithms</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>, <a class="el" href="a01239.html">BlockVector</a> &gt;::applyInverseIteration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01291.html#afe01daec21792b72fda320bf39349e88">Real</a> &amp;&#160;</td>
          <td class="paramname"><em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ISTLLinearSolver &amp;&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01239.html">BlockVector</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01291.html#afe01daec21792b72fda320bf39349e88">Real</a> &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform the inverse iteration algorithm to compute an approximation lambda of the least dominant (i.e. smallest magnitude) eigenvalue and the corresponding approximation x of an associated eigenvector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ISTLLinearSolver</td><td>Type of a DUNE-ISTL <a class="el" href="a02679.html" title="Abstract base class for all solvers.">InverseOperator</a> which shall be used as a linear solver. </td></tr>
    <tr><td class="paramname">avoidLinSolverCrime</td><td>The less accurate the linear solver is, the more corrupted gets the implemented computation of lambda and its associated residual. Setting this mode can help increasing their accuracy at the cost of a bit of efficiency which is beneficial e.g. when using a very inexact linear solver. Defaults to false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">epsilon</td><td>The target residual norm. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>The DUNE-ISTL <a class="el" href="a02679.html" title="Abstract base class for all solvers.">InverseOperator</a> which shall be used as a linear solver; is assumed to be constructed using the linear operator returned by <a class="el" href="a01291.html#aeb7a0a9b6f97e325b268ad4e36fe9bed" title="Return the iteration operator (m_ - mu_*I).">getIterationOperator()</a> (resp. matrix returned by <a class="el" href="a01291.html#aabd7c46c72c333a6b8034eab612dff6f" title="Return the iteration matrix (m_ - mu_*I), provided on demand when needed (e.g. for direct solvers or ...">getIterationMatrix()</a>). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lambda</td><td>The approximated least dominant eigenvalue. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>The associated approximated eigenvector; shall be initialized with an estimate for an eigenvector associated with the eigenvalue which shall be approximated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9eab7bccc53e451c59a1f87827109bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eab7bccc53e451c59a1f87827109bfe">&#9670;&nbsp;</a></span>applyInverseIteration() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BCRSMatrix , typename BlockVector &gt; </div>
<div class="memtemplate">
template&lt;typename ISTLLinearSolver , bool avoidLinSolverCrime = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01291.html">Dune::PowerIteration_Algorithms</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>, <a class="el" href="a01239.html">BlockVector</a> &gt;::applyInverseIteration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01291.html#afe01daec21792b72fda320bf39349e88">Real</a> &amp;&#160;</td>
          <td class="paramname"><em>gamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01291.html#afe01daec21792b72fda320bf39349e88">Real</a> &amp;&#160;</td>
          <td class="paramname"><em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ISTLLinearSolver &amp;&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01239.html">BlockVector</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01291.html#afe01daec21792b72fda320bf39349e88">Real</a> &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform the inverse iteration with shift algorithm to compute an approximation lambda of the eigenvalue closest to a given shift and the corresponding approximation x of an associated eigenvector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ISTLLinearSolver</td><td>Type of a DUNE-ISTL <a class="el" href="a02679.html" title="Abstract base class for all solvers.">InverseOperator</a> which shall be used as a linear solver. </td></tr>
    <tr><td class="paramname">avoidLinSolverCrime</td><td>The less accurate the linear solver is, the more corrupted gets the implemented computation of lambda and its associated residual. Setting this mode can help increasing their accuracy at the cost of a bit of efficiency which is beneficial e.g. when using a very inexact linear solver. Defaults to false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gamma</td><td>The shift. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">epsilon</td><td>The target residual norm. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>The DUNE-ISTL <a class="el" href="a02679.html" title="Abstract base class for all solvers.">InverseOperator</a> which shall be used as a linear solver; is assumed to be constructed using the linear operator returned by <a class="el" href="a01291.html#aeb7a0a9b6f97e325b268ad4e36fe9bed" title="Return the iteration operator (m_ - mu_*I).">getIterationOperator()</a> (resp. matrix returned by <a class="el" href="a01291.html#aabd7c46c72c333a6b8034eab612dff6f" title="Return the iteration matrix (m_ - mu_*I), provided on demand when needed (e.g. for direct solvers or ...">getIterationMatrix()</a>). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lambda</td><td>The approximated eigenvalue closest to gamma. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>The associated approximated eigenvector; shall be initialized with an estimate for an eigenvector associated with the eigenvalue which shall be approximated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f4e95a396612022814c6e72148a687d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f4e95a396612022814c6e72148a687d">&#9670;&nbsp;</a></span>applyPowerIteration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BCRSMatrix , typename BlockVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01291.html">Dune::PowerIteration_Algorithms</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>, <a class="el" href="a01239.html">BlockVector</a> &gt;::applyPowerIteration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01291.html#afe01daec21792b72fda320bf39349e88">Real</a> &amp;&#160;</td>
          <td class="paramname"><em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01239.html">BlockVector</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01291.html#afe01daec21792b72fda320bf39349e88">Real</a> &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform the power iteration algorithm to compute an approximation lambda of the dominant (i.e. largest magnitude) eigenvalue and the corresponding approximation x of an associated eigenvector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">epsilon</td><td>The target residual norm. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lambda</td><td>The approximated dominant eigenvalue. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>The associated approximated eigenvector; shall be initialized with an estimate for an eigenvector associated with the eigenvalue which shall be approximated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e613b4aaf1db1ccd053e4649b9162c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e613b4aaf1db1ccd053e4649b9162c7">&#9670;&nbsp;</a></span>applyRayleighQuotientIteration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BCRSMatrix , typename BlockVector &gt; </div>
<div class="memtemplate">
template&lt;typename ISTLLinearSolver , bool avoidLinSolverCrime = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01291.html">Dune::PowerIteration_Algorithms</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>, <a class="el" href="a01239.html">BlockVector</a> &gt;::applyRayleighQuotientIteration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01291.html#afe01daec21792b72fda320bf39349e88">Real</a> &amp;&#160;</td>
          <td class="paramname"><em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ISTLLinearSolver &amp;&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01239.html">BlockVector</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01291.html#afe01daec21792b72fda320bf39349e88">Real</a> &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform the Rayleigh quotient iteration algorithm to compute an approximation lambda of an eigenvalue and the corresponding approximation x of an associated eigenvector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ISTLLinearSolver</td><td>Type of a DUNE-ISTL <a class="el" href="a02679.html" title="Abstract base class for all solvers.">InverseOperator</a> which shall be used as a linear solver. </td></tr>
    <tr><td class="paramname">avoidLinSolverCrime</td><td>The less accurate the linear solver is, the more corrupted gets the implemented computation of lambda and its associated residual. Setting this mode can help increasing their accuracy at the cost of a bit of efficiency which is beneficial e.g. when using a very inexact linear solver. Defaults to false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">epsilon</td><td>The target residual norm. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>The DUNE-ISTL <a class="el" href="a02679.html" title="Abstract base class for all solvers.">InverseOperator</a> which shall be used as a linear solver; is assumed to be constructed using the linear operator returned by <a class="el" href="a01291.html#aeb7a0a9b6f97e325b268ad4e36fe9bed" title="Return the iteration operator (m_ - mu_*I).">getIterationOperator()</a> (resp. matrix returned by <a class="el" href="a01291.html#aabd7c46c72c333a6b8034eab612dff6f" title="Return the iteration matrix (m_ - mu_*I), provided on demand when needed (e.g. for direct solvers or ...">getIterationMatrix()</a>). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lambda</td><td>The approximated eigenvalue; shall be initialized with an estimate for the eigenvalue which shall be approximated. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>The associated approximated eigenvector; shall be initialized with an estimate for an eigenvector associated with the eigenvalue which shall be approximated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d544fc0fe4fdc58af31874256c433b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d544fc0fe4fdc58af31874256c433b7">&#9670;&nbsp;</a></span>applyTLIMEIteration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BCRSMatrix , typename BlockVector &gt; </div>
<div class="memtemplate">
template&lt;typename ISTLLinearSolver , bool avoidLinSolverCrime = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01291.html">Dune::PowerIteration_Algorithms</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>, <a class="el" href="a01239.html">BlockVector</a> &gt;::applyTLIMEIteration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01291.html#afe01daec21792b72fda320bf39349e88">Real</a> &amp;&#160;</td>
          <td class="paramname"><em>gamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01291.html#afe01daec21792b72fda320bf39349e88">Real</a> &amp;&#160;</td>
          <td class="paramname"><em>eta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01291.html#afe01daec21792b72fda320bf39349e88">Real</a> &amp;&#160;</td>
          <td class="paramname"><em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ISTLLinearSolver &amp;&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01291.html#afe01daec21792b72fda320bf39349e88">Real</a> &amp;&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>extrnl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01239.html">BlockVector</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01291.html#afe01daec21792b72fda320bf39349e88">Real</a> &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform the "two-level iterative method for eigenvalue calculations
       (TLIME)" iteration algorithm presented in [Szyld, 1988] to compute an approximation lambda of an eigenvalue and the corresponding approximation x of an associated eigenvector. </p>
<p>The algorithm combines the inverse iteration with shift and the Rayleigh quotient iteration in order to compute an eigenvalue in a given interval J = (gamma - eta, gamma + eta). It guarantees that if an eigenvalue exists in J, the method will converge to an eigenvalue in J, while exploiting the cubic convergence of the Rayleigh quotient iteration, but without its drawback that - depending on the initial vector - it can converge to an arbitrary eigenvalue of the matrix. When J is free of eigenvalues, the method will determine this fact and converge linearly to the eigenvalue closest to J.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ISTLLinearSolver</td><td>Type of a DUNE-ISTL <a class="el" href="a02679.html" title="Abstract base class for all solvers.">InverseOperator</a> which shall be used as a linear solver. </td></tr>
    <tr><td class="paramname">avoidLinSolverCrime</td><td>The less accurate the linear solver is, the more corrupted gets the implemented computation of lambda and its associated residual. Setting this mode can help increasing their accuracy at the cost of a bit of efficiency which is beneficial e.g. when using a very inexact linear solver. Defaults to false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gamma</td><td>An estimate for the eigenvalue which shall be approximated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eta</td><td>Radius around gamma in which the eigenvalue is expected. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">epsilon</td><td>The target norm of the residual with respect to the Rayleigh quotient. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>The DUNE-ISTL <a class="el" href="a02679.html" title="Abstract base class for all solvers.">InverseOperator</a> which shall be used as a linear solver; is assumed to be constructed using the linear operator returned by <a class="el" href="a01291.html#aeb7a0a9b6f97e325b268ad4e36fe9bed" title="Return the iteration operator (m_ - mu_*I).">getIterationOperator()</a> (resp. matrix returned by <a class="el" href="a01291.html#aabd7c46c72c333a6b8034eab612dff6f" title="Return the iteration matrix (m_ - mu_*I), provided on demand when needed (e.g. for direct solvers or ...">getIterationMatrix()</a>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delta</td><td>The target relative change of the Rayleigh quotient, indicating that inverse iteration has become stationary and switching to Rayleigh quotient iteration is appropriate; is only considered if J is free of eigenvalues. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The minimum number of inverse iterations before switching to Rayleigh quotient iteration; is only considered if J is free of eigenvalues. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extrnl</td><td>If true, the interval J is free of eigenvalues; the approximated eigenvalue-eigenvector pair (lambda,x_s) then corresponds to the eigenvalue closest to J. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lambda</td><td>The approximated eigenvalue. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>The associated approximated eigenvector; shall be initialized with an estimate for an eigenvector associated with the eigenvalue which shall be approximated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acbad7b52ef9f9a0329732eb17242c1a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbad7b52ef9f9a0329732eb17242c1a2">&#9670;&nbsp;</a></span>getIterationCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BCRSMatrix , typename BlockVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="a01291.html">Dune::PowerIteration_Algorithms</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>, <a class="el" href="a01239.html">BlockVector</a> &gt;::getIterationCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of iterations in last application of an algorithm. </p>

</div>
</div>
<a id="aabd7c46c72c333a6b8034eab612dff6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd7c46c72c333a6b8034eab612dff6f">&#9670;&nbsp;</a></span>getIterationMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BCRSMatrix , typename BlockVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a01155.html">BCRSMatrix</a>&amp; <a class="el" href="a01291.html">Dune::PowerIteration_Algorithms</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>, <a class="el" href="a01239.html">BlockVector</a> &gt;::getIterationMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the iteration matrix (m_ - mu_*I), provided on demand when needed (e.g. for direct solvers or preconditioning). </p>
<p>The matrix returned by this method shall be used to create the linear solver object if it requires that the matrix is provided explicitly. For linear solvers which operate completely matrix free use <a class="el" href="a01291.html#aeb7a0a9b6f97e325b268ad4e36fe9bed" title="Return the iteration operator (m_ - mu_*I).">getIterationOperator()</a> instead.</p>
<dl class="section note"><dt>Note</dt><dd>Calling this method creates a new DUNE-ISTL <a class="el" href="a01155.html" title="A sparse block matrix with compressed row storage.">BCRSMatrix</a> object which requires as much memory as the matrix whose eigenvalues shall be considered. </dd></dl>

</div>
</div>
<a id="aeb7a0a9b6f97e325b268ad4e36fe9bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb7a0a9b6f97e325b268ad4e36fe9bed">&#9670;&nbsp;</a></span>getIterationOperator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BCRSMatrix , typename BlockVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01291.html#a8d9e8521155195fb9257edcf705ad48a">IterationOperator</a>&amp; <a class="el" href="a01291.html">Dune::PowerIteration_Algorithms</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>, <a class="el" href="a01239.html">BlockVector</a> &gt;::getIterationOperator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the iteration operator (m_ - mu_*I). </p>
<p>The linear operator returned by this method shall be used to create the linear solver object. For linear solvers or preconditioners which require that the matrix is provided explicitly use <a class="el" href="a01291.html#aabd7c46c72c333a6b8034eab612dff6f" title="Return the iteration matrix (m_ - mu_*I), provided on demand when needed (e.g. for direct solvers or ...">getIterationMatrix()</a> instead/additionally. </p>

</div>
</div>
<a id="afb75b7c2b80b77aeac6a3753bc67036c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb75b7c2b80b77aeac6a3753bc67036c">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BCRSMatrix , typename BlockVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01291.html">PowerIteration_Algorithms</a>&amp; <a class="el" href="a01291.html">Dune::PowerIteration_Algorithms</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>, <a class="el" href="a01239.html">BlockVector</a> &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01291.html">PowerIteration_Algorithms</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>, <a class="el" href="a01239.html">BlockVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>disallow copying (default assignment operator does a shallow copy, if copying was required a deep copy would have to be implemented due to member variables which hold a dynamically allocated object) </p>

</div>
</div>
<a id="aa7dc68fd37a966d7c8931e70b4e32af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7dc68fd37a966d7c8931e70b4e32af2">&#9670;&nbsp;</a></span>updateShiftMu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BCRSMatrix , typename BlockVector &gt; </div>
<div class="memtemplate">
template&lt;typename ISTLLinearSolver &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01291.html">Dune::PowerIteration_Algorithms</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>, <a class="el" href="a01239.html">BlockVector</a> &gt;::updateShiftMu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01291.html#afe01daec21792b72fda320bf39349e88">Real</a> &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ISTLLinearSolver &amp;&#160;</td>
          <td class="paramname"><em>solver</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update shift mu_, i.e. update iteration operator/matrix (m_ - mu_*I). </p>
<dl class="section note"><dt>Note</dt><dd>Does nothing if new shift equals the old one.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ISTLLinearSolver</td><td>Type of a DUNE-ISTL <a class="el" href="a02679.html" title="Abstract base class for all solvers.">InverseOperator</a> which is used as a linear solver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mu</td><td>The new shift. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">solver</td><td>The DUNE-ISTL <a class="el" href="a02679.html" title="Abstract base class for all solvers.">InverseOperator</a> which is used as a linear solver. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a2377d6ab02c88d1aa35a21b043f5c061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2377d6ab02c88d1aa35a21b043f5c061">&#9670;&nbsp;</a></span>blank_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BCRSMatrix , typename BlockVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string <a class="el" href="a01291.html">Dune::PowerIteration_Algorithms</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>, <a class="el" href="a01239.html">BlockVector</a> &gt;::blank_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a047f7fd075e2cb3ee3655af6e29094d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047f7fd075e2cb3ee3655af6e29094d0">&#9670;&nbsp;</a></span>itMatrix_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BCRSMatrix , typename BlockVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="a01155.html">BCRSMatrix</a>&gt; <a class="el" href="a01291.html">Dune::PowerIteration_Algorithms</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>, <a class="el" href="a01239.html">BlockVector</a> &gt;::itMatrix_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4c274a2a5b944210ff9d9cfa726c2037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c274a2a5b944210ff9d9cfa726c2037">&#9670;&nbsp;</a></span>itOperator_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BCRSMatrix , typename BlockVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01291.html#a2e36be189e19690efebe810fb6a1f4b7">OperatorSum</a> <a class="el" href="a01291.html">Dune::PowerIteration_Algorithms</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>, <a class="el" href="a01239.html">BlockVector</a> &gt;::itOperator_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a79162dbf51a80f651499bf1d996915e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79162dbf51a80f651499bf1d996915e5">&#9670;&nbsp;</a></span>m_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BCRSMatrix , typename BlockVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a01155.html">BCRSMatrix</a>&amp; <a class="el" href="a01291.html">Dune::PowerIteration_Algorithms</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>, <a class="el" href="a01239.html">BlockVector</a> &gt;::m_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="accb98f59eaf2926169a99812e201660b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accb98f59eaf2926169a99812e201660b">&#9670;&nbsp;</a></span>matrixOperator_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BCRSMatrix , typename BlockVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a01291.html#a3648a93b503ecdeb9f00acca3431c923">MatrixOperator</a> <a class="el" href="a01291.html">Dune::PowerIteration_Algorithms</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>, <a class="el" href="a01239.html">BlockVector</a> &gt;::matrixOperator_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aff488e21710d0c41ef09ca533a7c4d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff488e21710d0c41ef09ca533a7c4d58">&#9670;&nbsp;</a></span>mu_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BCRSMatrix , typename BlockVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01291.html#afe01daec21792b72fda320bf39349e88">Real</a> <a class="el" href="a01291.html">Dune::PowerIteration_Algorithms</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>, <a class="el" href="a01239.html">BlockVector</a> &gt;::mu_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adbf309dd1490b37e04268b628be23aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf309dd1490b37e04268b628be23aef">&#9670;&nbsp;</a></span>nIterations_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BCRSMatrix , typename BlockVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="a01291.html">Dune::PowerIteration_Algorithms</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>, <a class="el" href="a01239.html">BlockVector</a> &gt;::nIterations_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d765090aba3e5efd96b7f96a0ea6bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d765090aba3e5efd96b7f96a0ea6bab">&#9670;&nbsp;</a></span>nIterationsMax_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BCRSMatrix , typename BlockVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="a01291.html">Dune::PowerIteration_Algorithms</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>, <a class="el" href="a01239.html">BlockVector</a> &gt;::nIterationsMax_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5d424945ab7838e4ba2ed9862756bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d424945ab7838e4ba2ed9862756bfb">&#9670;&nbsp;</a></span>scalingOperator_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BCRSMatrix , typename BlockVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a01291.html#a19a5490f9baecb7c8f4123afbe57dfbf">ScalingOperator</a> <a class="el" href="a01291.html">Dune::PowerIteration_Algorithms</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>, <a class="el" href="a01239.html">BlockVector</a> &gt;::scalingOperator_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aede475c3294d54f0e3782d99de68b16b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede475c3294d54f0e3782d99de68b16b">&#9670;&nbsp;</a></span>title_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BCRSMatrix , typename BlockVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string <a class="el" href="a01291.html">Dune::PowerIteration_Algorithms</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>, <a class="el" href="a01239.html">BlockVector</a> &gt;::title_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ade92dd48c73f8478fca9faee11e87d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade92dd48c73f8478fca9faee11e87d69">&#9670;&nbsp;</a></span>verbosity_level_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BCRSMatrix , typename BlockVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="a01291.html">Dune::PowerIteration_Algorithms</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>, <a class="el" href="a01239.html">BlockVector</a> &gt;::verbosity_level_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="a00050_source.html">poweriteration.hh</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
