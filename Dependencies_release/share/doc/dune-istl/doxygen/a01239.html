<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>dune-istl: Dune::BlockVector&lt; B, A &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">dune-istl
   &#160;<span id="projectnumber">2.8.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00252.html">Dune</a></li><li class="navelem"><a class="el" href="a01239.html">BlockVector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="a01236.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Dune::BlockVector&lt; B, A &gt; Class Template Reference<div class="ingroups"><a class="el" href="a00236.html">Iterative Solvers Template Library (ISTL)</a> &raquo; <a class="el" href="a00240.html">Sparse Matrix and Vector classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A vector of blocks with memory management.  
 <a href="a01239.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00032_source.html">dune/istl/bvector.hh</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Dune::BlockVector&lt; B, A &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="a01238.png" border="0" usemap="#a_dune_1_1_block_vector_3_01_b_00_01_a_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="a_dune_1_1_block_vector_3_01_b_00_01_a_01_4_inherit__map" id="a_dune_1_1_block_vector_3_01_b_00_01_a_01_4_inherit__map">
<area shape="rect" title="A vector of blocks with memory management." alt="" coords="1133,14,1272,55"/>
<area shape="rect" href="a01239.html" title=" " alt="" coords="1373,14,1512,55"/>
<area shape="rect" title=" " alt="" coords="884,7,1084,63"/>
<area shape="rect" title=" " alt="" coords="316,7,516,63"/>
<area shape="rect" title=" " alt="" coords="565,43,727,85"/>
<area shape="rect" title=" " alt="" coords="5,14,159,55"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa2debec6431c850994dc2d735fe1ce13"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01239.html#aa2debec6431c850994dc2d735fe1ce13">field_type</a> = typename Imp::BlockTraits&lt; B &gt;::<a class="el" href="a01239.html#aa2debec6431c850994dc2d735fe1ce13">field_type</a></td></tr>
<tr class="memdesc:aa2debec6431c850994dc2d735fe1ce13"><td class="mdescLeft">&#160;</td><td class="mdescRight">export the type representing the field  <a href="a01239.html#aa2debec6431c850994dc2d735fe1ce13">More...</a><br /></td></tr>
<tr class="separator:aa2debec6431c850994dc2d735fe1ce13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c370b75f9cf5d60cc9497537b86066"><td class="memItemLeft" align="right" valign="top">typedef B&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01239.html#ae6c370b75f9cf5d60cc9497537b86066">block_type</a></td></tr>
<tr class="memdesc:ae6c370b75f9cf5d60cc9497537b86066"><td class="mdescLeft">&#160;</td><td class="mdescRight">export the type representing the components  <a href="a01239.html#ae6c370b75f9cf5d60cc9497537b86066">More...</a><br /></td></tr>
<tr class="separator:ae6c370b75f9cf5d60cc9497537b86066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7234d1e543e99d0fcb7e2cbe2a91f9a9"><td class="memItemLeft" align="right" valign="top">typedef A&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01239.html#a7234d1e543e99d0fcb7e2cbe2a91f9a9">allocator_type</a></td></tr>
<tr class="memdesc:a7234d1e543e99d0fcb7e2cbe2a91f9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">export the allocator type  <a href="a01239.html#a7234d1e543e99d0fcb7e2cbe2a91f9a9">More...</a><br /></td></tr>
<tr class="separator:a7234d1e543e99d0fcb7e2cbe2a91f9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1aa0e3aabaa0ccd4aad8e49d81f349"><td class="memItemLeft" align="right" valign="top">typedef A::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01239.html#aad1aa0e3aabaa0ccd4aad8e49d81f349">size_type</a></td></tr>
<tr class="memdesc:aad1aa0e3aabaa0ccd4aad8e49d81f349"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type for the index access.  <a href="a01239.html#aad1aa0e3aabaa0ccd4aad8e49d81f349">More...</a><br /></td></tr>
<tr class="separator:aad1aa0e3aabaa0ccd4aad8e49d81f349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58343eb979ecdb0975518a40425d7741"><td class="memItemLeft" align="right" valign="top">typedef Imp::block_vector_unmanaged&lt; B, A &gt;::<a class="el" href="a01239.html#a58343eb979ecdb0975518a40425d7741">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01239.html#a58343eb979ecdb0975518a40425d7741">Iterator</a></td></tr>
<tr class="memdesc:a58343eb979ecdb0975518a40425d7741"><td class="mdescLeft">&#160;</td><td class="mdescRight">make iterators available as types  <a href="a01239.html#a58343eb979ecdb0975518a40425d7741">More...</a><br /></td></tr>
<tr class="separator:a58343eb979ecdb0975518a40425d7741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f7c1f4d678d67204daff9fc77b7fcd"><td class="memItemLeft" align="right" valign="top">typedef Imp::block_vector_unmanaged&lt; B, A &gt;::<a class="el" href="a01239.html#af8f7c1f4d678d67204daff9fc77b7fcd">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01239.html#af8f7c1f4d678d67204daff9fc77b7fcd">ConstIterator</a></td></tr>
<tr class="memdesc:af8f7c1f4d678d67204daff9fc77b7fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">make iterators available as types  <a href="a01239.html#af8f7c1f4d678d67204daff9fc77b7fcd">More...</a><br /></td></tr>
<tr class="separator:af8f7c1f4d678d67204daff9fc77b7fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a02fc2457c736ed2c26e22b6d2b67207d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01239.html#a02fc2457c736ed2c26e22b6d2b67207d">BlockVector</a> ()</td></tr>
<tr class="memdesc:a02fc2457c736ed2c26e22b6d2b67207d"><td class="mdescLeft">&#160;</td><td class="mdescRight">makes empty vector  <a href="a01239.html#a02fc2457c736ed2c26e22b6d2b67207d">More...</a><br /></td></tr>
<tr class="separator:a02fc2457c736ed2c26e22b6d2b67207d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7e9b921dca0b2c4bdf33f85ebf341a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01239.html#a4c7e9b921dca0b2c4bdf33f85ebf341a">BlockVector</a> (<a class="el" href="a01239.html#aad1aa0e3aabaa0ccd4aad8e49d81f349">size_type</a> _n)</td></tr>
<tr class="memdesc:a4c7e9b921dca0b2c4bdf33f85ebf341a"><td class="mdescLeft">&#160;</td><td class="mdescRight">make vector with _n components  <a href="a01239.html#a4c7e9b921dca0b2c4bdf33f85ebf341a">More...</a><br /></td></tr>
<tr class="separator:a4c7e9b921dca0b2c4bdf33f85ebf341a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4b3e1e543e116f66f8993a6f8b1b96"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01239.html#aae4b3e1e543e116f66f8993a6f8b1b96">BlockVector</a> (std::initializer_list&lt; B &gt; const &amp;l)</td></tr>
<tr class="memdesc:aae4b3e1e543e116f66f8993a6f8b1b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a std::initializer_list.  <a href="a01239.html#aae4b3e1e543e116f66f8993a6f8b1b96">More...</a><br /></td></tr>
<tr class="separator:aae4b3e1e543e116f66f8993a6f8b1b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae645c8daaa1feada2be0a5bbf4b9c9aa"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:ae645c8daaa1feada2be0a5bbf4b9c9aa"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01239.html#ae645c8daaa1feada2be0a5bbf4b9c9aa">BlockVector</a> (<a class="el" href="a01239.html#aad1aa0e3aabaa0ccd4aad8e49d81f349">size_type</a> _n, S _capacity)</td></tr>
<tr class="memdesc:ae645c8daaa1feada2be0a5bbf4b9c9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make vector with _n components but preallocating capacity components.  <a href="a01239.html#ae645c8daaa1feada2be0a5bbf4b9c9aa">More...</a><br /></td></tr>
<tr class="separator:ae645c8daaa1feada2be0a5bbf4b9c9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13bed42cd26580d6c81a1406589ce1da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01239.html#a13bed42cd26580d6c81a1406589ce1da">reserve</a> (<a class="el" href="a01239.html#aad1aa0e3aabaa0ccd4aad8e49d81f349">size_type</a> <a class="el" href="a01239.html#ac38c155e30098a5887c1ad0f34840b3b">capacity</a>)</td></tr>
<tr class="memdesc:a13bed42cd26580d6c81a1406589ce1da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve space.  <a href="a01239.html#a13bed42cd26580d6c81a1406589ce1da">More...</a><br /></td></tr>
<tr class="separator:a13bed42cd26580d6c81a1406589ce1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac38c155e30098a5887c1ad0f34840b3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01239.html#aad1aa0e3aabaa0ccd4aad8e49d81f349">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01239.html#ac38c155e30098a5887c1ad0f34840b3b">capacity</a> () const</td></tr>
<tr class="memdesc:ac38c155e30098a5887c1ad0f34840b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the capacity of the vector.  <a href="a01239.html#ac38c155e30098a5887c1ad0f34840b3b">More...</a><br /></td></tr>
<tr class="separator:ac38c155e30098a5887c1ad0f34840b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c827318ce2fc4dbc1f3d61d04e62f16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01239.html#a4c827318ce2fc4dbc1f3d61d04e62f16">resize</a> (<a class="el" href="a01239.html#aad1aa0e3aabaa0ccd4aad8e49d81f349">size_type</a> size)</td></tr>
<tr class="memdesc:a4c827318ce2fc4dbc1f3d61d04e62f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the vector.  <a href="a01239.html#a4c827318ce2fc4dbc1f3d61d04e62f16">More...</a><br /></td></tr>
<tr class="separator:a4c827318ce2fc4dbc1f3d61d04e62f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e17f28660c4e56100fd82132bab56bf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01239.html#a6e17f28660c4e56100fd82132bab56bf">BlockVector</a> (const <a class="el" href="a01239.html">BlockVector</a> &amp;a) noexcept(noexcept(std::declval&lt; <a class="el" href="a01239.html">BlockVector</a> &gt;().storage_=a.storage_))</td></tr>
<tr class="memdesc:a6e17f28660c4e56100fd82132bab56bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor  <a href="a01239.html#a6e17f28660c4e56100fd82132bab56bf">More...</a><br /></td></tr>
<tr class="separator:a6e17f28660c4e56100fd82132bab56bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a25328357a4158bbd65ea3e1c06fc5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01239.html#a45a25328357a4158bbd65ea3e1c06fc5">BlockVector</a> (<a class="el" href="a01239.html">BlockVector</a> &amp;&amp;a) noexcept(noexcept(std::declval&lt; <a class="el" href="a01239.html">BlockVector</a> &gt;().<a class="el" href="a01239.html#af02395a3170f5a53bfc88ba6f7b33e97">swap</a>(a)))</td></tr>
<tr class="memdesc:a45a25328357a4158bbd65ea3e1c06fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">move constructor  <a href="a01239.html#a45a25328357a4158bbd65ea3e1c06fc5">More...</a><br /></td></tr>
<tr class="separator:a45a25328357a4158bbd65ea3e1c06fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22cb35272533c055b3e45fec5e36d490"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01239.html">BlockVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01239.html#a22cb35272533c055b3e45fec5e36d490">operator=</a> (const <a class="el" href="a01239.html">BlockVector</a> &amp;a) noexcept(noexcept(std::declval&lt; <a class="el" href="a01239.html">BlockVector</a> &gt;().storage_=a.storage_))</td></tr>
<tr class="memdesc:a22cb35272533c055b3e45fec5e36d490"><td class="mdescLeft">&#160;</td><td class="mdescRight">assignment  <a href="a01239.html#a22cb35272533c055b3e45fec5e36d490">More...</a><br /></td></tr>
<tr class="separator:a22cb35272533c055b3e45fec5e36d490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d34e9b8701afbab8599413cec7022c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01239.html">BlockVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01239.html#a4d34e9b8701afbab8599413cec7022c8">operator=</a> (<a class="el" href="a01239.html">BlockVector</a> &amp;&amp;a) noexcept(noexcept(std::declval&lt; <a class="el" href="a01239.html">BlockVector</a> &gt;().<a class="el" href="a01239.html#af02395a3170f5a53bfc88ba6f7b33e97">swap</a>(a)))</td></tr>
<tr class="memdesc:a4d34e9b8701afbab8599413cec7022c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">move assignment  <a href="a01239.html#a4d34e9b8701afbab8599413cec7022c8">More...</a><br /></td></tr>
<tr class="separator:a4d34e9b8701afbab8599413cec7022c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02395a3170f5a53bfc88ba6f7b33e97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01239.html#af02395a3170f5a53bfc88ba6f7b33e97">swap</a> (<a class="el" href="a01239.html">BlockVector</a> &amp;other) noexcept(noexcept(std::declval&lt; <a class="el" href="a01239.html">BlockVector</a> &amp; &gt;().storage_.swap(other.storage_)))</td></tr>
<tr class="memdesc:af02395a3170f5a53bfc88ba6f7b33e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap operation  <a href="a01239.html#af02395a3170f5a53bfc88ba6f7b33e97">More...</a><br /></td></tr>
<tr class="separator:af02395a3170f5a53bfc88ba6f7b33e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadfc3a9d047f164205319590d7ea6712"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01239.html">BlockVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01239.html#aadfc3a9d047f164205319590d7ea6712">operator=</a> (const <a class="el" href="a01239.html#aa2debec6431c850994dc2d735fe1ce13">field_type</a> &amp;k)</td></tr>
<tr class="memdesc:aadfc3a9d047f164205319590d7ea6712"><td class="mdescLeft">&#160;</td><td class="mdescRight">assign from scalar  <a href="a01239.html#aadfc3a9d047f164205319590d7ea6712">More...</a><br /></td></tr>
<tr class="separator:aadfc3a9d047f164205319590d7ea6712"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a6a766d1205e0d6a81397e7b39db37e81"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01239.html#a6a766d1205e0d6a81397e7b39db37e81">blocklevel</a> = <a class="el" href="a00252.html#a477c671e3966936ca929dee4be2dcf95">blockLevel</a>&lt;B&gt;()+1</td></tr>
<tr class="memdesc:a6a766d1205e0d6a81397e7b39db37e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">increment block level counter  <a href="a01239.html#a6a766d1205e0d6a81397e7b39db37e81">More...</a><br /></td></tr>
<tr class="separator:a6a766d1205e0d6a81397e7b39db37e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class B, class A = std::allocator&lt;B&gt;&gt;<br />
class Dune::BlockVector&lt; B, A &gt;</h3>

<p>A vector of blocks with memory management. </p>
<p><a class="el" href="a01239.html" title="A vector of blocks with memory management.">BlockVector</a> adds memory management with ordinary copy semantics to the block_vector_unmanaged template. </p><pre class="fragment">Error checking: no error checking is provided normally.
Setting the compile time switch DUNE_ISTL_WITH_CHECKING
enables error checking.
</pre> </div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a7234d1e543e99d0fcb7e2cbe2a91f9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7234d1e543e99d0fcb7e2cbe2a91f9a9">&#9670;&nbsp;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef A <a class="el" href="a01239.html">Dune::BlockVector</a>&lt; B, A &gt;::<a class="el" href="a01239.html#a7234d1e543e99d0fcb7e2cbe2a91f9a9">allocator_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>export the allocator type </p>

</div>
</div>
<a id="ae6c370b75f9cf5d60cc9497537b86066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6c370b75f9cf5d60cc9497537b86066">&#9670;&nbsp;</a></span>block_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef B <a class="el" href="a01239.html">Dune::BlockVector</a>&lt; B, A &gt;::<a class="el" href="a01239.html#ae6c370b75f9cf5d60cc9497537b86066">block_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>export the type representing the components </p>

</div>
</div>
<a id="af8f7c1f4d678d67204daff9fc77b7fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8f7c1f4d678d67204daff9fc77b7fcd">&#9670;&nbsp;</a></span>ConstIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Imp::block_vector_unmanaged&lt;B,A&gt;::<a class="el" href="a01239.html#af8f7c1f4d678d67204daff9fc77b7fcd">ConstIterator</a> <a class="el" href="a01239.html">Dune::BlockVector</a>&lt; B, A &gt;::<a class="el" href="a01239.html#af8f7c1f4d678d67204daff9fc77b7fcd">ConstIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>make iterators available as types </p>

</div>
</div>
<a id="aa2debec6431c850994dc2d735fe1ce13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2debec6431c850994dc2d735fe1ce13">&#9670;&nbsp;</a></span>field_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a01239.html">Dune::BlockVector</a>&lt; B, A &gt;::<a class="el" href="a01239.html#aa2debec6431c850994dc2d735fe1ce13">field_type</a> =  typename Imp::BlockTraits&lt;B&gt;::<a class="el" href="a01239.html#aa2debec6431c850994dc2d735fe1ce13">field_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>export the type representing the field </p>

</div>
</div>
<a id="a58343eb979ecdb0975518a40425d7741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58343eb979ecdb0975518a40425d7741">&#9670;&nbsp;</a></span>Iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Imp::block_vector_unmanaged&lt;B,A&gt;::<a class="el" href="a01239.html#a58343eb979ecdb0975518a40425d7741">Iterator</a> <a class="el" href="a01239.html">Dune::BlockVector</a>&lt; B, A &gt;::<a class="el" href="a01239.html#a58343eb979ecdb0975518a40425d7741">Iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>make iterators available as types </p>

</div>
</div>
<a id="aad1aa0e3aabaa0ccd4aad8e49d81f349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad1aa0e3aabaa0ccd4aad8e49d81f349">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef A::size_type <a class="el" href="a01239.html">Dune::BlockVector</a>&lt; B, A &gt;::<a class="el" href="a01239.html#aad1aa0e3aabaa0ccd4aad8e49d81f349">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type for the index access. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a02fc2457c736ed2c26e22b6d2b67207d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02fc2457c736ed2c26e22b6d2b67207d">&#9670;&nbsp;</a></span>BlockVector() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01239.html">Dune::BlockVector</a>&lt; B, A &gt;::<a class="el" href="a01239.html">BlockVector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>makes empty vector </p>

</div>
</div>
<a id="a4c7e9b921dca0b2c4bdf33f85ebf341a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c7e9b921dca0b2c4bdf33f85ebf341a">&#9670;&nbsp;</a></span>BlockVector() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01239.html">Dune::BlockVector</a>&lt; B, A &gt;::<a class="el" href="a01239.html">BlockVector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01239.html#aad1aa0e3aabaa0ccd4aad8e49d81f349">size_type</a>&#160;</td>
          <td class="paramname"><em>_n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>make vector with _n components </p>

</div>
</div>
<a id="aae4b3e1e543e116f66f8993a6f8b1b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae4b3e1e543e116f66f8993a6f8b1b96">&#9670;&nbsp;</a></span>BlockVector() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01239.html">Dune::BlockVector</a>&lt; B, A &gt;::<a class="el" href="a01239.html">BlockVector</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; B &gt; const &amp;&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a std::initializer_list. </p>

</div>
</div>
<a id="ae645c8daaa1feada2be0a5bbf4b9c9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae645c8daaa1feada2be0a5bbf4b9c9aa">&#9670;&nbsp;</a></span>BlockVector() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01239.html">Dune::BlockVector</a>&lt; B, A &gt;::<a class="el" href="a01239.html">BlockVector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01239.html#aad1aa0e3aabaa0ccd4aad8e49d81f349">size_type</a>&#160;</td>
          <td class="paramname"><em>_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>_capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make vector with _n components but preallocating capacity components. </p>
<p>If _n &gt; capacity then space for _n entries is allocated. </p><dl class="section note"><dt>Note</dt><dd>This constructor is somewhat dangerous. People may be tempted to write something like <div class="fragment"><div class="line">BlockVector&lt;FieldVector&lt;double,1&gt; &gt; my_vector(100,0);</div>
</div><!-- fragment --> expecting to obtain a vector of 100 doubles initialized with zero. However, the code calls this constructor which tacitly does something else! </dd></dl>

</div>
</div>
<a id="a6e17f28660c4e56100fd82132bab56bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e17f28660c4e56100fd82132bab56bf">&#9670;&nbsp;</a></span>BlockVector() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01239.html">Dune::BlockVector</a>&lt; B, A &gt;::<a class="el" href="a01239.html">BlockVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01239.html">BlockVector</a>&lt; B, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy constructor </p>

</div>
</div>
<a id="a45a25328357a4158bbd65ea3e1c06fc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45a25328357a4158bbd65ea3e1c06fc5">&#9670;&nbsp;</a></span>BlockVector() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01239.html">Dune::BlockVector</a>&lt; B, A &gt;::<a class="el" href="a01239.html">BlockVector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01239.html">BlockVector</a>&lt; B, A &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>move constructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac38c155e30098a5887c1ad0f34840b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac38c155e30098a5887c1ad0f34840b3b">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01239.html#aad1aa0e3aabaa0ccd4aad8e49d81f349">size_type</a> <a class="el" href="a01239.html">Dune::BlockVector</a>&lt; B, A &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the capacity of the vector. </p>
<p>I. e. the maximum number of elements the vector can hold. </p><dl class="section return"><dt>Returns</dt><dd>The capacity of the vector. </dd></dl>

</div>
</div>
<a id="a4d34e9b8701afbab8599413cec7022c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d34e9b8701afbab8599413cec7022c8">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01239.html">BlockVector</a>&amp; <a class="el" href="a01239.html">Dune::BlockVector</a>&lt; B, A &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01239.html">BlockVector</a>&lt; B, A &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>move assignment </p>

</div>
</div>
<a id="a22cb35272533c055b3e45fec5e36d490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22cb35272533c055b3e45fec5e36d490">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01239.html">BlockVector</a>&amp; <a class="el" href="a01239.html">Dune::BlockVector</a>&lt; B, A &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01239.html">BlockVector</a>&lt; B, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>assignment </p>

</div>
</div>
<a id="aadfc3a9d047f164205319590d7ea6712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadfc3a9d047f164205319590d7ea6712">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01239.html">BlockVector</a>&amp; <a class="el" href="a01239.html">Dune::BlockVector</a>&lt; B, A &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01239.html#aa2debec6431c850994dc2d735fe1ce13">field_type</a> &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>assign from scalar </p>

</div>
</div>
<a id="a13bed42cd26580d6c81a1406589ce1da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13bed42cd26580d6c81a1406589ce1da">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01239.html">Dune::BlockVector</a>&lt; B, A &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01239.html#aad1aa0e3aabaa0ccd4aad8e49d81f349">size_type</a>&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserve space. </p>
<p>Allocate storage for up to <code>capacity</code> blocks. Resizing won't cause reallocation until the size exceeds the <code>capacity</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The maximum number of elements the vector needs to hold. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c827318ce2fc4dbc1f3d61d04e62f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c827318ce2fc4dbc1f3d61d04e62f16">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01239.html">Dune::BlockVector</a>&lt; B, A &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01239.html#aad1aa0e3aabaa0ccd4aad8e49d81f349">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize the vector. </p>
<p>Resize the vector to the given number of blocks. Blocks below the given size are copied (moved if possible). Old blocks above the given size are destructed, new blocks above the given size are value-initialized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The new number of blocks of the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af02395a3170f5a53bfc88ba6f7b33e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02395a3170f5a53bfc88ba6f7b33e97">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01239.html">Dune::BlockVector</a>&lt; B, A &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01239.html">BlockVector</a>&lt; B, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>swap operation </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a6a766d1205e0d6a81397e7b39db37e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a766d1205e0d6a81397e7b39db37e81">&#9670;&nbsp;</a></span>blocklevel</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class A  = std::allocator&lt;B&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned int <a class="el" href="a01239.html">Dune::BlockVector</a>&lt; B, A &gt;::blocklevel = <a class="el" href="a00252.html#a477c671e3966936ca929dee4be2dcf95">blockLevel</a>&lt;B&gt;()+1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>increment block level counter </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="a00032_source.html">bvector.hh</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
