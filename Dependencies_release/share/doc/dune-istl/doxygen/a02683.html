<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>dune-istl: Dune::IterativeSolver&lt; X, Y &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">dune-istl
   &#160;<span id="projectnumber">2.8.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00252.html">Dune</a></li><li class="navelem"><a class="el" href="a02683.html">IterativeSolver</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="a02680.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Dune::IterativeSolver&lt; X, Y &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="a00236.html">Iterative Solvers Template Library (ISTL)</a> &raquo; <a class="el" href="a00237.html">Iterative Solvers</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class for all implementations of iterative solvers.  
 <a href="a02683.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00197_source.html">dune/istl/solver.hh</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Dune::IterativeSolver&lt; X, Y &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="a02682.png" border="0" usemap="#a_dune_1_1_iterative_solver_3_01_x_00_01_y_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="a_dune_1_1_iterative_solver_3_01_x_00_01_y_01_4_inherit__map" id="a_dune_1_1_iterative_solver_3_01_x_00_01_y_01_4_inherit__map">
<area shape="rect" title="Base class for all implementations of iterative solvers." alt="" coords="205,216,344,257"/>
<area shape="rect" href="a02683.html" title=" " alt="" coords="443,216,581,257"/>
<area shape="rect" href="a02679.html" title="Abstract base class for all solvers." alt="" coords="5,216,156,257"/>
<area shape="rect" href="a02755.html" title=" " alt="" coords="959,343,1153,384"/>
<area shape="rect" href="a02747.html" title="Bi&#45;conjugate Gradient Stabilized (BiCG&#45;STAB)" alt="" coords="647,71,837,98"/>
<area shape="rect" href="a02743.html" title="conjugate gradient method" alt="" coords="669,122,815,149"/>
<area shape="rect" href="a02763.html" title="Generalized preconditioned conjugate gradient solver." alt="" coords="631,173,853,199"/>
<area shape="rect" href="a02739.html" title="gradient method" alt="" coords="655,223,829,250"/>
<area shape="rect" href="a02735.html" title="Preconditioned loop solver." alt="" coords="665,274,819,301"/>
<area shape="rect" href="a02751.html" title="Minimal Residual Method (MINRES)" alt="" coords="654,325,830,351"/>
<area shape="rect" href="a02767.html" title="Accelerated flexible conjugate gradient method." alt="" coords="637,426,847,453"/>
<area shape="rect" href="a02755.html" title="implements the Generalized Minimal Residual (GMRes) method" alt="" coords="645,5,839,47"/>
<area shape="rect" href="a02759.html" title="implements the Flexible Generalized Minimal Residual (FGMRes) method (right preconditioned)" alt="" coords="1209,343,1415,384"/>
<area shape="rect" href="a02771.html" title="Complete flexible conjugate gradient method." alt="" coords="952,426,1160,453"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02687.html">Iteration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for controlling iterative methods.  <a href="a02687.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aaba59848baa4879b548d96b9f77e150a"><td class="memItemLeft" align="right" valign="top">typedef X&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02679.html#aaba59848baa4879b548d96b9f77e150a">domain_type</a></td></tr>
<tr class="memdesc:aaba59848baa4879b548d96b9f77e150a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the domain of the operator to be inverted.  <a href="a02679.html#aaba59848baa4879b548d96b9f77e150a">More...</a><br /></td></tr>
<tr class="separator:aaba59848baa4879b548d96b9f77e150a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b7df40fa5e6a60c2a3db25a4140823"><td class="memItemLeft" align="right" valign="top">typedef Y&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02679.html#a85b7df40fa5e6a60c2a3db25a4140823">range_type</a></td></tr>
<tr class="memdesc:a85b7df40fa5e6a60c2a3db25a4140823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the range of the operator to be inverted.  <a href="a02679.html#a85b7df40fa5e6a60c2a3db25a4140823">More...</a><br /></td></tr>
<tr class="separator:a85b7df40fa5e6a60c2a3db25a4140823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce5c3d7c39415d90326ccc06b94b9dc"><td class="memItemLeft" align="right" valign="top">typedef X::field_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02679.html#adce5c3d7c39415d90326ccc06b94b9dc">field_type</a></td></tr>
<tr class="memdesc:adce5c3d7c39415d90326ccc06b94b9dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The field type of the operator.  <a href="a02679.html#adce5c3d7c39415d90326ccc06b94b9dc">More...</a><br /></td></tr>
<tr class="separator:adce5c3d7c39415d90326ccc06b94b9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08de8ceccc057d0785cfda953796a81"><td class="memItemLeft" align="right" valign="top">typedef FieldTraits&lt; <a class="el" href="a02679.html#adce5c3d7c39415d90326ccc06b94b9dc">field_type</a> &gt;::<a class="el" href="a02679.html#ae08de8ceccc057d0785cfda953796a81">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02679.html#ae08de8ceccc057d0785cfda953796a81">real_type</a></td></tr>
<tr class="memdesc:ae08de8ceccc057d0785cfda953796a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">The real type of the field type (is the same if using real numbers, but differs for std::complex)  <a href="a02679.html#ae08de8ceccc057d0785cfda953796a81">More...</a><br /></td></tr>
<tr class="separator:ae08de8ceccc057d0785cfda953796a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef8454657f69b2e69fcd9a2779cee4e"><td class="memItemLeft" align="right" valign="top">typedef Simd::Scalar&lt; <a class="el" href="a02679.html#ae08de8ceccc057d0785cfda953796a81">real_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02679.html#a7ef8454657f69b2e69fcd9a2779cee4e">scalar_real_type</a></td></tr>
<tr class="memdesc:a7ef8454657f69b2e69fcd9a2779cee4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">scalar type underlying the field_type  <a href="a02679.html#a7ef8454657f69b2e69fcd9a2779cee4e">More...</a><br /></td></tr>
<tr class="separator:a7ef8454657f69b2e69fcd9a2779cee4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa3aac0420d78c7e981855173998dfdbd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02683.html#aa3aac0420d78c7e981855173998dfdbd">IterativeSolver</a> (<a class="el" href="a01819.html">LinearOperator</a>&lt; X, Y &gt; &amp;op, <a class="el" href="a02583.html">Preconditioner</a>&lt; X, Y &gt; &amp;prec, <a class="el" href="a02679.html#a7ef8454657f69b2e69fcd9a2779cee4e">scalar_real_type</a> reduction, int maxit, int verbose)</td></tr>
<tr class="memdesc:aa3aac0420d78c7e981855173998dfdbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">General constructor to initialize an iterative solver.  <a href="a02683.html#aa3aac0420d78c7e981855173998dfdbd">More...</a><br /></td></tr>
<tr class="separator:aa3aac0420d78c7e981855173998dfdbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5c17e2cf1c34f2ff6c696d551c3acb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02683.html#a2e5c17e2cf1c34f2ff6c696d551c3acb">IterativeSolver</a> (<a class="el" href="a01819.html">LinearOperator</a>&lt; X, Y &gt; &amp;op, <a class="el" href="a02639.html">ScalarProduct</a>&lt; X &gt; &amp;sp, <a class="el" href="a02583.html">Preconditioner</a>&lt; X, Y &gt; &amp;prec, <a class="el" href="a02679.html#a7ef8454657f69b2e69fcd9a2779cee4e">scalar_real_type</a> reduction, int maxit, int verbose)</td></tr>
<tr class="memdesc:a2e5c17e2cf1c34f2ff6c696d551c3acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">General constructor to initialize an iterative solver.  <a href="a02683.html#a2e5c17e2cf1c34f2ff6c696d551c3acb">More...</a><br /></td></tr>
<tr class="separator:a2e5c17e2cf1c34f2ff6c696d551c3acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ff9476da2017980a0574aa0c3d3048"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02683.html#a95ff9476da2017980a0574aa0c3d3048">IterativeSolver</a> (std::shared_ptr&lt; <a class="el" href="a01819.html">LinearOperator</a>&lt; X, Y &gt; &gt; op, std::shared_ptr&lt; <a class="el" href="a02583.html">Preconditioner</a>&lt; X, X &gt; &gt; prec, const ParameterTree &amp;configuration)</td></tr>
<tr class="memdesc:a95ff9476da2017980a0574aa0c3d3048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="a02683.html#a95ff9476da2017980a0574aa0c3d3048">More...</a><br /></td></tr>
<tr class="separator:a95ff9476da2017980a0574aa0c3d3048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2fa55775d41709b976bfa306d8cd50e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02683.html#af2fa55775d41709b976bfa306d8cd50e">IterativeSolver</a> (std::shared_ptr&lt; <a class="el" href="a01819.html">LinearOperator</a>&lt; X, Y &gt; &gt; op, std::shared_ptr&lt; <a class="el" href="a02639.html">ScalarProduct</a>&lt; X &gt; &gt; sp, std::shared_ptr&lt; <a class="el" href="a02583.html">Preconditioner</a>&lt; X, X &gt; &gt; prec, const ParameterTree &amp;configuration)</td></tr>
<tr class="memdesc:af2fa55775d41709b976bfa306d8cd50e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="a02683.html#af2fa55775d41709b976bfa306d8cd50e">More...</a><br /></td></tr>
<tr class="separator:af2fa55775d41709b976bfa306d8cd50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9591f7951c8d340cda51ad6093ac9c12"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02683.html#a9591f7951c8d340cda51ad6093ac9c12">IterativeSolver</a> (std::shared_ptr&lt; <a class="el" href="a01819.html">LinearOperator</a>&lt; X, Y &gt;&gt; op, std::shared_ptr&lt; <a class="el" href="a02639.html">ScalarProduct</a>&lt; X &gt;&gt; sp, std::shared_ptr&lt; <a class="el" href="a02583.html">Preconditioner</a>&lt; X, Y &gt;&gt; prec, <a class="el" href="a02679.html#a7ef8454657f69b2e69fcd9a2779cee4e">scalar_real_type</a> reduction, int maxit, int verbose)</td></tr>
<tr class="memdesc:a9591f7951c8d340cda51ad6093ac9c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">General constructor to initialize an iterative solver.  <a href="a02683.html#a9591f7951c8d340cda51ad6093ac9c12">More...</a><br /></td></tr>
<tr class="separator:a9591f7951c8d340cda51ad6093ac9c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42273cb037e81940486a2109adf4a941"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02683.html#a42273cb037e81940486a2109adf4a941">apply</a> (X &amp;x, X &amp;b, double reduction, <a class="el" href="a02675.html">InverseOperatorResult</a> &amp;res)</td></tr>
<tr class="memdesc:a42273cb037e81940486a2109adf4a941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply inverse operator with given reduction factor.  <a href="a02683.html#a42273cb037e81940486a2109adf4a941">More...</a><br /></td></tr>
<tr class="separator:a42273cb037e81940486a2109adf4a941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e81a96530540ab4040226ad3346c51"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a02703.html#ae061380ac961490be6ee353cf0dc1733">SolverCategory::Category</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02683.html#af4e81a96530540ab4040226ad3346c51">category</a> () const</td></tr>
<tr class="memdesc:af4e81a96530540ab4040226ad3346c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Category of the solver (see <a class="el" href="a02703.html#ae061380ac961490be6ee353cf0dc1733">SolverCategory::Category</a>)  <a href="a02683.html#af4e81a96530540ab4040226ad3346c51">More...</a><br /></td></tr>
<tr class="separator:af4e81a96530540ab4040226ad3346c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a15e3a8451ca039a01251e25dad47c2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02683.html#a7a15e3a8451ca039a01251e25dad47c2">name</a> () const</td></tr>
<tr class="separator:a7a15e3a8451ca039a01251e25dad47c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef4f0b84f4a983421f15b6eea8c69ab"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02679.html#aaef4f0b84f4a983421f15b6eea8c69ab">apply</a> (X &amp;x, Y &amp;b, <a class="el" href="a02675.html">InverseOperatorResult</a> &amp;res)=0</td></tr>
<tr class="memdesc:aaef4f0b84f4a983421f15b6eea8c69ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply inverse operator,.  <a href="a02679.html#aaef4f0b84f4a983421f15b6eea8c69ab">More...</a><br /></td></tr>
<tr class="separator:aaef4f0b84f4a983421f15b6eea8c69ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a25fc54525ae58726ec0f274d5cc29"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02679.html#a57a25fc54525ae58726ec0f274d5cc29">apply</a> (X &amp;x, Y &amp;b, double reduction, <a class="el" href="a02675.html">InverseOperatorResult</a> &amp;res)=0</td></tr>
<tr class="memdesc:a57a25fc54525ae58726ec0f274d5cc29"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply inverse operator, with given convergence criteria.  <a href="a02679.html#a57a25fc54525ae58726ec0f274d5cc29">More...</a><br /></td></tr>
<tr class="separator:a57a25fc54525ae58726ec0f274d5cc29"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:aa1dfd25631ab66c43480f464a732afca"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="a02679.html#aa1dfd25631ab66c43480f464a732afcaa9fce7d3cb1a28247f8d0f8fe2d3863a7">iterationSpacing</a> = 5
, <a class="el" href="a02679.html#aa1dfd25631ab66c43480f464a732afcaa3e7887a2fbc4f073d7c6dde204557d94">normSpacing</a> = 16
 }</td></tr>
<tr class="separator:aa1dfd25631ab66c43480f464a732afca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a07986680755603e2cc783f8be1994d1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02679.html#a07986680755603e2cc783f8be1994d1f">printHeader</a> (std::ostream &amp;s) const</td></tr>
<tr class="memdesc:a07986680755603e2cc783f8be1994d1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function for printing header of solver output  <a href="a02679.html#a07986680755603e2cc783f8be1994d1f">More...</a><br /></td></tr>
<tr class="separator:a07986680755603e2cc783f8be1994d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45229eb4007296995264f4277a89b51c"><td class="memTemplParams" colspan="2">template&lt;typename CountType , typename DataType &gt; </td></tr>
<tr class="memitem:a45229eb4007296995264f4277a89b51c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a02679.html#a45229eb4007296995264f4277a89b51c">printOutput</a> (std::ostream &amp;s, const CountType &amp;iter, const DataType &amp;norm, const DataType &amp;norm_old) const</td></tr>
<tr class="memdesc:a45229eb4007296995264f4277a89b51c"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function for printing solver output  <a href="a02679.html#a45229eb4007296995264f4277a89b51c">More...</a><br /></td></tr>
<tr class="separator:a45229eb4007296995264f4277a89b51c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5876dba1ae3409f017e30cbd0a7838"><td class="memTemplParams" colspan="2">template&lt;typename CountType , typename DataType &gt; </td></tr>
<tr class="memitem:a1c5876dba1ae3409f017e30cbd0a7838"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a02679.html#a1c5876dba1ae3409f017e30cbd0a7838">printOutput</a> (std::ostream &amp;s, const CountType &amp;iter, const DataType &amp;norm) const</td></tr>
<tr class="memdesc:a1c5876dba1ae3409f017e30cbd0a7838"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function for printing solver output  <a href="a02679.html#a1c5876dba1ae3409f017e30cbd0a7838">More...</a><br /></td></tr>
<tr class="separator:a1c5876dba1ae3409f017e30cbd0a7838"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a94e87f284efd1ea398108ac23f77bda1"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="a01819.html">LinearOperator</a>&lt; X, Y &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02683.html#a94e87f284efd1ea398108ac23f77bda1">_op</a></td></tr>
<tr class="separator:a94e87f284efd1ea398108ac23f77bda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a8a49af428c01332ca8254f124de3e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="a02583.html">Preconditioner</a>&lt; X, Y &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02683.html#af4a8a49af428c01332ca8254f124de3e">_prec</a></td></tr>
<tr class="separator:af4a8a49af428c01332ca8254f124de3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d46723a40e4e699102cf1dc96c7713"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="a02639.html">ScalarProduct</a>&lt; X &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02683.html#a95d46723a40e4e699102cf1dc96c7713">_sp</a></td></tr>
<tr class="separator:a95d46723a40e4e699102cf1dc96c7713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9fa53fbc7b256e48620dd8acfbcac0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a02679.html#a7ef8454657f69b2e69fcd9a2779cee4e">scalar_real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02683.html#ac9fa53fbc7b256e48620dd8acfbcac0a">_reduction</a></td></tr>
<tr class="separator:ac9fa53fbc7b256e48620dd8acfbcac0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9fc491826e83b4b56e9d9354e07155"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02683.html#a9b9fc491826e83b4b56e9d9354e07155">_maxit</a></td></tr>
<tr class="separator:a9b9fc491826e83b4b56e9d9354e07155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd5c0f9fb28cea306a95fa326f197df"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02683.html#aafd5c0f9fb28cea306a95fa326f197df">_verbose</a></td></tr>
<tr class="separator:aafd5c0f9fb28cea306a95fa326f197df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86a07e35fee34640932781b5f0b57e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a02703.html#ae061380ac961490be6ee353cf0dc1733">SolverCategory::Category</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02683.html#ae86a07e35fee34640932781b5f0b57e8">_category</a></td></tr>
<tr class="separator:ae86a07e35fee34640932781b5f0b57e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class X, class Y&gt;<br />
class Dune::IterativeSolver&lt; X, Y &gt;</h3>

<p>Base class for all implementations of iterative solvers. </p>
<p>This class provides all storage, which is needed by the usual iterative solvers. In additional it provides all the necessary constructors, which are then only imported in the actual solver implementation. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aaba59848baa4879b548d96b9f77e150a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba59848baa4879b548d96b9f77e150a">&#9670;&nbsp;</a></span>domain_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef X <a class="el" href="a02679.html">Dune::InverseOperator</a>&lt; X, Y &gt;::<a class="el" href="a02679.html#aaba59848baa4879b548d96b9f77e150a">domain_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of the domain of the operator to be inverted. </p>

</div>
</div>
<a id="adce5c3d7c39415d90326ccc06b94b9dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce5c3d7c39415d90326ccc06b94b9dc">&#9670;&nbsp;</a></span>field_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef X::field_type <a class="el" href="a02679.html">Dune::InverseOperator</a>&lt; X, Y &gt;::<a class="el" href="a02679.html#adce5c3d7c39415d90326ccc06b94b9dc">field_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The field type of the operator. </p>

</div>
</div>
<a id="a85b7df40fa5e6a60c2a3db25a4140823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b7df40fa5e6a60c2a3db25a4140823">&#9670;&nbsp;</a></span>range_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef Y <a class="el" href="a02679.html">Dune::InverseOperator</a>&lt; X, Y &gt;::<a class="el" href="a02679.html#a85b7df40fa5e6a60c2a3db25a4140823">range_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of the range of the operator to be inverted. </p>

</div>
</div>
<a id="ae08de8ceccc057d0785cfda953796a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae08de8ceccc057d0785cfda953796a81">&#9670;&nbsp;</a></span>real_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef FieldTraits&lt;<a class="el" href="a02679.html#adce5c3d7c39415d90326ccc06b94b9dc">field_type</a>&gt;::<a class="el" href="a02679.html#ae08de8ceccc057d0785cfda953796a81">real_type</a> <a class="el" href="a02679.html">Dune::InverseOperator</a>&lt; X, Y &gt;::<a class="el" href="a02679.html#ae08de8ceccc057d0785cfda953796a81">real_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The real type of the field type (is the same if using real numbers, but differs for std::complex) </p>

</div>
</div>
<a id="a7ef8454657f69b2e69fcd9a2779cee4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef8454657f69b2e69fcd9a2779cee4e">&#9670;&nbsp;</a></span>scalar_real_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef Simd::Scalar&lt;<a class="el" href="a02679.html#ae08de8ceccc057d0785cfda953796a81">real_type</a>&gt; <a class="el" href="a02679.html">Dune::InverseOperator</a>&lt; X, Y &gt;::<a class="el" href="a02679.html#a7ef8454657f69b2e69fcd9a2779cee4e">scalar_real_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>scalar type underlying the field_type </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="aa1dfd25631ab66c43480f464a732afca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1dfd25631ab66c43480f464a732afca">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa1dfd25631ab66c43480f464a732afcaa9fce7d3cb1a28247f8d0f8fe2d3863a7"></a>iterationSpacing&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa1dfd25631ab66c43480f464a732afcaa3e7887a2fbc4f073d7c6dde204557d94"></a>normSpacing&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa3aac0420d78c7e981855173998dfdbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3aac0420d78c7e981855173998dfdbd">&#9670;&nbsp;</a></span>IterativeSolver() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02683.html">Dune::IterativeSolver</a>&lt; X, Y &gt;::<a class="el" href="a02683.html">IterativeSolver</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01819.html">LinearOperator</a>&lt; X, Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a02583.html">Preconditioner</a>&lt; X, Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>prec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a02679.html#a7ef8454657f69b2e69fcd9a2779cee4e">scalar_real_type</a>&#160;</td>
          <td class="paramname"><em>reduction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>General constructor to initialize an iterative solver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operator we solve. </td></tr>
    <tr><td class="paramname">prec</td><td>The preconditioner to apply in each iteration of the loop. Has to inherit from <a class="el" href="a02583.html" title="Base class for matrix free definition of preconditioners.">Preconditioner</a>. </td></tr>
    <tr><td class="paramname">reduction</td><td>The relative defect reduction to achieve when applying the operator. </td></tr>
    <tr><td class="paramname">maxit</td><td>The maximum number of iteration steps allowed when applying the operator. </td></tr>
    <tr><td class="paramname">verbose</td><td>The verbosity level.</td></tr>
  </table>
  </dd>
</dl>
<p>Verbose levels are: </p><ul>
<li>
0 : print nothing  </li>
<li>
1 : print initial and final defect and statistics  </li>
<li>
2 : print line for each iteration  </li>
</ul>

</div>
</div>
<a id="a2e5c17e2cf1c34f2ff6c696d551c3acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e5c17e2cf1c34f2ff6c696d551c3acb">&#9670;&nbsp;</a></span>IterativeSolver() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02683.html">Dune::IterativeSolver</a>&lt; X, Y &gt;::<a class="el" href="a02683.html">IterativeSolver</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01819.html">LinearOperator</a>&lt; X, Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a02639.html">ScalarProduct</a>&lt; X &gt; &amp;&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a02583.html">Preconditioner</a>&lt; X, Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>prec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a02679.html#a7ef8454657f69b2e69fcd9a2779cee4e">scalar_real_type</a>&#160;</td>
          <td class="paramname"><em>reduction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>General constructor to initialize an iterative solver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operator we solve. </td></tr>
    <tr><td class="paramname">sp</td><td>The scalar product to use, e. g. SeqScalarproduct. </td></tr>
    <tr><td class="paramname">prec</td><td>The preconditioner to apply in each iteration of the loop. Has to inherit from <a class="el" href="a02583.html" title="Base class for matrix free definition of preconditioners.">Preconditioner</a>. </td></tr>
    <tr><td class="paramname">reduction</td><td>The relative defect reduction to achieve when applying the operator. </td></tr>
    <tr><td class="paramname">maxit</td><td>The maximum number of iteration steps allowed when applying the operator. </td></tr>
    <tr><td class="paramname">verbose</td><td>The verbosity level.</td></tr>
  </table>
  </dd>
</dl>
<p>Verbose levels are: </p><ul>
<li>
0 : print nothing  </li>
<li>
1 : print initial and final defect and statistics  </li>
<li>
2 : print line for each iteration  </li>
</ul>

</div>
</div>
<a id="a95ff9476da2017980a0574aa0c3d3048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95ff9476da2017980a0574aa0c3d3048">&#9670;&nbsp;</a></span>IterativeSolver() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02683.html">Dune::IterativeSolver</a>&lt; X, Y &gt;::<a class="el" href="a02683.html">IterativeSolver</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="a01819.html">LinearOperator</a>&lt; X, Y &gt; &gt;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="a02583.html">Preconditioner</a>&lt; X, X &gt; &gt;&#160;</td>
          <td class="paramname"><em>prec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ParameterTree &amp;&#160;</td>
          <td class="paramname"><em>configuration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operator we solve </td></tr>
    <tr><td class="paramname">prec</td><td>The preconditioner to apply in each iteration of the loop. </td></tr>
    <tr><td class="paramname">configuration</td><td>ParameterTree containing iterative solver parameters.</td></tr>
  </table>
  </dd>
</dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">ParameterTree Key   </th><th class="markdownTableHeadNone">Meaning    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">reduction   </td><td class="markdownTableBodyNone">The relative defect reduction to achieve when applying the operator    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">maxit   </td><td class="markdownTableBodyNone">The maximum number of iteration steps allowed when applying the operator    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">verbose   </td><td class="markdownTableBodyNone">The verbosity level   </td></tr>
</table>
<p>See <a class="el" href="a00250.html">ISTL_Factory</a> for the ParameterTree layout and examples. </p>

</div>
</div>
<a id="af2fa55775d41709b976bfa306d8cd50e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2fa55775d41709b976bfa306d8cd50e">&#9670;&nbsp;</a></span>IterativeSolver() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02683.html">Dune::IterativeSolver</a>&lt; X, Y &gt;::<a class="el" href="a02683.html">IterativeSolver</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="a01819.html">LinearOperator</a>&lt; X, Y &gt; &gt;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="a02639.html">ScalarProduct</a>&lt; X &gt; &gt;&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="a02583.html">Preconditioner</a>&lt; X, X &gt; &gt;&#160;</td>
          <td class="paramname"><em>prec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ParameterTree &amp;&#160;</td>
          <td class="paramname"><em>configuration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operator we solve </td></tr>
    <tr><td class="paramname">sp</td><td>The scalar product to use, e. g. SeqScalarproduct. </td></tr>
    <tr><td class="paramname">prec</td><td>The preconditioner to apply in each iteration of the loop. </td></tr>
    <tr><td class="paramname">configuration</td><td>ParameterTree containing iterative solver parameters.</td></tr>
  </table>
  </dd>
</dl>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">ParameterTree Key   </th><th class="markdownTableHeadNone">Meaning    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">reduction   </td><td class="markdownTableBodyNone">The relative defect reduction to achieve when applying the operator    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">maxit   </td><td class="markdownTableBodyNone">The maximum number of iteration steps allowed when applying the operator    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">verbose   </td><td class="markdownTableBodyNone">The verbosity level   </td></tr>
</table>
<p>See <a class="el" href="a00250.html">ISTL_Factory</a> for the ParameterTree layout and examples. </p>

</div>
</div>
<a id="a9591f7951c8d340cda51ad6093ac9c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9591f7951c8d340cda51ad6093ac9c12">&#9670;&nbsp;</a></span>IterativeSolver() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02683.html">Dune::IterativeSolver</a>&lt; X, Y &gt;::<a class="el" href="a02683.html">IterativeSolver</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="a01819.html">LinearOperator</a>&lt; X, Y &gt;&gt;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="a02639.html">ScalarProduct</a>&lt; X &gt;&gt;&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="a02583.html">Preconditioner</a>&lt; X, Y &gt;&gt;&#160;</td>
          <td class="paramname"><em>prec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a02679.html#a7ef8454657f69b2e69fcd9a2779cee4e">scalar_real_type</a>&#160;</td>
          <td class="paramname"><em>reduction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>General constructor to initialize an iterative solver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operator we solve. </td></tr>
    <tr><td class="paramname">sp</td><td>The scalar product to use, e. g. SeqScalarproduct. </td></tr>
    <tr><td class="paramname">prec</td><td>The preconditioner to apply in each iteration of the loop. Has to inherit from <a class="el" href="a02583.html" title="Base class for matrix free definition of preconditioners.">Preconditioner</a>. </td></tr>
    <tr><td class="paramname">reduction</td><td>The relative defect reduction to achieve when applying the operator. </td></tr>
    <tr><td class="paramname">maxit</td><td>The maximum number of iteration steps allowed when applying the operator. </td></tr>
    <tr><td class="paramname">verbose</td><td>The verbosity level.</td></tr>
  </table>
  </dd>
</dl>
<p>Verbose levels are: </p><ul>
<li>
0 : print nothing  </li>
<li>
1 : print initial and final defect and statistics  </li>
<li>
2 : print line for each iteration  </li>
</ul>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a42273cb037e81940486a2109adf4a941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42273cb037e81940486a2109adf4a941">&#9670;&nbsp;</a></span>apply() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="a02683.html">Dune::IterativeSolver</a>&lt; X, Y &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>reduction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a02675.html">InverseOperatorResult</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply inverse operator with given reduction factor. </p>
<p>apply inverse operator, with given convergence criteria. </p><dl class="section warning"><dt>Warning</dt><dd>Right hand side b may be overwritten!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The left hand side to store the result in. </td></tr>
    <tr><td class="paramname">b</td><td>The right hand side </td></tr>
    <tr><td class="paramname">reduction</td><td>The minimum defect reduction to achieve. </td></tr>
    <tr><td class="paramname">res</td><td>Object to store the statistics about applying the operator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a01395.html" title="Thrown when a solver aborts due to some problem.">SolverAbort</a></td><td>When the solver detects a problem and cannot continue </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57a25fc54525ae58726ec0f274d5cc29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a25fc54525ae58726ec0f274d5cc29">&#9670;&nbsp;</a></span>apply() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="a02679.html">Dune::InverseOperator</a>&lt; X, Y &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>reduction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a02675.html">InverseOperatorResult</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>apply inverse operator, with given convergence criteria. </p>
<dl class="section warning"><dt>Warning</dt><dd>Right hand side b may be overwritten!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The left hand side to store the result in. </td></tr>
    <tr><td class="paramname">b</td><td>The right hand side </td></tr>
    <tr><td class="paramname">reduction</td><td>The minimum defect reduction to achieve. </td></tr>
    <tr><td class="paramname">res</td><td>Object to store the statistics about applying the operator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a01395.html" title="Thrown when a solver aborts due to some problem.">SolverAbort</a></td><td>When the solver detects a problem and cannot continue </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="a02683.html#a42273cb037e81940486a2109adf4a941">Dune::IterativeSolver&lt; X, X &gt;</a>.</p>

</div>
</div>
<a id="aaef4f0b84f4a983421f15b6eea8c69ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef4f0b84f4a983421f15b6eea8c69ab">&#9670;&nbsp;</a></span>apply() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="a02679.html">Dune::InverseOperator</a>&lt; X, Y &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a02675.html">InverseOperatorResult</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply inverse operator,. </p>
<dl class="section warning"><dt>Warning</dt><dd>Note: right hand side b may be overwritten!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The left hand side to store the result in. </td></tr>
    <tr><td class="paramname">b</td><td>The right hand side </td></tr>
    <tr><td class="paramname">res</td><td>Object to store the statistics about applying the operator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="a01395.html" title="Thrown when a solver aborts due to some problem.">SolverAbort</a></td><td>When the solver detects a problem and cannot continue </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="a02771.html#ab9f6aeaed8af96e9ae901f1b8852de2e">Dune::CompleteFCGSolver&lt; X &gt;</a>, <a class="el" href="a02767.html#abebe8348b669681d556520449a5e4fa6">Dune::RestartedFCGSolver&lt; X &gt;</a>, <a class="el" href="a02763.html#a6f5103064e2d418df87cdf32f32763d0">Dune::GeneralizedPCGSolver&lt; X &gt;</a>, <a class="el" href="a02755.html#ade9aa220eb9c8e1c792d95a6b828a355">Dune::RestartedGMResSolver&lt; X, X &gt;</a>, <a class="el" href="a02751.html#a05aa4f1d7d2ce815c9018a511aa74536">Dune::MINRESSolver&lt; X &gt;</a>, <a class="el" href="a02747.html#a9531f3a435dfb9b4eb1ace39345fc8bb">Dune::BiCGSTABSolver&lt; X &gt;</a>, <a class="el" href="a02743.html#a56c73d203a465dc8cd09a99254cc47d0">Dune::CGSolver&lt; X &gt;</a>, <a class="el" href="a02739.html#a2aeda3b340632ac7cf4efd509a1f7ba2">Dune::GradientSolver&lt; X &gt;</a>, and <a class="el" href="a02735.html#a4dc4fe89a41de2aaee395ade4ac96e7c">Dune::LoopSolver&lt; X &gt;</a>.</p>

</div>
</div>
<a id="af4e81a96530540ab4040226ad3346c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4e81a96530540ab4040226ad3346c51">&#9670;&nbsp;</a></span>category()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a02703.html#ae061380ac961490be6ee353cf0dc1733">SolverCategory::Category</a> <a class="el" href="a02683.html">Dune::IterativeSolver</a>&lt; X, Y &gt;::category </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Category of the solver (see <a class="el" href="a02703.html#ae061380ac961490be6ee353cf0dc1733">SolverCategory::Category</a>) </p>

<p>Implements <a class="el" href="a02679.html#ae74604dd6afec05c0e2a080fe403d2a1">Dune::InverseOperator&lt; X, Y &gt;</a>.</p>

</div>
</div>
<a id="a7a15e3a8451ca039a01251e25dad47c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a15e3a8451ca039a01251e25dad47c2">&#9670;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="a02683.html">Dune::IterativeSolver</a>&lt; X, Y &gt;::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a07986680755603e2cc783f8be1994d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07986680755603e2cc783f8be1994d1f">&#9670;&nbsp;</a></span>printHeader()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a02679.html">Dune::InverseOperator</a>&lt; X, Y &gt;::printHeader </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper function for printing header of solver output </p>

</div>
</div>
<a id="a1c5876dba1ae3409f017e30cbd0a7838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c5876dba1ae3409f017e30cbd0a7838">&#9670;&nbsp;</a></span>printOutput() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<div class="memtemplate">
template&lt;typename CountType , typename DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a02679.html">Dune::InverseOperator</a>&lt; X, Y &gt;::printOutput </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CountType &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataType &amp;&#160;</td>
          <td class="paramname"><em>norm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper function for printing solver output </p>

</div>
</div>
<a id="a45229eb4007296995264f4277a89b51c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45229eb4007296995264f4277a89b51c">&#9670;&nbsp;</a></span>printOutput() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<div class="memtemplate">
template&lt;typename CountType , typename DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a02679.html">Dune::InverseOperator</a>&lt; X, Y &gt;::printOutput </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CountType &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataType &amp;&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataType &amp;&#160;</td>
          <td class="paramname"><em>norm_old</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper function for printing solver output </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae86a07e35fee34640932781b5f0b57e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae86a07e35fee34640932781b5f0b57e8">&#9670;&nbsp;</a></span>_category</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02703.html#ae061380ac961490be6ee353cf0dc1733">SolverCategory::Category</a> <a class="el" href="a02683.html">Dune::IterativeSolver</a>&lt; X, Y &gt;::_category</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b9fc491826e83b4b56e9d9354e07155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9fc491826e83b4b56e9d9354e07155">&#9670;&nbsp;</a></span>_maxit</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="a02683.html">Dune::IterativeSolver</a>&lt; X, Y &gt;::_maxit</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a94e87f284efd1ea398108ac23f77bda1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94e87f284efd1ea398108ac23f77bda1">&#9670;&nbsp;</a></span>_op</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="a01819.html">LinearOperator</a>&lt;X,Y&gt; &gt; <a class="el" href="a02683.html">Dune::IterativeSolver</a>&lt; X, Y &gt;::_op</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af4a8a49af428c01332ca8254f124de3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a8a49af428c01332ca8254f124de3e">&#9670;&nbsp;</a></span>_prec</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="a02583.html">Preconditioner</a>&lt;X,Y&gt; &gt; <a class="el" href="a02683.html">Dune::IterativeSolver</a>&lt; X, Y &gt;::_prec</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9fa53fbc7b256e48620dd8acfbcac0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9fa53fbc7b256e48620dd8acfbcac0a">&#9670;&nbsp;</a></span>_reduction</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02679.html#a7ef8454657f69b2e69fcd9a2779cee4e">scalar_real_type</a> <a class="el" href="a02683.html">Dune::IterativeSolver</a>&lt; X, Y &gt;::_reduction</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a95d46723a40e4e699102cf1dc96c7713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d46723a40e4e699102cf1dc96c7713">&#9670;&nbsp;</a></span>_sp</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="a02639.html">ScalarProduct</a>&lt;X&gt; &gt; <a class="el" href="a02683.html">Dune::IterativeSolver</a>&lt; X, Y &gt;::_sp</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aafd5c0f9fb28cea306a95fa326f197df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafd5c0f9fb28cea306a95fa326f197df">&#9670;&nbsp;</a></span>_verbose</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="a02683.html">Dune::IterativeSolver</a>&lt; X, Y &gt;::_verbose</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="a00197_source.html">solver.hh</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
