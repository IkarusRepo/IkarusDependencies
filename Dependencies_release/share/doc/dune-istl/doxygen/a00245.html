<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>dune-istl: Preconditioners</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">dune-istl
   &#160;<span id="projectnumber">2.8.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Preconditioners<div class="ingroups"><a class="el" href="a00236.html">Iterative Solvers Template Library (ISTL)</a> &raquo; <a class="el" href="a00237.html">Iterative Solvers</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Preconditioners:</div>
<div class="dyncontent">
<div class="center"><img src="a00245.png" border="0" usemap="#aa00245" alt=""/></div>
<map name="aa00245" id="aa00245">
<area shape="rect" title=" " alt="" coords="167,77,279,102"/>
<area shape="rect" href="a00244.html" title="An Algebraic Multigrid based on Agglomeration that saves memory bandwidth." alt="" coords="505,5,683,45"/>
<area shape="rect" href="a00243.html" title="A Parallel Algebraic Multigrid based on Agglomeration." alt="" coords="533,69,655,109"/>
<area shape="rect" href="a00236.html" title="Iterative Solvers supporting block recursive matrix and vector classes at compile time." alt="" coords="509,133,679,173"/>
<area shape="rect" href="a00237.html" title=" " alt="" coords="5,77,117,102"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:a00243"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html">Parallel Algebraic Multigrid</a></td></tr>
<tr class="memdesc:a00243"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Parallel Algebraic Multigrid based on Agglomeration. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00244"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00244.html">Fast (sequential) Algebraic Multigrid</a></td></tr>
<tr class="memdesc:a00244"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Algebraic Multigrid based on Agglomeration that saves memory bandwidth. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:a00107"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00107.html">overlappingschwarz.hh</a></td></tr>
<tr class="memdesc:a00107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains one level overlapping Schwarz preconditioners. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00182"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00182.html">preconditioners.hh</a></td></tr>
<tr class="memdesc:a00182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define general preconditioner interface. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01815.html">Dune::NonoverlappingBlockPreconditioner&lt; C, P &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nonoverlapping parallel preconditioner.  <a href="a01815.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01403.html">Dune::SeqOverlappingSchwarz&lt; M, X, TM, TD, TA &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequential overlapping Schwarz preconditioner.  <a href="a01403.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01123.html">Dune::OverlappingSchwarzInitializer&lt; I, S, D &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer for <a class="el" href="a02839.html" title="SuperLu Solver.">SuperLU</a> Matrices representing the subdomains.  <a href="a01123.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01835.html">Dune::AdditiveSchwarzMode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag that the tells the Schwarz method to be additive.  <a href="a01835.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01839.html">Dune::MultiplicativeSchwarzMode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag that tells the Schwarz method to be multiplicative.  <a href="a01839.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01843.html">Dune::SymmetricMultiplicativeSchwarzMode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag that tells the Schwarz method to be multiplicative and symmetric.  <a href="a01843.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01847.html">Dune::DynamicMatrixSubdomainSolver&lt; M, X, Y &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exact subdomain solver using Dune::DynamicMatrix&lt;T&gt;::solve.  <a href="a01847.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01851.html">Dune::DynamicMatrixSubdomainSolver&lt; BCRSMatrix&lt; K, Al &gt;, X, Y &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01855.html">Dune::OverlappingAssignerHelper&lt; T, tag &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01859.html">Dune::OverlappingAssignerHelper&lt; DynamicMatrixSubdomainSolver&lt; BCRSMatrix&lt; K, Al &gt;, X, Y &gt;, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01863.html">Dune::OverlappingAssignerHelper&lt; S&lt; BCRSMatrix&lt; T, A &gt; &gt;, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01867.html">Dune::OverlappingAssignerILUBase&lt; M, X, Y &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01871.html">Dune::OverlappingAssignerHelper&lt; ILU0SubdomainSolver&lt; M, X, Y &gt;, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01875.html">Dune::OverlappingAssignerHelper&lt; ILUNSubdomainSolver&lt; M, X, Y &gt;, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01879.html">Dune::AdditiveAdder&lt; S, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01883.html">Dune::AdditiveAdder&lt; S, BlockVector&lt; T, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01887.html">Dune::MultiplicativeAdder&lt; S, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01891.html">Dune::MultiplicativeAdder&lt; S, BlockVector&lt; T, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01895.html">Dune::AdderSelector&lt; T, X, S &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">template meta program for choosing how to add the correction.  <a href="a01895.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01899.html">Dune::AdderSelector&lt; AdditiveSchwarzMode, X, S &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01903.html">Dune::AdderSelector&lt; MultiplicativeSchwarzMode, X, S &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01907.html">Dune::AdderSelector&lt; SymmetricMultiplicativeSchwarzMode, X, S &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01911.html">Dune::IteratorDirectionSelector&lt; T1, T2, forward &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template meta program for application of overlapping Schwarz.  <a href="a01911.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01915.html">Dune::IteratorDirectionSelector&lt; T1, T2, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01919.html">Dune::SeqOverlappingSchwarzApplier&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template meta program for application of overlapping Schwarz.  <a href="a01919.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01923.html">Dune::SeqOverlappingSchwarzApplier&lt; SeqOverlappingSchwarz&lt; M, X, SymmetricMultiplicativeSchwarzMode, TD, TA &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01407.html">Dune::SeqOverlappingSchwarzAssemblerHelper&lt; T, tag &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01927.html">Dune::SeqOverlappingSchwarzAssemblerHelper&lt; DynamicMatrixSubdomainSolver&lt; BCRSMatrix&lt; K, Al &gt;, X, Y &gt;, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01931.html">Dune::SeqOverlappingSchwarzAssemblerHelper&lt; S&lt; BCRSMatrix&lt; T, A &gt; &gt;, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01935.html">Dune::SeqOverlappingSchwarzAssemblerILUBase&lt; M, X, Y &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01939.html">Dune::SeqOverlappingSchwarzAssemblerHelper&lt; ILU0SubdomainSolver&lt; M, X, Y &gt;, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01943.html">Dune::SeqOverlappingSchwarzAssemblerHelper&lt; ILUNSubdomainSolver&lt; M, X, Y &gt;, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01947.html">Dune::SeqOverlappingSchwarzDomainSize&lt; M &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01951.html">Dune::SeqOverlappingSchwarzDomainSize&lt; BCRSMatrix&lt; T, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02583.html">Dune::Preconditioner&lt; X, Y &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for matrix free definition of preconditioners.  <a href="a02583.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02587.html">Dune::InverseOperator2Preconditioner&lt; O, c &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns an <a class="el" href="a02679.html" title="Abstract base class for all solvers.">InverseOperator</a> into a <a class="el" href="a02583.html" title="Base class for matrix free definition of preconditioners.">Preconditioner</a>.  <a href="a02587.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02591.html">Dune::SeqSSOR&lt; M, X, Y, l &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequential SSOR preconditioner.  <a href="a02591.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02595.html">Dune::SeqSOR&lt; M, X, Y, l &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequential SOR preconditioner.  <a href="a02595.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02599.html">Dune::SeqJac&lt; M, X, Y, l &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sequential jacobian preconditioner.  <a href="a02599.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02603.html">Dune::SeqILU&lt; M, X, Y, l &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequential <a class="el" href="a00261.html">ILU</a> preconditioner.  <a href="a02603.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02607.html">Dune::Richardson&lt; X, Y &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a02607.html" title="Richardson preconditioner.">Richardson</a> preconditioner.  <a href="a02607.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02611.html">Dune::SeqILDL&lt; M, X, Y &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">sequential ILDL preconditioner  <a href="a02611.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga57430ed63b8d6900976df9950af0a0bb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga57430ed63b8d6900976df9950af0a0bb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00245.html#ga57430ed63b8d6900976df9950af0a0bb">Dune::OverlappingAssigner</a> = <a class="el" href="a01855.html">OverlappingAssignerHelper</a>&lt; T, <a class="el" href="a02779.html">Dune::StoresColumnCompressed</a>&lt; T &gt;::value &gt;</td></tr>
<tr class="separator:ga57430ed63b8d6900976df9950af0a0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a5d6fa4ec6f65757b49ed7fe09e15e2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga5a5d6fa4ec6f65757b49ed7fe09e15e2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00245.html#ga5a5d6fa4ec6f65757b49ed7fe09e15e2">Dune::SeqOverlappingSchwarzAssembler</a> = <a class="el" href="a01407.html">SeqOverlappingSchwarzAssemblerHelper</a>&lt; T, <a class="el" href="a02779.html">Dune::StoresColumnCompressed</a>&lt; T &gt;::value &gt;</td></tr>
<tr class="separator:ga5a5d6fa4ec6f65757b49ed7fe09e15e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf04e8521e43d7b1c8fdb3a412210b36d"><td class="memTemplParams" colspan="2">template&lt;class M , class X , class Y , int l = 1&gt; </td></tr>
<tr class="memitem:gaf04e8521e43d7b1c8fdb3a412210b36d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00245.html#gaf04e8521e43d7b1c8fdb3a412210b36d">Dune::SeqGS</a> = <a class="el" href="a02595.html">SeqSOR</a>&lt; M, X, Y, l &gt;</td></tr>
<tr class="memdesc:gaf04e8521e43d7b1c8fdb3a412210b36d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequential Gauss Seidel preconditioner.  <a href="a00245.html#gaf04e8521e43d7b1c8fdb3a412210b36d">More...</a><br /></td></tr>
<tr class="separator:gaf04e8521e43d7b1c8fdb3a412210b36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga31161bee90db194d09f233f00ab4de9c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga31161bee90db194d09f233f00ab4de9c">Dune::DUNE_REGISTER_PRECONDITIONER</a> (&quot;ssor&quot;, defaultPreconditionerBlockLevelCreator&lt; <a class="el" href="a02591.html">Dune::SeqSSOR</a> &gt;())</td></tr>
<tr class="separator:ga31161bee90db194d09f233f00ab4de9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84e1da868870a635c00649be4e1d101b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga84e1da868870a635c00649be4e1d101b">Dune::DUNE_REGISTER_PRECONDITIONER</a> (&quot;sor&quot;, defaultPreconditionerBlockLevelCreator&lt; <a class="el" href="a02595.html">Dune::SeqSOR</a> &gt;())</td></tr>
<tr class="separator:ga84e1da868870a635c00649be4e1d101b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08abf358156090136c1433291819a194"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga08abf358156090136c1433291819a194">Dune::DUNE_REGISTER_PRECONDITIONER</a> (&quot;gs&quot;, defaultPreconditionerBlockLevelCreator&lt; <a class="el" href="a00245.html#gaf04e8521e43d7b1c8fdb3a412210b36d">Dune::SeqGS</a> &gt;())</td></tr>
<tr class="separator:ga08abf358156090136c1433291819a194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e0768493ba56650387ef7f1171d2620"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga8e0768493ba56650387ef7f1171d2620">Dune::DUNE_REGISTER_PRECONDITIONER</a> (&quot;jac&quot;, defaultPreconditionerBlockLevelCreator&lt; <a class="el" href="a02599.html">Dune::SeqJac</a> &gt;())</td></tr>
<tr class="separator:ga8e0768493ba56650387ef7f1171d2620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdfc9bd7597c826fa723af53d0cb0e2d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#gabdfc9bd7597c826fa723af53d0cb0e2d">Dune::DUNE_REGISTER_PRECONDITIONER</a> (&quot;ilu&quot;, defaultPreconditionerBlockLevelCreator&lt; <a class="el" href="a02603.html">Dune::SeqILU</a> &gt;())</td></tr>
<tr class="separator:gabdfc9bd7597c826fa723af53d0cb0e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c0383c6a267d2dd7bdf0425463c95dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga6c0383c6a267d2dd7bdf0425463c95dc">Dune::DUNE_REGISTER_PRECONDITIONER</a> (&quot;richardson&quot;, [](auto tl, const auto &amp;, const ParameterTree &amp;config){ using D=typename Dune::TypeListElement&lt; 1, decltype(tl)&gt;::type;using R=typename Dune::TypeListElement&lt; 2, decltype(tl)&gt;::type;return std::make_shared&lt; <a class="el" href="a02607.html">Richardson</a>&lt; D, R &gt;&gt;(config);})</td></tr>
<tr class="separator:ga6c0383c6a267d2dd7bdf0425463c95dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada61707dc136db5a195bef80037d5246"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#gada61707dc136db5a195bef80037d5246">Dune::DUNE_REGISTER_PRECONDITIONER</a> (&quot;ildl&quot;, defaultPreconditionerCreator&lt; <a class="el" href="a02611.html">Dune::SeqILDL</a> &gt;())</td></tr>
<tr class="separator:gada61707dc136db5a195bef80037d5246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga680ecf80821212aaa8149d72eea3010e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga680ecf80821212aaa8149d72eea3010e">Dune::OverlappingSchwarzInitializer&lt; I, S, D &gt;::OverlappingSchwarzInitializer</a> (<a class="el" href="a01123.html#abec4859ff0228c9b8af3095b41cb8b0a">InitializerList</a> &amp;il, const <a class="el" href="a01123.html#a4720a7ee7e9cb7069df83bcb38bcbcee">IndexSet</a> &amp;indices, const <a class="el" href="a01123.html#ae876d38e035d6edaae28a4ff0ffd59ac">subdomain_vector</a> &amp;domains)</td></tr>
<tr class="separator:ga680ecf80821212aaa8149d72eea3010e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01ce789c3fd3870dee0f0df52eac92c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga01ce789c3fd3870dee0f0df52eac92c5">Dune::OverlappingSchwarzInitializer&lt; I, S, D &gt;::addRowNnz</a> (const <a class="el" href="a01123.html#a7262d3824fe191c948ed60e1156eb872">Iter</a> &amp;row)</td></tr>
<tr class="separator:ga01ce789c3fd3870dee0f0df52eac92c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga995ede9ec46c2990a1f249b4096a827a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga995ede9ec46c2990a1f249b4096a827a">Dune::OverlappingSchwarzInitializer&lt; I, S, D &gt;::allocate</a> ()</td></tr>
<tr class="separator:ga995ede9ec46c2990a1f249b4096a827a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5ed84777f6e2f1181aae4198ab75e12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#gac5ed84777f6e2f1181aae4198ab75e12">Dune::OverlappingSchwarzInitializer&lt; I, S, D &gt;::countEntries</a> (const <a class="el" href="a01123.html#a7262d3824fe191c948ed60e1156eb872">Iter</a> &amp;row, const <a class="el" href="a01123.html#a1992e4a416cb68438b2c51122f4af880">CIter</a> &amp;<a class="el" href="a00240.html#ga67ae04c7e7c030370f82da49ab2b98d1">col</a>) const</td></tr>
<tr class="separator:gac5ed84777f6e2f1181aae4198ab75e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fa860d4fc5e8db80cd39b1c377d407f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga0fa860d4fc5e8db80cd39b1c377d407f">Dune::OverlappingSchwarzInitializer&lt; I, S, D &gt;::calcColstart</a> () const</td></tr>
<tr class="separator:ga0fa860d4fc5e8db80cd39b1c377d407f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49aa7ec764cdad87e4336c4f62598c76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga49aa7ec764cdad87e4336c4f62598c76">Dune::OverlappingSchwarzInitializer&lt; I, S, D &gt;::copyValue</a> (const <a class="el" href="a01123.html#a7262d3824fe191c948ed60e1156eb872">Iter</a> &amp;row, const <a class="el" href="a01123.html#a1992e4a416cb68438b2c51122f4af880">CIter</a> &amp;<a class="el" href="a00240.html#ga67ae04c7e7c030370f82da49ab2b98d1">col</a>) const</td></tr>
<tr class="separator:ga49aa7ec764cdad87e4336c4f62598c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5052a702af185623894c97c65d41b94c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga5052a702af185623894c97c65d41b94c">Dune::OverlappingSchwarzInitializer&lt; I, S, D &gt;::createMatrix</a> () const</td></tr>
<tr class="separator:ga5052a702af185623894c97c65d41b94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a680e2548b56a7dadc9f0269fd2bb7b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga6a680e2548b56a7dadc9f0269fd2bb7b">Dune::OverlappingSchwarzInitializer&lt; I, S, D &gt;::IndexMap::IndexMap</a> ()</td></tr>
<tr class="separator:ga6a680e2548b56a7dadc9f0269fd2bb7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac38c2a9d650c270b58a6572b8d54292f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#gac38c2a9d650c270b58a6572b8d54292f">Dune::OverlappingSchwarzInitializer&lt; I, S, D &gt;::IndexMap::insert</a> (<a class="el" href="a01123.html#aa3519152398319a8c8db877d565bdd01">size_type</a> grow)</td></tr>
<tr class="separator:gac38c2a9d650c270b58a6572b8d54292f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f7b78dea6bde8fd42a9f33519dbe8e5"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga7f7b78dea6bde8fd42a9f33519dbe8e5">Dune::OverlappingSchwarzInitializer&lt; I, S, D &gt;::IndexMap::find</a> (<a class="el" href="a01123.html#aa3519152398319a8c8db877d565bdd01">size_type</a> grow) const</td></tr>
<tr class="separator:ga7f7b78dea6bde8fd42a9f33519dbe8e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4914e60d4ae3251d332a27b367b16280"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga4914e60d4ae3251d332a27b367b16280">Dune::OverlappingSchwarzInitializer&lt; I, S, D &gt;::IndexMap::find</a> (<a class="el" href="a01123.html#aa3519152398319a8c8db877d565bdd01">size_type</a> grow)</td></tr>
<tr class="separator:ga4914e60d4ae3251d332a27b367b16280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2553a87370e6225f413fb43a609b13de"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga2553a87370e6225f413fb43a609b13de">Dune::OverlappingSchwarzInitializer&lt; I, S, D &gt;::IndexMap::end</a> () const</td></tr>
<tr class="separator:ga2553a87370e6225f413fb43a609b13de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32f49a7bed697ba20cdad682abf7831b"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga32f49a7bed697ba20cdad682abf7831b">Dune::OverlappingSchwarzInitializer&lt; I, S, D &gt;::IndexMap::end</a> ()</td></tr>
<tr class="separator:ga32f49a7bed697ba20cdad682abf7831b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4709e82416cc84c95bacc7f50fbf0426"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga4709e82416cc84c95bacc7f50fbf0426">Dune::OverlappingSchwarzInitializer&lt; I, S, D &gt;::IndexMap::begin</a> () const</td></tr>
<tr class="separator:ga4709e82416cc84c95bacc7f50fbf0426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga609c6c8a5bb36b65278f3107963f67a5"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga609c6c8a5bb36b65278f3107963f67a5">Dune::OverlappingSchwarzInitializer&lt; I, S, D &gt;::IndexMap::begin</a> ()</td></tr>
<tr class="separator:ga609c6c8a5bb36b65278f3107963f67a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae92d3496d89061727cbb287f66353cb5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#gae92d3496d89061727cbb287f66353cb5">Dune::SeqOverlappingSchwarz&lt; M, X, TM, TD, TA &gt;::SeqOverlappingSchwarz</a> (const <a class="el" href="a01403.html#a2c1e4ea9fee09a79b7aaf1b2b3c4d0d2">matrix_type</a> &amp;mat, const <a class="el" href="a01403.html#aa679bfde903b5a193f50e31837d22956">rowtodomain_vector</a> &amp;rowToDomain, <a class="el" href="a01403.html#a00ba249b6b77136bb153c46347b389b9">field_type</a> relaxationFactor=1, bool onTheFly_=true)</td></tr>
<tr class="separator:gae92d3496d89061727cbb287f66353cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b6f1eb9ad0a1080f762446c800ee2ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga8b6f1eb9ad0a1080f762446c800ee2ef">Dune::SeqOverlappingSchwarz&lt; M, X, TM, TD, TA &gt;::SeqOverlappingSchwarz</a> (const <a class="el" href="a01403.html#a2c1e4ea9fee09a79b7aaf1b2b3c4d0d2">matrix_type</a> &amp;mat, const <a class="el" href="a01403.html#a94ed586f1f44590f316c357fbc7f7fdd">subdomain_vector</a> &amp;subDomains, <a class="el" href="a01403.html#a00ba249b6b77136bb153c46347b389b9">field_type</a> relaxationFactor=1, bool onTheFly_=true)</td></tr>
<tr class="memdesc:ga8b6f1eb9ad0a1080f762446c800ee2ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the overlapping Schwarz method.  <a href="a00245.html#ga8b6f1eb9ad0a1080f762446c800ee2ef">More...</a><br /></td></tr>
<tr class="separator:ga8b6f1eb9ad0a1080f762446c800ee2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f5c5f46969aca8a8cfb6953bcf9d230"><td class="memTemplParams" colspan="2">template&lt;class RowToDomain , class Solvers , class SubDomains &gt; </td></tr>
<tr class="memitem:ga1f5c5f46969aca8a8cfb6953bcf9d230"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00245.html#ga1f5c5f46969aca8a8cfb6953bcf9d230">Dune::SeqOverlappingSchwarzAssemblerHelper&lt; DynamicMatrixSubdomainSolver&lt; BCRSMatrix&lt; K, Al &gt;, X, Y &gt;, false &gt;::assembleLocalProblems</a> ([[maybe_unused]] const RowToDomain &amp;rowToDomain, [[maybe_unused]] const <a class="el" href="a01927.html#a17c21dbe7634ee5f72e8f8b3a0323823">matrix_type</a> &amp;<a class="el" href="a00240.html#ga7051f2cf6a74fbd2d74ef52b1389cb0d">mat</a>, [[maybe_unused]] Solvers &amp;solvers, const SubDomains &amp;subDomains, [[maybe_unused]] bool onTheFly)</td></tr>
<tr class="separator:ga1f5c5f46969aca8a8cfb6953bcf9d230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2c38596fb38fbd904e356cea2bcd554"><td class="memTemplParams" colspan="2">template&lt;class RowToDomain , class Solvers , class SubDomains &gt; </td></tr>
<tr class="memitem:gad2c38596fb38fbd904e356cea2bcd554"><td class="memTemplItemLeft" align="right" valign="top">static std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00245.html#gad2c38596fb38fbd904e356cea2bcd554">Dune::SeqOverlappingSchwarzAssemblerHelper&lt; S&lt; BCRSMatrix&lt; T, A &gt; &gt;, true &gt;::assembleLocalProblems</a> (const RowToDomain &amp;rowToDomain, const <a class="el" href="a01931.html#a3a126ea72725fae253352af3f991e91b">matrix_type</a> &amp;<a class="el" href="a00240.html#ga7051f2cf6a74fbd2d74ef52b1389cb0d">mat</a>, Solvers &amp;solvers, const SubDomains &amp;domains, bool onTheFly)</td></tr>
<tr class="separator:gad2c38596fb38fbd904e356cea2bcd554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0aa914d086d8b0320f101b2f076ac991"><td class="memTemplParams" colspan="2">template&lt;class RowToDomain , class Solvers , class SubDomains &gt; </td></tr>
<tr class="memitem:ga0aa914d086d8b0320f101b2f076ac991"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00245.html#ga0aa914d086d8b0320f101b2f076ac991">Dune::SeqOverlappingSchwarzAssemblerILUBase&lt; M, X, Y &gt;::assembleLocalProblems</a> ([[maybe_unused]] const RowToDomain &amp;rowToDomain, const <a class="el" href="a01935.html#a5aee4c2388849de9ba7ef2f6afdc69f6">matrix_type</a> &amp;<a class="el" href="a00240.html#ga7051f2cf6a74fbd2d74ef52b1389cb0d">mat</a>, Solvers &amp;solvers, const SubDomains &amp;subDomains, bool onTheFly)</td></tr>
<tr class="separator:ga0aa914d086d8b0320f101b2f076ac991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7165b943ac63555d9be74469dd1bdf0c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga7165b943ac63555d9be74469dd1bdf0c">Dune::SeqOverlappingSchwarz&lt; M, X, TM, TD, TA &gt;::apply</a> (X &amp;v, const X &amp;d)</td></tr>
<tr class="memdesc:ga7165b943ac63555d9be74469dd1bdf0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the precondtioner.  <a href="a00245.html#ga7165b943ac63555d9be74469dd1bdf0c">More...</a><br /></td></tr>
<tr class="separator:ga7165b943ac63555d9be74469dd1bdf0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f9c740568e948c8bffcf8f420aeaba0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga3f9c740568e948c8bffcf8f420aeaba0">Dune::OverlappingAssignerHelper&lt; DynamicMatrixSubdomainSolver&lt; BCRSMatrix&lt; K, Al &gt;, X, Y &gt;, false &gt;::OverlappingAssignerHelper</a> (std::size_t maxlength, const <a class="el" href="a01155.html">BCRSMatrix</a>&lt; K, Al &gt; &amp;mat_, const X &amp;b_, Y &amp;x_)</td></tr>
<tr class="memdesc:ga3f9c740568e948c8bffcf8f420aeaba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="a00245.html#ga3f9c740568e948c8bffcf8f420aeaba0">More...</a><br /></td></tr>
<tr class="separator:ga3f9c740568e948c8bffcf8f420aeaba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae347c974f0314ed345e659004b62c26c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#gae347c974f0314ed345e659004b62c26c">Dune::OverlappingAssignerHelper&lt; DynamicMatrixSubdomainSolver&lt; BCRSMatrix&lt; K, Al &gt;, X, Y &gt;, false &gt;::deallocate</a> ()</td></tr>
<tr class="memdesc:gae347c974f0314ed345e659004b62c26c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates memory of the local vector.  <a href="a00245.html#gae347c974f0314ed345e659004b62c26c">More...</a><br /></td></tr>
<tr class="separator:gae347c974f0314ed345e659004b62c26c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1c22f222bb77ed8c9a47017c2fea395"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#gac1c22f222bb77ed8c9a47017c2fea395">Dune::OverlappingAssignerHelper&lt; DynamicMatrixSubdomainSolver&lt; BCRSMatrix&lt; K, Al &gt;, X, Y &gt;, false &gt;::resetIndexForNextDomain</a> ()</td></tr>
<tr class="memdesc:gac1c22f222bb77ed8c9a47017c2fea395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the local index to zero.  <a href="a00245.html#gac1c22f222bb77ed8c9a47017c2fea395">More...</a><br /></td></tr>
<tr class="separator:gac1c22f222bb77ed8c9a47017c2fea395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7ffec89b084a27a9601100f74347e96"><td class="memItemLeft" align="right" valign="top">DynamicVector&lt; <a class="el" href="a01859.html#acb0398fed98398821ac642854921519a">field_type</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#gaa7ffec89b084a27a9601100f74347e96">Dune::OverlappingAssignerHelper&lt; DynamicMatrixSubdomainSolver&lt; BCRSMatrix&lt; K, Al &gt;, X, Y &gt;, false &gt;::lhs</a> ()</td></tr>
<tr class="memdesc:gaa7ffec89b084a27a9601100f74347e96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local left hand side.  <a href="a00245.html#gaa7ffec89b084a27a9601100f74347e96">More...</a><br /></td></tr>
<tr class="separator:gaa7ffec89b084a27a9601100f74347e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5ddbe6322eb27047edf9a296065f229"><td class="memItemLeft" align="right" valign="top">DynamicVector&lt; <a class="el" href="a01859.html#acb0398fed98398821ac642854921519a">field_type</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#gaf5ddbe6322eb27047edf9a296065f229">Dune::OverlappingAssignerHelper&lt; DynamicMatrixSubdomainSolver&lt; BCRSMatrix&lt; K, Al &gt;, X, Y &gt;, false &gt;::rhs</a> ()</td></tr>
<tr class="memdesc:gaf5ddbe6322eb27047edf9a296065f229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local right hand side.  <a href="a00245.html#gaf5ddbe6322eb27047edf9a296065f229">More...</a><br /></td></tr>
<tr class="separator:gaf5ddbe6322eb27047edf9a296065f229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae316c5e7518e5bf9db8e65cfcaea7c42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#gae316c5e7518e5bf9db8e65cfcaea7c42">Dune::OverlappingAssignerHelper&lt; DynamicMatrixSubdomainSolver&lt; BCRSMatrix&lt; K, Al &gt;, X, Y &gt;, false &gt;::relaxResult</a> (<a class="el" href="a01859.html#acb0398fed98398821ac642854921519a">field_type</a> relax)</td></tr>
<tr class="memdesc:gae316c5e7518e5bf9db8e65cfcaea7c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">relax the result.  <a href="a00245.html#gae316c5e7518e5bf9db8e65cfcaea7c42">More...</a><br /></td></tr>
<tr class="separator:gae316c5e7518e5bf9db8e65cfcaea7c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bf365158cd6a9bb38fd6def4f70ce15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga4bf365158cd6a9bb38fd6def4f70ce15">Dune::OverlappingAssignerHelper&lt; DynamicMatrixSubdomainSolver&lt; BCRSMatrix&lt; K, Al &gt;, X, Y &gt;, false &gt;::operator()</a> (const <a class="el" href="a01859.html#a05c1b125ff116d09fddc896870efd83c">size_type</a> &amp;domainIndex)</td></tr>
<tr class="memdesc:ga4bf365158cd6a9bb38fd6def4f70ce15"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate one entry of the local defect.  <a href="a00245.html#ga4bf365158cd6a9bb38fd6def4f70ce15">More...</a><br /></td></tr>
<tr class="separator:ga4bf365158cd6a9bb38fd6def4f70ce15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac286d23d4d9cab29a16efbec63cb5322"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#gac286d23d4d9cab29a16efbec63cb5322">Dune::OverlappingAssignerHelper&lt; DynamicMatrixSubdomainSolver&lt; BCRSMatrix&lt; K, Al &gt;, X, Y &gt;, false &gt;::assignResult</a> (<a class="el" href="a01859.html#aff9ef8c872cf7ae25b558e9299e69241">block_type</a> &amp;res)</td></tr>
<tr class="memdesc:gac286d23d4d9cab29a16efbec63cb5322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the block to the current local index. At the same time the local defect is calculated for the index and stored in the rhs. Afterwards the is incremented for the next block.  <a href="a00245.html#gac286d23d4d9cab29a16efbec63cb5322">More...</a><br /></td></tr>
<tr class="separator:gac286d23d4d9cab29a16efbec63cb5322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1c644dc711b85eef93b84cd6c00836a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#gae1c644dc711b85eef93b84cd6c00836a">Dune::OverlappingAssignerHelper&lt; S&lt; BCRSMatrix&lt; T, A &gt; &gt;, true &gt;::OverlappingAssignerHelper</a> (std::size_t maxlength, const <a class="el" href="a01863.html#aee0e1da118b565b23c133e1b243348e1">matrix_type</a> &amp;mat, const <a class="el" href="a01863.html#a69863d94fec374c0732278912b8aebd9">range_type</a> &amp;b, <a class="el" href="a01863.html#a69863d94fec374c0732278912b8aebd9">range_type</a> &amp;x)</td></tr>
<tr class="memdesc:gae1c644dc711b85eef93b84cd6c00836a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="a00245.html#gae1c644dc711b85eef93b84cd6c00836a">More...</a><br /></td></tr>
<tr class="separator:gae1c644dc711b85eef93b84cd6c00836a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab38e2e3912b42816193fcf4d24aebb14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#gab38e2e3912b42816193fcf4d24aebb14">Dune::OverlappingAssignerHelper&lt; S&lt; BCRSMatrix&lt; T, A &gt; &gt;, true &gt;::deallocate</a> ()</td></tr>
<tr class="memdesc:gab38e2e3912b42816193fcf4d24aebb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates memory of the local vector.  <a href="a00245.html#gab38e2e3912b42816193fcf4d24aebb14">More...</a><br /></td></tr>
<tr class="separator:gab38e2e3912b42816193fcf4d24aebb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac83c3d93e203302a07e5534ef3a1eda3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#gac83c3d93e203302a07e5534ef3a1eda3">Dune::OverlappingAssignerHelper&lt; S&lt; BCRSMatrix&lt; T, A &gt; &gt;, true &gt;::operator()</a> (const <a class="el" href="a01863.html#ade16b85eb9a36660c947335d686ad12f">size_type</a> &amp;domain)</td></tr>
<tr class="memdesc:gac83c3d93e203302a07e5534ef3a1eda3"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate one entry of the local defect.  <a href="a00245.html#gac83c3d93e203302a07e5534ef3a1eda3">More...</a><br /></td></tr>
<tr class="separator:gac83c3d93e203302a07e5534ef3a1eda3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81a8b561789c3969f2196bac51508921"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga81a8b561789c3969f2196bac51508921">Dune::OverlappingAssignerHelper&lt; S&lt; BCRSMatrix&lt; T, A &gt; &gt;, true &gt;::relaxResult</a> (<a class="el" href="a01863.html#abd7c8bb5dd05106f2017f07c2172defb">field_type</a> relax)</td></tr>
<tr class="memdesc:ga81a8b561789c3969f2196bac51508921"><td class="mdescLeft">&#160;</td><td class="mdescRight">relax the result.  <a href="a00245.html#ga81a8b561789c3969f2196bac51508921">More...</a><br /></td></tr>
<tr class="separator:ga81a8b561789c3969f2196bac51508921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad02f2ece4d291c61f9c958dd4d5e1831"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#gad02f2ece4d291c61f9c958dd4d5e1831">Dune::OverlappingAssignerHelper&lt; S&lt; BCRSMatrix&lt; T, A &gt; &gt;, true &gt;::assignResult</a> (<a class="el" href="a01863.html#ab6e5fed631541c755dc02527f19d80cb">block_type</a> &amp;res)</td></tr>
<tr class="memdesc:gad02f2ece4d291c61f9c958dd4d5e1831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the block to the current local index. At the same time the local defect is calculated for the index and stored in the rhs. Afterwards the is incremented for the next block.  <a href="a00245.html#gad02f2ece4d291c61f9c958dd4d5e1831">More...</a><br /></td></tr>
<tr class="separator:gad02f2ece4d291c61f9c958dd4d5e1831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfde7e2456e273ce5e4c80381bfc203d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#gadfde7e2456e273ce5e4c80381bfc203d">Dune::OverlappingAssignerHelper&lt; S&lt; BCRSMatrix&lt; T, A &gt; &gt;, true &gt;::resetIndexForNextDomain</a> ()</td></tr>
<tr class="separator:gadfde7e2456e273ce5e4c80381bfc203d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fdf6d3c8d16e9ac866e353644c6c0ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01863.html#abd7c8bb5dd05106f2017f07c2172defb">field_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga5fdf6d3c8d16e9ac866e353644c6c0ec">Dune::OverlappingAssignerHelper&lt; S&lt; BCRSMatrix&lt; T, A &gt; &gt;, true &gt;::lhs</a> ()</td></tr>
<tr class="memdesc:ga5fdf6d3c8d16e9ac866e353644c6c0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local left hand side.  <a href="a00245.html#ga5fdf6d3c8d16e9ac866e353644c6c0ec">More...</a><br /></td></tr>
<tr class="separator:ga5fdf6d3c8d16e9ac866e353644c6c0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga725e9ce0b934a3040f41fcce53170f93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01863.html#abd7c8bb5dd05106f2017f07c2172defb">field_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga725e9ce0b934a3040f41fcce53170f93">Dune::OverlappingAssignerHelper&lt; S&lt; BCRSMatrix&lt; T, A &gt; &gt;, true &gt;::rhs</a> ()</td></tr>
<tr class="memdesc:ga725e9ce0b934a3040f41fcce53170f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local right hand side.  <a href="a00245.html#ga725e9ce0b934a3040f41fcce53170f93">More...</a><br /></td></tr>
<tr class="separator:ga725e9ce0b934a3040f41fcce53170f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a24b7bf122f654480690478c2cc80fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga7a24b7bf122f654480690478c2cc80fc">Dune::OverlappingAssignerILUBase&lt; M, X, Y &gt;::OverlappingAssignerILUBase</a> (std::size_t maxlength, const M &amp;mat, const Y &amp;b, X &amp;x)</td></tr>
<tr class="memdesc:ga7a24b7bf122f654480690478c2cc80fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="a00245.html#ga7a24b7bf122f654480690478c2cc80fc">More...</a><br /></td></tr>
<tr class="separator:ga7a24b7bf122f654480690478c2cc80fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a7c6fd66dd0d12e3db397ec4318ae6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga9a7c6fd66dd0d12e3db397ec4318ae6a">Dune::OverlappingAssignerILUBase&lt; M, X, Y &gt;::deallocate</a> ()</td></tr>
<tr class="memdesc:ga9a7c6fd66dd0d12e3db397ec4318ae6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates memory of the local vector.  <a href="a00245.html#ga9a7c6fd66dd0d12e3db397ec4318ae6a">More...</a><br /></td></tr>
<tr class="separator:ga9a7c6fd66dd0d12e3db397ec4318ae6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85a5a216087e03197a0b64f7484bccb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga85a5a216087e03197a0b64f7484bccb5">Dune::OverlappingAssignerILUBase&lt; M, X, Y &gt;::operator()</a> (const <a class="el" href="a01867.html#a2481bf0db19cb556ec7388eb171d2056">size_type</a> &amp;domain)</td></tr>
<tr class="memdesc:ga85a5a216087e03197a0b64f7484bccb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate one entry of the local defect.  <a href="a00245.html#ga85a5a216087e03197a0b64f7484bccb5">More...</a><br /></td></tr>
<tr class="separator:ga85a5a216087e03197a0b64f7484bccb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad711654fd4e5f5e86f68e99795664119"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#gad711654fd4e5f5e86f68e99795664119">Dune::OverlappingAssignerILUBase&lt; M, X, Y &gt;::relaxResult</a> (<a class="el" href="a01867.html#a3b7d16afd6729f746c05d0c9de270898">field_type</a> relax)</td></tr>
<tr class="memdesc:gad711654fd4e5f5e86f68e99795664119"><td class="mdescLeft">&#160;</td><td class="mdescRight">relax the result.  <a href="a00245.html#gad711654fd4e5f5e86f68e99795664119">More...</a><br /></td></tr>
<tr class="separator:gad711654fd4e5f5e86f68e99795664119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae600a61fbac4cd4fc97c2dc2e0eb17f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#gae600a61fbac4cd4fc97c2dc2e0eb17f1">Dune::OverlappingAssignerILUBase&lt; M, X, Y &gt;::assignResult</a> (<a class="el" href="a01867.html#a6f90e2c8bdeb34e45da12c03ce4c78c4">block_type</a> &amp;res)</td></tr>
<tr class="memdesc:gae600a61fbac4cd4fc97c2dc2e0eb17f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the block to the current local index. At the same time the local defect is calculated for the index and stored in the rhs. Afterwards the is incremented for the next block.  <a href="a00245.html#gae600a61fbac4cd4fc97c2dc2e0eb17f1">More...</a><br /></td></tr>
<tr class="separator:gae600a61fbac4cd4fc97c2dc2e0eb17f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f21fa6a8c50e4281aac39aa06ed442c"><td class="memItemLeft" align="right" valign="top">X &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga0f21fa6a8c50e4281aac39aa06ed442c">Dune::OverlappingAssignerILUBase&lt; M, X, Y &gt;::lhs</a> ()</td></tr>
<tr class="memdesc:ga0f21fa6a8c50e4281aac39aa06ed442c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local left hand side.  <a href="a00245.html#ga0f21fa6a8c50e4281aac39aa06ed442c">More...</a><br /></td></tr>
<tr class="separator:ga0f21fa6a8c50e4281aac39aa06ed442c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga242dba5b5b746420469c028df5833224"><td class="memItemLeft" align="right" valign="top">Y &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga242dba5b5b746420469c028df5833224">Dune::OverlappingAssignerILUBase&lt; M, X, Y &gt;::rhs</a> ()</td></tr>
<tr class="memdesc:ga242dba5b5b746420469c028df5833224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local right hand side.  <a href="a00245.html#ga242dba5b5b746420469c028df5833224">More...</a><br /></td></tr>
<tr class="separator:ga242dba5b5b746420469c028df5833224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4236f7c9f4d06105d1f2f2f4ded2ea95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga4236f7c9f4d06105d1f2f2f4ded2ea95">Dune::OverlappingAssignerILUBase&lt; M, X, Y &gt;::resetIndexForNextDomain</a> ()</td></tr>
<tr class="memdesc:ga4236f7c9f4d06105d1f2f2f4ded2ea95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the local index to zero.  <a href="a00245.html#ga4236f7c9f4d06105d1f2f2f4ded2ea95">More...</a><br /></td></tr>
<tr class="separator:ga4236f7c9f4d06105d1f2f2f4ded2ea95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4426d91edd8cc9b0b3334067843955ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga4426d91edd8cc9b0b3334067843955ab">Dune::AdditiveAdder&lt; S, BlockVector&lt; T, A &gt; &gt;::AdditiveAdder</a> (<a class="el" href="a01239.html">BlockVector</a>&lt; T, A &gt; &amp;v, <a class="el" href="a01239.html">BlockVector</a>&lt; T, A &gt; &amp;x, <a class="el" href="a00245.html#ga57430ed63b8d6900976df9950af0a0bb">OverlappingAssigner</a>&lt; S &gt; &amp;assigner, const <a class="el" href="a01883.html#a06eb0b7aec34e55bdffa3a89ca4c2736">field_type</a> &amp;relax_)</td></tr>
<tr class="separator:ga4426d91edd8cc9b0b3334067843955ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76542a5eff5f5f0fd32c73b17ba2eaf1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga76542a5eff5f5f0fd32c73b17ba2eaf1">Dune::AdditiveAdder&lt; S, BlockVector&lt; T, A &gt; &gt;::operator()</a> (const <a class="el" href="a01883.html#ab2a79d712eb561d5a5faa8aba1535076">size_type</a> &amp;domain)</td></tr>
<tr class="separator:ga76542a5eff5f5f0fd32c73b17ba2eaf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b4e23858765034998eae99df253ce73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga9b4e23858765034998eae99df253ce73">Dune::AdditiveAdder&lt; S, BlockVector&lt; T, A &gt; &gt;::axpy</a> ()</td></tr>
<tr class="separator:ga9b4e23858765034998eae99df253ce73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga168a62b5b202ef08f67cb016096571d5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga168a62b5b202ef08f67cb016096571d5">Dune::MultiplicativeAdder&lt; S, BlockVector&lt; T, A &gt; &gt;::MultiplicativeAdder</a> (<a class="el" href="a01239.html">BlockVector</a>&lt; T, A &gt; &amp;v, <a class="el" href="a01239.html">BlockVector</a>&lt; T, A &gt; &amp;x, <a class="el" href="a00245.html#ga57430ed63b8d6900976df9950af0a0bb">OverlappingAssigner</a>&lt; S &gt; &amp;assigner_, const <a class="el" href="a01891.html#a9e8cae7cc3223077b125254efb329516">field_type</a> &amp;relax_)</td></tr>
<tr class="separator:ga168a62b5b202ef08f67cb016096571d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga385efdb7af8bcdcd9afe46e6297d82fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#ga385efdb7af8bcdcd9afe46e6297d82fa">Dune::MultiplicativeAdder&lt; S, BlockVector&lt; T, A &gt; &gt;::operator()</a> (const <a class="el" href="a01891.html#aae47cc62c59890b49ad57451d54795af">size_type</a> &amp;domain)</td></tr>
<tr class="separator:ga385efdb7af8bcdcd9afe46e6297d82fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacf07a33120284d3626dc8853373235f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html#gaacf07a33120284d3626dc8853373235f">Dune::MultiplicativeAdder&lt; S, BlockVector&lt; T, A &gt; &gt;::axpy</a> ()</td></tr>
<tr class="separator:gaacf07a33120284d3626dc8853373235f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>All of our <a class="el" href="a00237.html">Krylow solvers</a> are preconditioned versions. There are sequential preconditioners (e,g. SeqJacobi, <a class="el" href="a02595.html" title="Sequential SOR preconditioner.">SeqSOR</a>, <a class="el" href="a02591.html" title="Sequential SSOR preconditioner.">SeqSSOR</a>) as well as parallel preconditioners (e.g. AMG, <a class="el" href="a02671.html" title="Block parallel preconditioner.">BlockPreconditioner</a>) available for plugging them into the solvers together with matching ScalarProducts.</p>
<p>Some of the available preconditioners (e.g. SeqJacobi, <a class="el" href="a02595.html" title="Sequential SOR preconditioner.">SeqSOR</a>, <a class="el" href="a02591.html" title="Sequential SSOR preconditioner.">SeqSSOR</a>)) may be given an aditional int as a template parameter, the block recursion level. These preconditioners can be used on block-recursive matrices with an arbitrary hierarchy depth (eg. <a class="el" href="a01155.html" title="A sparse block matrix with compressed row storage.">BCRSMatrix</a>&lt;BCRSMatrix&lt;FieldMatrix,n,m&gt; &gt; &gt;. Given a block recursion level <img class="formulaInl" alt="$k$" src="form_44.png"/> those preconditioners work as normal on the offdiagonal blocks, treating them as traditional matrix entries. For the diagonal values a special procedure applies: If <img class="formulaInl" alt="$k&gt;1$" src="form_45.png"/> the diagonal is treated as a matrix itself and the preconditioner is applied recursively on the matrix representing the diagonal value <img class="formulaInl" alt="$D=A_{ii}$" src="form_46.png"/> with block level <img class="formulaInl" alt="$k-1$" src="form_47.png"/>. For the case that <img class="formulaInl" alt="$k=1$" src="form_48.png"/> the diagonal is treated as a matrix entry resulting in a linear solve or an identity operation depending on the algorithm. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga57430ed63b8d6900976df9950af0a0bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57430ed63b8d6900976df9950af0a0bb">&#9670;&nbsp;</a></span>OverlappingAssigner</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00245.html#ga57430ed63b8d6900976df9950af0a0bb">Dune::OverlappingAssigner</a> = typedef <a class="el" href="a01855.html">OverlappingAssignerHelper</a>&lt;T, <a class="el" href="a02779.html">Dune::StoresColumnCompressed</a>&lt;T&gt;::value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaf04e8521e43d7b1c8fdb3a412210b36d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf04e8521e43d7b1c8fdb3a412210b36d">&#9670;&nbsp;</a></span>SeqGS</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , class X , class Y , int l = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00245.html#gaf04e8521e43d7b1c8fdb3a412210b36d">Dune::SeqGS</a> = typedef <a class="el" href="a02595.html">SeqSOR</a>&lt;M,X,Y,l&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sequential Gauss Seidel preconditioner. </p>
<p>Wraps the naked <a class="el" href="a00254.html">ISTL</a> generic block Gauss-Seidel preconditioner into the solver framework.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The matrix type to operate on </td></tr>
    <tr><td class="paramname">X</td><td>Type of the update </td></tr>
    <tr><td class="paramname">Y</td><td>Type of the defect </td></tr>
    <tr><td class="paramname">l</td><td>The block level to invert. Default is 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5a5d6fa4ec6f65757b49ed7fe09e15e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a5d6fa4ec6f65757b49ed7fe09e15e2">&#9670;&nbsp;</a></span>SeqOverlappingSchwarzAssembler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00245.html#ga5a5d6fa4ec6f65757b49ed7fe09e15e2">Dune::SeqOverlappingSchwarzAssembler</a> = typedef <a class="el" href="a01407.html">SeqOverlappingSchwarzAssemblerHelper</a>&lt;T,<a class="el" href="a02779.html">Dune::StoresColumnCompressed</a>&lt;T&gt;::value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga4426d91edd8cc9b0b3334067843955ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4426d91edd8cc9b0b3334067843955ab">&#9670;&nbsp;</a></span>AdditiveAdder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01879.html">Dune::AdditiveAdder</a>&lt; S, <a class="el" href="a01239.html">BlockVector</a>&lt; T, A &gt; &gt;::<a class="el" href="a01879.html">AdditiveAdder</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01239.html">BlockVector</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01239.html">BlockVector</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00245.html#ga57430ed63b8d6900976df9950af0a0bb">OverlappingAssigner</a>&lt; S &gt; &amp;&#160;</td>
          <td class="paramname"><em>assigner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01883.html#a06eb0b7aec34e55bdffa3a89ca4c2736">field_type</a> &amp;&#160;</td>
          <td class="paramname"><em>relax_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga01ce789c3fd3870dee0f0df52eac92c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01ce789c3fd3870dee0f0df52eac92c5">&#9670;&nbsp;</a></span>addRowNnz()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I , class S , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01123.html">Dune::OverlappingSchwarzInitializer</a>&lt; I, S, D &gt;::addRowNnz </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01123.html#a7262d3824fe191c948ed60e1156eb872">Iter</a> &amp;&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga995ede9ec46c2990a1f249b4096a827a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga995ede9ec46c2990a1f249b4096a827a">&#9670;&nbsp;</a></span>allocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I , class S , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01123.html">Dune::OverlappingSchwarzInitializer</a>&lt; I, S, D &gt;::allocate</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga7165b943ac63555d9be74469dd1bdf0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7165b943ac63555d9be74469dd1bdf0c">&#9670;&nbsp;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , class X , class TM , class TD , class TA &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01403.html">Dune::SeqOverlappingSchwarz</a>&lt; M, X, TM, TD, TA &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the precondtioner. </p>
<p>Apply one step of the preconditioner to the system A(v)=d. On entry v=0 and d=b-A(x) (although this might not be computed in that way. On exit v contains the update, i.e one step computes <img class="formulaInl" alt="$ v = M^{-1} d $" src="form_41.png"/> where <img class="formulaInl" alt="$ M $" src="form_42.png"/> is the approximate inverse of the operator <img class="formulaInl" alt="$ A $" src="form_43.png"/> characterizing the preconditioner. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>The update to be computed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">d</td><td>The current defect. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="a02583.html#a05b45208eec670e82b65bbc8e2601af0">Dune::Preconditioner&lt; X, X &gt;</a>.</p>

</div>
</div>
<a id="ga1f5c5f46969aca8a8cfb6953bcf9d230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f5c5f46969aca8a8cfb6953bcf9d230">&#9670;&nbsp;</a></span>assembleLocalProblems() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class Al , class X , class Y &gt; </div>
<div class="memtemplate">
template&lt;class RowToDomain , class Solvers , class SubDomains &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="a01407.html">Dune::SeqOverlappingSchwarzAssemblerHelper</a>&lt; <a class="el" href="a01847.html">DynamicMatrixSubdomainSolver</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>&lt; K, Al &gt;, X, Y &gt;, false &gt;::assembleLocalProblems </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] const RowToDomain &amp;&#160;</td>
          <td class="paramname"><em>rowToDomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] const <a class="el" href="a01927.html#a17c21dbe7634ee5f72e8f8b3a0323823">matrix_type</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] Solvers &amp;&#160;</td>
          <td class="paramname"><em>solvers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SubDomains &amp;&#160;</td>
          <td class="paramname"><em>subDomains</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] bool&#160;</td>
          <td class="paramname"><em>onTheFly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga0aa914d086d8b0320f101b2f076ac991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0aa914d086d8b0320f101b2f076ac991">&#9670;&nbsp;</a></span>assembleLocalProblems() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , class X , class Y &gt; </div>
<div class="memtemplate">
template&lt;class RowToDomain , class Solvers , class SubDomains &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="a01935.html">Dune::SeqOverlappingSchwarzAssemblerILUBase</a>&lt; M, X, Y &gt;::assembleLocalProblems </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] const RowToDomain &amp;&#160;</td>
          <td class="paramname"><em>rowToDomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01935.html#a5aee4c2388849de9ba7ef2f6afdc69f6">matrix_type</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Solvers &amp;&#160;</td>
          <td class="paramname"><em>solvers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SubDomains &amp;&#160;</td>
          <td class="paramname"><em>subDomains</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onTheFly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gad2c38596fb38fbd904e356cea2bcd554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2c38596fb38fbd904e356cea2bcd554">&#9670;&nbsp;</a></span>assembleLocalProblems() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; class S, typename T , typename A &gt; </div>
<div class="memtemplate">
template&lt;class RowToDomain , class Solvers , class SubDomains &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="a01407.html">Dune::SeqOverlappingSchwarzAssemblerHelper</a>&lt; S&lt; <a class="el" href="a01155.html">BCRSMatrix</a>&lt; T, A &gt; &gt;, true &gt;::assembleLocalProblems </td>
          <td>(</td>
          <td class="paramtype">const RowToDomain &amp;&#160;</td>
          <td class="paramname"><em>rowToDomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01931.html#a3a126ea72725fae253352af3f991e91b">matrix_type</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Solvers &amp;&#160;</td>
          <td class="paramname"><em>solvers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SubDomains &amp;&#160;</td>
          <td class="paramname"><em>domains</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onTheFly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gac286d23d4d9cab29a16efbec63cb5322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac286d23d4d9cab29a16efbec63cb5322">&#9670;&nbsp;</a></span>assignResult() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class Al , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01855.html">Dune::OverlappingAssignerHelper</a>&lt; <a class="el" href="a01847.html">DynamicMatrixSubdomainSolver</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>&lt; K, Al &gt;, X, Y &gt;, false &gt;::assignResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01859.html#aff9ef8c872cf7ae25b558e9299e69241">block_type</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the block to the current local index. At the same time the local defect is calculated for the index and stored in the rhs. Afterwards the is incremented for the next block. </p>

</div>
</div>
<a id="gad02f2ece4d291c61f9c958dd4d5e1831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad02f2ece4d291c61f9c958dd4d5e1831">&#9670;&nbsp;</a></span>assignResult() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; class S, typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01855.html">Dune::OverlappingAssignerHelper</a>&lt; S&lt; <a class="el" href="a01155.html">BCRSMatrix</a>&lt; T, A &gt; &gt;, true &gt;::assignResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01863.html#ab6e5fed631541c755dc02527f19d80cb">block_type</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns the block to the current local index. At the same time the local defect is calculated for the index and stored in the rhs. Afterwards the is incremented for the next block. </p>

</div>
</div>
<a id="gae600a61fbac4cd4fc97c2dc2e0eb17f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae600a61fbac4cd4fc97c2dc2e0eb17f1">&#9670;&nbsp;</a></span>assignResult() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01867.html">Dune::OverlappingAssignerILUBase</a>&lt; M, X, Y &gt;::assignResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01867.html#a6f90e2c8bdeb34e45da12c03ce4c78c4">block_type</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns the block to the current local index. At the same time the local defect is calculated for the index and stored in the rhs. Afterwards the is incremented for the next block. </p>

</div>
</div>
<a id="ga9b4e23858765034998eae99df253ce73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b4e23858765034998eae99df253ce73">&#9670;&nbsp;</a></span>axpy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01879.html">Dune::AdditiveAdder</a>&lt; S, <a class="el" href="a01239.html">BlockVector</a>&lt; T, A &gt; &gt;::axpy</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaacf07a33120284d3626dc8853373235f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacf07a33120284d3626dc8853373235f">&#9670;&nbsp;</a></span>axpy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01887.html">Dune::MultiplicativeAdder</a>&lt; S, <a class="el" href="a01239.html">BlockVector</a>&lt; T, A &gt; &gt;::axpy</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga609c6c8a5bb36b65278f3107963f67a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga609c6c8a5bb36b65278f3107963f67a5">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I , class S , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01123.html">OverlappingSchwarzInitializer</a>&lt; I, S, D &gt;::IndexMap::iterator <a class="el" href="a01123.html">Dune::OverlappingSchwarzInitializer</a>&lt; I, S, D &gt;::IndexMap::begin</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga4709e82416cc84c95bacc7f50fbf0426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4709e82416cc84c95bacc7f50fbf0426">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I , class S , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01123.html">OverlappingSchwarzInitializer</a>&lt; I, S, D &gt;::IndexMap::const_iterator <a class="el" href="a01123.html">Dune::OverlappingSchwarzInitializer</a>&lt; I, S, D &gt;::IndexMap::begin</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga0fa860d4fc5e8db80cd39b1c377d407f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fa860d4fc5e8db80cd39b1c377d407f">&#9670;&nbsp;</a></span>calcColstart()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I , class S , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01123.html">Dune::OverlappingSchwarzInitializer</a>&lt; I, S, D &gt;::calcColstart</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga49aa7ec764cdad87e4336c4f62598c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49aa7ec764cdad87e4336c4f62598c76">&#9670;&nbsp;</a></span>copyValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I , class S , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01123.html">Dune::OverlappingSchwarzInitializer</a>&lt; I, S, D &gt;::copyValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01123.html#a7262d3824fe191c948ed60e1156eb872">Iter</a> &amp;&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01123.html#a1992e4a416cb68438b2c51122f4af880">CIter</a> &amp;&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gac5ed84777f6e2f1181aae4198ab75e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5ed84777f6e2f1181aae4198ab75e12">&#9670;&nbsp;</a></span>countEntries()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I , class S , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01123.html">Dune::OverlappingSchwarzInitializer</a>&lt; I, S, D &gt;::countEntries </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01123.html#a7262d3824fe191c948ed60e1156eb872">Iter</a> &amp;&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01123.html#a1992e4a416cb68438b2c51122f4af880">CIter</a> &amp;&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga5052a702af185623894c97c65d41b94c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5052a702af185623894c97c65d41b94c">&#9670;&nbsp;</a></span>createMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I , class S , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01123.html">Dune::OverlappingSchwarzInitializer</a>&lt; I, S, D &gt;::createMatrix</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gae347c974f0314ed345e659004b62c26c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae347c974f0314ed345e659004b62c26c">&#9670;&nbsp;</a></span>deallocate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class Al , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01855.html">Dune::OverlappingAssignerHelper</a>&lt; <a class="el" href="a01847.html">DynamicMatrixSubdomainSolver</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>&lt; K, Al &gt;, X, Y &gt;, false &gt;::deallocate</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocates memory of the local vector. </p>

</div>
</div>
<a id="gab38e2e3912b42816193fcf4d24aebb14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab38e2e3912b42816193fcf4d24aebb14">&#9670;&nbsp;</a></span>deallocate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; class S, typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01855.html">Dune::OverlappingAssignerHelper</a>&lt; S&lt; <a class="el" href="a01155.html">BCRSMatrix</a>&lt; T, A &gt; &gt;, true &gt;::deallocate</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocates memory of the local vector. </p>
<dl class="section warning"><dt>Warning</dt><dd>memory is released by the destructor as this Functor is copied and the copy needs to still have the data. </dd></dl>

</div>
</div>
<a id="ga9a7c6fd66dd0d12e3db397ec4318ae6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a7c6fd66dd0d12e3db397ec4318ae6a">&#9670;&nbsp;</a></span>deallocate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01867.html">Dune::OverlappingAssignerILUBase</a>&lt; M, X, Y &gt;::deallocate</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocates memory of the local vector. </p>
<dl class="section warning"><dt>Warning</dt><dd>memory is released by the destructor as this Functor is copied and the copy needs to still have the data. </dd></dl>

</div>
</div>
<a id="ga08abf358156090136c1433291819a194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08abf358156090136c1433291819a194">&#9670;&nbsp;</a></span>DUNE_REGISTER_PRECONDITIONER() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_REGISTER_PRECONDITIONER </td>
          <td>(</td>
          <td class="paramtype">&quot;gs&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00250.html#ga335dd7b0d29e9493a7f193c9f07767bf">defaultPreconditionerBlockLevelCreator</a>&lt; <a class="el" href="a00245.html#gaf04e8521e43d7b1c8fdb3a412210b36d">Dune::SeqGS</a> &gt;&#160;</td>
          <td class="paramname">()&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gada61707dc136db5a195bef80037d5246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada61707dc136db5a195bef80037d5246">&#9670;&nbsp;</a></span>DUNE_REGISTER_PRECONDITIONER() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_REGISTER_PRECONDITIONER </td>
          <td>(</td>
          <td class="paramtype">&quot;ildl&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00250.html#gaaf82ab9baa6ac2e24bb927e953ffb4fb">defaultPreconditionerCreator</a>&lt; <a class="el" href="a02611.html">Dune::SeqILDL</a> &gt;&#160;</td>
          <td class="paramname">()&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gabdfc9bd7597c826fa723af53d0cb0e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdfc9bd7597c826fa723af53d0cb0e2d">&#9670;&nbsp;</a></span>DUNE_REGISTER_PRECONDITIONER() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_REGISTER_PRECONDITIONER </td>
          <td>(</td>
          <td class="paramtype">&quot;ilu&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00250.html#ga335dd7b0d29e9493a7f193c9f07767bf">defaultPreconditionerBlockLevelCreator</a>&lt; <a class="el" href="a02603.html">Dune::SeqILU</a> &gt;&#160;</td>
          <td class="paramname">()&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga8e0768493ba56650387ef7f1171d2620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e0768493ba56650387ef7f1171d2620">&#9670;&nbsp;</a></span>DUNE_REGISTER_PRECONDITIONER() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_REGISTER_PRECONDITIONER </td>
          <td>(</td>
          <td class="paramtype">&quot;jac&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00250.html#ga335dd7b0d29e9493a7f193c9f07767bf">defaultPreconditionerBlockLevelCreator</a>&lt; <a class="el" href="a02599.html">Dune::SeqJac</a> &gt;&#160;</td>
          <td class="paramname">()&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga6c0383c6a267d2dd7bdf0425463c95dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c0383c6a267d2dd7bdf0425463c95dc">&#9670;&nbsp;</a></span>DUNE_REGISTER_PRECONDITIONER() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_REGISTER_PRECONDITIONER </td>
          <td>(</td>
          <td class="paramtype">&quot;richardson&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[] (auto tl, const auto &amp;, const ParameterTree &amp;config){ using D=typename Dune::TypeListElement&lt; 1, decltype(tl)&gt;::type;using R=typename Dune::TypeListElement&lt; 2, decltype(tl)&gt;::type;return std::make_shared&lt; <a class="el" href="a02607.html">Richardson</a>&lt; D, R &gt;&gt;(config);}&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga84e1da868870a635c00649be4e1d101b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84e1da868870a635c00649be4e1d101b">&#9670;&nbsp;</a></span>DUNE_REGISTER_PRECONDITIONER() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_REGISTER_PRECONDITIONER </td>
          <td>(</td>
          <td class="paramtype">&quot;sor&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00250.html#ga335dd7b0d29e9493a7f193c9f07767bf">defaultPreconditionerBlockLevelCreator</a>&lt; <a class="el" href="a02595.html">Dune::SeqSOR</a> &gt;&#160;</td>
          <td class="paramname">()&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga31161bee90db194d09f233f00ab4de9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31161bee90db194d09f233f00ab4de9c">&#9670;&nbsp;</a></span>DUNE_REGISTER_PRECONDITIONER() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_REGISTER_PRECONDITIONER </td>
          <td>(</td>
          <td class="paramtype">&quot;ssor&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00250.html#ga335dd7b0d29e9493a7f193c9f07767bf">defaultPreconditionerBlockLevelCreator</a>&lt; <a class="el" href="a02591.html">Dune::SeqSSOR</a> &gt;&#160;</td>
          <td class="paramname">()&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga32f49a7bed697ba20cdad682abf7831b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32f49a7bed697ba20cdad682abf7831b">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I , class S , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01123.html">OverlappingSchwarzInitializer</a>&lt; I, S, D &gt;::IndexMap::iterator <a class="el" href="a01123.html">Dune::OverlappingSchwarzInitializer</a>&lt; I, S, D &gt;::IndexMap::end</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga2553a87370e6225f413fb43a609b13de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2553a87370e6225f413fb43a609b13de">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I , class S , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01123.html">OverlappingSchwarzInitializer</a>&lt; I, S, D &gt;::IndexMap::const_iterator <a class="el" href="a01123.html">Dune::OverlappingSchwarzInitializer</a>&lt; I, S, D &gt;::IndexMap::end</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga4914e60d4ae3251d332a27b367b16280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4914e60d4ae3251d332a27b367b16280">&#9670;&nbsp;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I , class S , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01123.html">OverlappingSchwarzInitializer</a>&lt; I, S, D &gt;::IndexMap::iterator <a class="el" href="a01123.html">Dune::OverlappingSchwarzInitializer</a>&lt; I, S, D &gt;::IndexMap::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01123.html#aa3519152398319a8c8db877d565bdd01">size_type</a>&#160;</td>
          <td class="paramname"><em>grow</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga7f7b78dea6bde8fd42a9f33519dbe8e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f7b78dea6bde8fd42a9f33519dbe8e5">&#9670;&nbsp;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I , class S , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01123.html">OverlappingSchwarzInitializer</a>&lt; I, S, D &gt;::IndexMap::const_iterator <a class="el" href="a01123.html">Dune::OverlappingSchwarzInitializer</a>&lt; I, S, D &gt;::IndexMap::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01123.html#aa3519152398319a8c8db877d565bdd01">size_type</a>&#160;</td>
          <td class="paramname"><em>grow</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga6a680e2548b56a7dadc9f0269fd2bb7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a680e2548b56a7dadc9f0269fd2bb7b">&#9670;&nbsp;</a></span>IndexMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I , class S , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01123.html">Dune::OverlappingSchwarzInitializer</a>&lt; I, S, D &gt;::IndexMap::IndexMap</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gac38c2a9d650c270b58a6572b8d54292f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac38c2a9d650c270b58a6572b8d54292f">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I , class S , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01123.html">Dune::OverlappingSchwarzInitializer</a>&lt; I, S, D &gt;::IndexMap::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01123.html#aa3519152398319a8c8db877d565bdd01">size_type</a>&#160;</td>
          <td class="paramname"><em>grow</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaa7ffec89b084a27a9601100f74347e96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7ffec89b084a27a9601100f74347e96">&#9670;&nbsp;</a></span>lhs() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class Al , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DynamicVector&lt; typename X::field_type &gt; &amp; <a class="el" href="a01855.html">Dune::OverlappingAssignerHelper</a>&lt; <a class="el" href="a01847.html">DynamicMatrixSubdomainSolver</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>&lt; K, Al &gt;, X, Y &gt;, false &gt;::lhs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the local left hand side. </p>
<dl class="section return"><dt>Returns</dt><dd>The local left hand side. </dd></dl>

</div>
</div>
<a id="ga5fdf6d3c8d16e9ac866e353644c6c0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fdf6d3c8d16e9ac866e353644c6c0ec">&#9670;&nbsp;</a></span>lhs() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; class S, typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01855.html">OverlappingAssignerHelper</a>&lt; S&lt; <a class="el" href="a01155.html">BCRSMatrix</a>&lt; T, A &gt; &gt;, true &gt;::<a class="el" href="a01863.html#abd7c8bb5dd05106f2017f07c2172defb">field_type</a> * <a class="el" href="a01855.html">Dune::OverlappingAssignerHelper</a>&lt; S&lt; <a class="el" href="a01155.html">BCRSMatrix</a>&lt; T, A &gt; &gt;, true &gt;::lhs</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the local left hand side. </p>
<dl class="section return"><dt>Returns</dt><dd>The local left hand side. </dd></dl>

</div>
</div>
<a id="ga0f21fa6a8c50e4281aac39aa06ed442c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f21fa6a8c50e4281aac39aa06ed442c">&#9670;&nbsp;</a></span>lhs() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">X &amp; <a class="el" href="a01867.html">Dune::OverlappingAssignerILUBase</a>&lt; M, X, Y &gt;::lhs</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the local left hand side. </p>
<dl class="section return"><dt>Returns</dt><dd>The local left hand side. </dd></dl>

</div>
</div>
<a id="ga168a62b5b202ef08f67cb016096571d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga168a62b5b202ef08f67cb016096571d5">&#9670;&nbsp;</a></span>MultiplicativeAdder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01887.html">Dune::MultiplicativeAdder</a>&lt; S, <a class="el" href="a01239.html">BlockVector</a>&lt; T, A &gt; &gt;::<a class="el" href="a01887.html">MultiplicativeAdder</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01239.html">BlockVector</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01239.html">BlockVector</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00245.html#ga57430ed63b8d6900976df9950af0a0bb">OverlappingAssigner</a>&lt; S &gt; &amp;&#160;</td>
          <td class="paramname"><em>assigner_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01891.html#a9e8cae7cc3223077b125254efb329516">field_type</a> &amp;&#160;</td>
          <td class="paramname"><em>relax_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gac83c3d93e203302a07e5534ef3a1eda3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac83c3d93e203302a07e5534ef3a1eda3">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; class S, typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01855.html">Dune::OverlappingAssignerHelper</a>&lt; S&lt; <a class="el" href="a01155.html">BCRSMatrix</a>&lt; T, A &gt; &gt;, true &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01863.html#ade16b85eb9a36660c947335d686ad12f">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>domain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate one entry of the local defect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>One index of the domain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga85a5a216087e03197a0b64f7484bccb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85a5a216087e03197a0b64f7484bccb5">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01867.html">Dune::OverlappingAssignerILUBase</a>&lt; M, X, Y &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01867.html#a2481bf0db19cb556ec7388eb171d2056">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>domain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate one entry of the local defect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>One index of the domain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga76542a5eff5f5f0fd32c73b17ba2eaf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76542a5eff5f5f0fd32c73b17ba2eaf1">&#9670;&nbsp;</a></span>operator()() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01879.html">Dune::AdditiveAdder</a>&lt; S, <a class="el" href="a01239.html">BlockVector</a>&lt; T, A &gt; &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01883.html#ab2a79d712eb561d5a5faa8aba1535076">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>domain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga385efdb7af8bcdcd9afe46e6297d82fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga385efdb7af8bcdcd9afe46e6297d82fa">&#9670;&nbsp;</a></span>operator()() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01887.html">Dune::MultiplicativeAdder</a>&lt; S, <a class="el" href="a01239.html">BlockVector</a>&lt; T, A &gt; &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01891.html#aae47cc62c59890b49ad57451d54795af">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>domain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga4bf365158cd6a9bb38fd6def4f70ce15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bf365158cd6a9bb38fd6def4f70ce15">&#9670;&nbsp;</a></span>operator()() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class Al , class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01855.html">Dune::OverlappingAssignerHelper</a>&lt; <a class="el" href="a01847.html">DynamicMatrixSubdomainSolver</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>&lt; K, Al &gt;, X, Y &gt;, false &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01859.html#a05c1b125ff116d09fddc896870efd83c">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>domainIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate one entry of the local defect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domainIndex</td><td>One index of the domain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3f9c740568e948c8bffcf8f420aeaba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f9c740568e948c8bffcf8f420aeaba0">&#9670;&nbsp;</a></span>OverlappingAssignerHelper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class Al , class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01855.html">Dune::OverlappingAssignerHelper</a>&lt; <a class="el" href="a01847.html">DynamicMatrixSubdomainSolver</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>&lt; K, Al &gt;, X, Y &gt;, false &gt;::<a class="el" href="a01855.html">OverlappingAssignerHelper</a> </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>maxlength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01155.html">BCRSMatrix</a>&lt; K, Al &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X &amp;&#160;</td>
          <td class="paramname"><em>b_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>x_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxlength</td><td>The maximum entries over all subdomains. </td></tr>
    <tr><td class="paramname">mat_</td><td>The global matrix. </td></tr>
    <tr><td class="paramname">b_</td><td>the global right hand side. </td></tr>
    <tr><td class="paramname">x_</td><td>the global left hand side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae1c644dc711b85eef93b84cd6c00836a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1c644dc711b85eef93b84cd6c00836a">&#9670;&nbsp;</a></span>OverlappingAssignerHelper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; class S, typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01855.html">Dune::OverlappingAssignerHelper</a>&lt; S&lt; <a class="el" href="a01155.html">BCRSMatrix</a>&lt; T, A &gt; &gt;, true &gt;::<a class="el" href="a01855.html">OverlappingAssignerHelper</a> </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>maxlength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01863.html#aee0e1da118b565b23c133e1b243348e1">matrix_type</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01863.html#a69863d94fec374c0732278912b8aebd9">range_type</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01863.html#a69863d94fec374c0732278912b8aebd9">range_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxlength</td><td>The maximum entries over all subdomains. </td></tr>
    <tr><td class="paramname">mat</td><td>The global matrix. </td></tr>
    <tr><td class="paramname">b</td><td>the global right hand side. </td></tr>
    <tr><td class="paramname">x</td><td>the global left hand side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7a24b7bf122f654480690478c2cc80fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a24b7bf122f654480690478c2cc80fc">&#9670;&nbsp;</a></span>OverlappingAssignerILUBase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01867.html">Dune::OverlappingAssignerILUBase</a>&lt; M, X, Y &gt;::<a class="el" href="a01867.html">OverlappingAssignerILUBase</a> </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>maxlength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Y &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxlength</td><td>The maximum entries over all subdomains. </td></tr>
    <tr><td class="paramname">mat</td><td>The global matrix. </td></tr>
    <tr><td class="paramname">b</td><td>the global right hand side. </td></tr>
    <tr><td class="paramname">x</td><td>the global left hand side. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga680ecf80821212aaa8149d72eea3010e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga680ecf80821212aaa8149d72eea3010e">&#9670;&nbsp;</a></span>OverlappingSchwarzInitializer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I , class S , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01123.html">Dune::OverlappingSchwarzInitializer</a>&lt; I, S, D &gt;::<a class="el" href="a01123.html">OverlappingSchwarzInitializer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01123.html#abec4859ff0228c9b8af3095b41cb8b0a">InitializerList</a> &amp;&#160;</td>
          <td class="paramname"><em>il</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01123.html#a4720a7ee7e9cb7069df83bcb38bcbcee">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01123.html#ae876d38e035d6edaae28a4ff0ffd59ac">subdomain_vector</a> &amp;&#160;</td>
          <td class="paramname"><em>domains</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gae316c5e7518e5bf9db8e65cfcaea7c42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae316c5e7518e5bf9db8e65cfcaea7c42">&#9670;&nbsp;</a></span>relaxResult() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class Al , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01855.html">Dune::OverlappingAssignerHelper</a>&lt; <a class="el" href="a01847.html">DynamicMatrixSubdomainSolver</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>&lt; K, Al &gt;, X, Y &gt;, false &gt;::relaxResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01859.html#acb0398fed98398821ac642854921519a">field_type</a>&#160;</td>
          <td class="paramname"><em>relax</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>relax the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">relax</td><td>The relaxation parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga81a8b561789c3969f2196bac51508921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81a8b561789c3969f2196bac51508921">&#9670;&nbsp;</a></span>relaxResult() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; class S, typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01855.html">Dune::OverlappingAssignerHelper</a>&lt; S&lt; <a class="el" href="a01155.html">BCRSMatrix</a>&lt; T, A &gt; &gt;, true &gt;::relaxResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01863.html#abd7c8bb5dd05106f2017f07c2172defb">field_type</a>&#160;</td>
          <td class="paramname"><em>relax</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>relax the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">relax</td><td>The relaxation parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad711654fd4e5f5e86f68e99795664119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad711654fd4e5f5e86f68e99795664119">&#9670;&nbsp;</a></span>relaxResult() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01867.html">Dune::OverlappingAssignerILUBase</a>&lt; M, X, Y &gt;::relaxResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01867.html#a3b7d16afd6729f746c05d0c9de270898">field_type</a>&#160;</td>
          <td class="paramname"><em>relax</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>relax the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">relax</td><td>The relaxation parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac1c22f222bb77ed8c9a47017c2fea395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1c22f222bb77ed8c9a47017c2fea395">&#9670;&nbsp;</a></span>resetIndexForNextDomain() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class Al , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01855.html">Dune::OverlappingAssignerHelper</a>&lt; <a class="el" href="a01847.html">DynamicMatrixSubdomainSolver</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>&lt; K, Al &gt;, X, Y &gt;, false &gt;::resetIndexForNextDomain</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the local index to zero. </p>

</div>
</div>
<a id="gadfde7e2456e273ce5e4c80381bfc203d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfde7e2456e273ce5e4c80381bfc203d">&#9670;&nbsp;</a></span>resetIndexForNextDomain() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; class S, typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01855.html">Dune::OverlappingAssignerHelper</a>&lt; S&lt; <a class="el" href="a01155.html">BCRSMatrix</a>&lt; T, A &gt; &gt;, true &gt;::resetIndexForNextDomain</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga4236f7c9f4d06105d1f2f2f4ded2ea95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4236f7c9f4d06105d1f2f2f4ded2ea95">&#9670;&nbsp;</a></span>resetIndexForNextDomain() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01867.html">Dune::OverlappingAssignerILUBase</a>&lt; M, X, Y &gt;::resetIndexForNextDomain</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the local index to zero. </p>

</div>
</div>
<a id="gaf5ddbe6322eb27047edf9a296065f229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5ddbe6322eb27047edf9a296065f229">&#9670;&nbsp;</a></span>rhs() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class Al , class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DynamicVector&lt; typename X::field_type &gt; &amp; <a class="el" href="a01855.html">Dune::OverlappingAssignerHelper</a>&lt; <a class="el" href="a01847.html">DynamicMatrixSubdomainSolver</a>&lt; <a class="el" href="a01155.html">BCRSMatrix</a>&lt; K, Al &gt;, X, Y &gt;, false &gt;::rhs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the local right hand side. </p>
<dl class="section return"><dt>Returns</dt><dd>The local right hand side. </dd></dl>

</div>
</div>
<a id="ga725e9ce0b934a3040f41fcce53170f93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga725e9ce0b934a3040f41fcce53170f93">&#9670;&nbsp;</a></span>rhs() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; class S, typename T , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01855.html">OverlappingAssignerHelper</a>&lt; S&lt; <a class="el" href="a01155.html">BCRSMatrix</a>&lt; T, A &gt; &gt;, true &gt;::<a class="el" href="a01863.html#abd7c8bb5dd05106f2017f07c2172defb">field_type</a> * <a class="el" href="a01855.html">Dune::OverlappingAssignerHelper</a>&lt; S&lt; <a class="el" href="a01155.html">BCRSMatrix</a>&lt; T, A &gt; &gt;, true &gt;::rhs</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the local right hand side. </p>
<dl class="section return"><dt>Returns</dt><dd>The local right hand side. </dd></dl>

</div>
</div>
<a id="ga242dba5b5b746420469c028df5833224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga242dba5b5b746420469c028df5833224">&#9670;&nbsp;</a></span>rhs() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Y &amp; <a class="el" href="a01867.html">Dune::OverlappingAssignerILUBase</a>&lt; M, X, Y &gt;::rhs</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the local right hand side. </p>
<dl class="section return"><dt>Returns</dt><dd>The local right hand side. </dd></dl>

</div>
</div>
<a id="gae92d3496d89061727cbb287f66353cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae92d3496d89061727cbb287f66353cb5">&#9670;&nbsp;</a></span>SeqOverlappingSchwarz() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , class X , class TM , class TD , class TA &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01403.html">Dune::SeqOverlappingSchwarz</a>&lt; M, X, TM, TD, TA &gt;::<a class="el" href="a01403.html">SeqOverlappingSchwarz</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01403.html#a2c1e4ea9fee09a79b7aaf1b2b3c4d0d2">matrix_type</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01403.html#aa679bfde903b5a193f50e31837d22956">rowtodomain_vector</a> &amp;&#160;</td>
          <td class="paramname"><em>rowToDomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01403.html#a00ba249b6b77136bb153c46347b389b9">field_type</a>&#160;</td>
          <td class="paramname"><em>relaxationFactor</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onTheFly_</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct the overlapping Schwarz method </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix to precondition. </td></tr>
    <tr><td class="paramname">rowToDomain</td><td>The mapping of the rows onto the domains. </td></tr>
    <tr><td class="paramname">relaxationFactor</td><td>relaxation factor </td></tr>
    <tr><td class="paramname">onTheFly_</td><td>If true the decomposition of the exact local solvers is computed on the fly for each subdomain and iteration step. If false all decompositions are computed in pre and only forward and backward substitution takes place in the iteration steps. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8b6f1eb9ad0a1080f762446c800ee2ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b6f1eb9ad0a1080f762446c800ee2ef">&#9670;&nbsp;</a></span>SeqOverlappingSchwarz() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , class X , class TM , class TD , class TA &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01403.html">Dune::SeqOverlappingSchwarz</a>&lt; M, X, TM, TD, TA &gt;::<a class="el" href="a01403.html">SeqOverlappingSchwarz</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01403.html#a2c1e4ea9fee09a79b7aaf1b2b3c4d0d2">matrix_type</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01403.html#a94ed586f1f44590f316c357fbc7f7fdd">subdomain_vector</a> &amp;&#160;</td>
          <td class="paramname"><em>subDomains</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01403.html#a00ba249b6b77136bb153c46347b389b9">field_type</a>&#160;</td>
          <td class="paramname"><em>relaxationFactor</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onTheFly_</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the overlapping Schwarz method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix to precondition. </td></tr>
    <tr><td class="paramname">subDomains</td><td>Array of sets of rowindices belonging to an overlapping subdomain </td></tr>
    <tr><td class="paramname">relaxationFactor</td><td>relaxation factor </td></tr>
    <tr><td class="paramname">onTheFly_</td><td>If true the decomposition of the exact local solvers is computed on the fly for each subdomain and iteration step. If false all decompositions are computed in pre and only forward and backward substitution takes place in the iteration steps. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Each rowindex should be part of at least one subdomain! </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
