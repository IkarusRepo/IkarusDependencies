<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>dune-common: Dune::DynamicVector&lt; K, Allocator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">dune-common
   &#160;<span id="projectnumber">2.7.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00428.html">Dune</a></li><li class="navelem"><a class="el" href="a01528.html">DynamicVector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="a01525.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Dune::DynamicVector&lt; K, Allocator &gt; Class Template Reference<div class="ingroups"><a class="el" href="a00400.html">Common</a> &raquo; <a class="el" href="a00414.html">Dense Matrix and Vector Template Library</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Construct a vector with a dynamic size.  
 <a href="a01528.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00077_source.html">dune/common/dynvector.hh</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Dune::DynamicVector&lt; K, Allocator &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="a01527.png" border="0" usemap="#a_dune_1_1_dynamic_vector_3_01_k_00_01_allocator_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="a_dune_1_1_dynamic_vector_3_01_k_00_01_allocator_01_4_inherit__map" id="a_dune_1_1_dynamic_vector_3_01_k_00_01_allocator_01_4_inherit__map">
<area shape="rect" title="Construct a vector with a dynamic size." alt="" coords="15,215,164,256"/>
<area shape="rect" href="a01440.html" title=" " alt="" coords="8,109,171,165"/>
<area shape="rect" href="a01440.html" title="Interface for a class of dense vectors over a given field." alt="" coords="5,5,173,32"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a50a7d3fa728a4b82b4407b134e347190"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a01440.html#a67b4a65a6199d863602f152045f5a5dd">Base::size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01528.html#a50a7d3fa728a4b82b4407b134e347190">size_type</a></td></tr>
<tr class="separator:a50a7d3fa728a4b82b4407b134e347190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a735233c2a1599812e8cd3e6f4676dd48"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a01440.html#a007463aa44631abffe62eb8c868ae95d">Base::value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01528.html#a735233c2a1599812e8cd3e6f4676dd48">value_type</a></td></tr>
<tr class="separator:a735233c2a1599812e8cd3e6f4676dd48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7bd4fc26554e6189ecc927bd1bfb4b"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; K, Allocator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01528.html#a5a7bd4fc26554e6189ecc927bd1bfb4b">container_type</a></td></tr>
<tr class="separator:a5a7bd4fc26554e6189ecc927bd1bfb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7565d55f987adf7629660bdc919d3aff"><td class="memItemLeft" align="right" valign="top">typedef Allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01528.html#a7565d55f987adf7629660bdc919d3aff">allocator_type</a></td></tr>
<tr class="separator:a7565d55f987adf7629660bdc919d3aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53558845f4efcb6623cbddca97c2970"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="memdesc:ac53558845f4efcb6623cbddca97c2970"><td class="mdescLeft">&#160;</td><td class="mdescRight">We are at the leaf of the block recursion.  <a href="a01440.html#ac53558845f4efcb6623cbddca97c2970">More...</a><br /></td></tr>
<tr class="separator:ac53558845f4efcb6623cbddca97c2970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e9bf293f856d54796593981ea52c17"><td class="memItemLeft" align="right" valign="top">typedef Traits::derived_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#a34e9bf293f856d54796593981ea52c17">derived_type</a></td></tr>
<tr class="memdesc:a34e9bf293f856d54796593981ea52c17"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of derived vector class  <a href="a01440.html#a34e9bf293f856d54796593981ea52c17">More...</a><br /></td></tr>
<tr class="separator:a34e9bf293f856d54796593981ea52c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40059aac27a618d775bce116b4f3746"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a01748.html">FieldTraits</a>&lt; <a class="el" href="a01528.html#a735233c2a1599812e8cd3e6f4676dd48">value_type</a> &gt;::<a class="el" href="a01440.html#ab40059aac27a618d775bce116b4f3746">field_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#ab40059aac27a618d775bce116b4f3746">field_type</a></td></tr>
<tr class="memdesc:ab40059aac27a618d775bce116b4f3746"><td class="mdescLeft">&#160;</td><td class="mdescRight">export the type representing the field  <a href="a01440.html#ab40059aac27a618d775bce116b4f3746">More...</a><br /></td></tr>
<tr class="separator:ab40059aac27a618d775bce116b4f3746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e72791f5c4cffc273a43f63a3072d8"><td class="memItemLeft" align="right" valign="top">typedef Traits::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#ab5e72791f5c4cffc273a43f63a3072d8">block_type</a></td></tr>
<tr class="memdesc:ab5e72791f5c4cffc273a43f63a3072d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">export the type representing the components  <a href="a01440.html#ab5e72791f5c4cffc273a43f63a3072d8">More...</a><br /></td></tr>
<tr class="separator:ab5e72791f5c4cffc273a43f63a3072d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c98d3c53e08f0db8cce3b1e88b45c1a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a01456.html">DenseIterator</a>&lt; <a class="el" href="a01440.html">DenseVector</a>, <a class="el" href="a01528.html#a735233c2a1599812e8cd3e6f4676dd48">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#a6c98d3c53e08f0db8cce3b1e88b45c1a">Iterator</a></td></tr>
<tr class="memdesc:a6c98d3c53e08f0db8cce3b1e88b45c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator class for sequential access.  <a href="a01440.html#a6c98d3c53e08f0db8cce3b1e88b45c1a">More...</a><br /></td></tr>
<tr class="separator:a6c98d3c53e08f0db8cce3b1e88b45c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d32efa59ca198acd89776fff71d4ef3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a01440.html#a6c98d3c53e08f0db8cce3b1e88b45c1a">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#a0d32efa59ca198acd89776fff71d4ef3">iterator</a></td></tr>
<tr class="memdesc:a0d32efa59ca198acd89776fff71d4ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">typedef for stl compliant access  <a href="a01440.html#a0d32efa59ca198acd89776fff71d4ef3">More...</a><br /></td></tr>
<tr class="separator:a0d32efa59ca198acd89776fff71d4ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a284929d58f3df6c66e2a7ad629a7f4f2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a01456.html">DenseIterator</a>&lt; const <a class="el" href="a01440.html">DenseVector</a>, const <a class="el" href="a01528.html#a735233c2a1599812e8cd3e6f4676dd48">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#a284929d58f3df6c66e2a7ad629a7f4f2">ConstIterator</a></td></tr>
<tr class="memdesc:a284929d58f3df6c66e2a7ad629a7f4f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">ConstIterator class for sequential access.  <a href="a01440.html#a284929d58f3df6c66e2a7ad629a7f4f2">More...</a><br /></td></tr>
<tr class="separator:a284929d58f3df6c66e2a7ad629a7f4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e293015cdccffda5df1fe06070a130"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a01440.html#a284929d58f3df6c66e2a7ad629a7f4f2">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#a08e293015cdccffda5df1fe06070a130">const_iterator</a></td></tr>
<tr class="memdesc:a08e293015cdccffda5df1fe06070a130"><td class="mdescLeft">&#160;</td><td class="mdescRight">typedef for stl compliant access  <a href="a01440.html#a08e293015cdccffda5df1fe06070a130">More...</a><br /></td></tr>
<tr class="separator:a08e293015cdccffda5df1fe06070a130"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7ab6b30514c24d5afa6eaf1d12349692"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01528.html#a7ab6b30514c24d5afa6eaf1d12349692">DynamicVector</a> (const <a class="el" href="a01528.html#a7565d55f987adf7629660bdc919d3aff">allocator_type</a> &amp;a=<a class="el" href="a01528.html#a7565d55f987adf7629660bdc919d3aff">allocator_type</a>())</td></tr>
<tr class="memdesc:a7ab6b30514c24d5afa6eaf1d12349692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor making uninitialized vector.  <a href="a01528.html#a7ab6b30514c24d5afa6eaf1d12349692">More...</a><br /></td></tr>
<tr class="separator:a7ab6b30514c24d5afa6eaf1d12349692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdca3f644f1b4151eb8e8f39656b239c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01528.html#abdca3f644f1b4151eb8e8f39656b239c">DynamicVector</a> (<a class="el" href="a01528.html#a50a7d3fa728a4b82b4407b134e347190">size_type</a> n, const <a class="el" href="a01528.html#a7565d55f987adf7629660bdc919d3aff">allocator_type</a> &amp;a=<a class="el" href="a01528.html#a7565d55f987adf7629660bdc919d3aff">allocator_type</a>())</td></tr>
<tr class="separator:abdca3f644f1b4151eb8e8f39656b239c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae821be352676f391e19ffa70d9ca3714"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01528.html#ae821be352676f391e19ffa70d9ca3714">DynamicVector</a> (<a class="el" href="a01528.html#a50a7d3fa728a4b82b4407b134e347190">size_type</a> n, <a class="el" href="a01528.html#a735233c2a1599812e8cd3e6f4676dd48">value_type</a> c, const <a class="el" href="a01528.html#a7565d55f987adf7629660bdc919d3aff">allocator_type</a> &amp;a=<a class="el" href="a01528.html#a7565d55f987adf7629660bdc919d3aff">allocator_type</a>())</td></tr>
<tr class="memdesc:ae821be352676f391e19ffa70d9ca3714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor making vector with identical coordinates.  <a href="a01528.html#ae821be352676f391e19ffa70d9ca3714">More...</a><br /></td></tr>
<tr class="separator:ae821be352676f391e19ffa70d9ca3714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac816734949044d1f94a33060fcb1da39"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01528.html#ac816734949044d1f94a33060fcb1da39">DynamicVector</a> (std::initializer_list&lt; K &gt; const &amp;l)</td></tr>
<tr class="memdesc:ac816734949044d1f94a33060fcb1da39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a std::initializer_list.  <a href="a01528.html#ac816734949044d1f94a33060fcb1da39">More...</a><br /></td></tr>
<tr class="separator:ac816734949044d1f94a33060fcb1da39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc74b2715a2e47302d769df2992201b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01528.html#a2dc74b2715a2e47302d769df2992201b">DynamicVector</a> (const <a class="el" href="a01528.html">DynamicVector</a> &amp;x)</td></tr>
<tr class="memdesc:a2dc74b2715a2e47302d769df2992201b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor making vector with identical coordinates.  <a href="a01528.html#a2dc74b2715a2e47302d769df2992201b">More...</a><br /></td></tr>
<tr class="separator:a2dc74b2715a2e47302d769df2992201b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e82f8787ae085c459dca22b0ed12d26"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01528.html#a7e82f8787ae085c459dca22b0ed12d26">DynamicVector</a> (<a class="el" href="a01528.html">DynamicVector</a> &amp;&amp;x)</td></tr>
<tr class="memdesc:a7e82f8787ae085c459dca22b0ed12d26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="a01528.html#a7e82f8787ae085c459dca22b0ed12d26">More...</a><br /></td></tr>
<tr class="separator:a7e82f8787ae085c459dca22b0ed12d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3719da9dabab00e1de6921c553983a1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad3719da9dabab00e1de6921c553983a1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01528.html#ad3719da9dabab00e1de6921c553983a1">DynamicVector</a> (const <a class="el" href="a01528.html">DynamicVector</a>&lt; T, Allocator &gt; &amp;x)</td></tr>
<tr class="separator:ad3719da9dabab00e1de6921c553983a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7d86873cf92f60efa2b17d11298f05"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:aec7d86873cf92f60efa2b17d11298f05"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01528.html#aec7d86873cf92f60efa2b17d11298f05">DynamicVector</a> (const <a class="el" href="a01440.html">DenseVector</a>&lt; X &gt; &amp;x, const <a class="el" href="a01528.html#a7565d55f987adf7629660bdc919d3aff">allocator_type</a> &amp;a=<a class="el" href="a01528.html#a7565d55f987adf7629660bdc919d3aff">allocator_type</a>())</td></tr>
<tr class="memdesc:aec7d86873cf92f60efa2b17d11298f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor from another <a class="el" href="a01440.html" title="Interface for a class of dense vectors over a given field.">DenseVector</a>.  <a href="a01528.html#aec7d86873cf92f60efa2b17d11298f05">More...</a><br /></td></tr>
<tr class="separator:aec7d86873cf92f60efa2b17d11298f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f3befde174fd8fec8a4e9d1d57dd62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01528.html">DynamicVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01528.html#a61f3befde174fd8fec8a4e9d1d57dd62">operator=</a> (const <a class="el" href="a01528.html">DynamicVector</a> &amp;other)</td></tr>
<tr class="memdesc:a61f3befde174fd8fec8a4e9d1d57dd62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="a01528.html#a61f3befde174fd8fec8a4e9d1d57dd62">More...</a><br /></td></tr>
<tr class="separator:a61f3befde174fd8fec8a4e9d1d57dd62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4d5d1d002528026ab748e22b3d0558"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01528.html">DynamicVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01528.html#a1e4d5d1d002528026ab748e22b3d0558">operator=</a> (<a class="el" href="a01528.html">DynamicVector</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a1e4d5d1d002528026ab748e22b3d0558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="a01528.html#a1e4d5d1d002528026ab748e22b3d0558">More...</a><br /></td></tr>
<tr class="separator:a1e4d5d1d002528026ab748e22b3d0558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa28080f12c895ae6cf7f11f26bb6f729"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01528.html#a50a7d3fa728a4b82b4407b134e347190">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01528.html#aa28080f12c895ae6cf7f11f26bb6f729">capacity</a> () const</td></tr>
<tr class="memdesc:aa28080f12c895ae6cf7f11f26bb6f729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements for which memory has been allocated.  <a href="a01528.html#aa28080f12c895ae6cf7f11f26bb6f729">More...</a><br /></td></tr>
<tr class="separator:aa28080f12c895ae6cf7f11f26bb6f729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc5235fd9a477eb17112e4826753b48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01528.html#a1dc5235fd9a477eb17112e4826753b48">resize</a> (<a class="el" href="a01528.html#a50a7d3fa728a4b82b4407b134e347190">size_type</a> n, <a class="el" href="a01528.html#a735233c2a1599812e8cd3e6f4676dd48">value_type</a> c=<a class="el" href="a01528.html#a735233c2a1599812e8cd3e6f4676dd48">value_type</a>())</td></tr>
<tr class="separator:a1dc5235fd9a477eb17112e4826753b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5bfe6f530c32091c3dddca5f360b33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01528.html#adc5bfe6f530c32091c3dddca5f360b33">reserve</a> (<a class="el" href="a01528.html#a50a7d3fa728a4b82b4407b134e347190">size_type</a> n)</td></tr>
<tr class="separator:adc5bfe6f530c32091c3dddca5f360b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61cc6ffa5d43445b061035c97d58e38e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01528.html#a50a7d3fa728a4b82b4407b134e347190">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01528.html#a61cc6ffa5d43445b061035c97d58e38e">size</a> () const</td></tr>
<tr class="separator:a61cc6ffa5d43445b061035c97d58e38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea329d38527ac5c9c79c76f45faeb6fd"><td class="memItemLeft" align="right" valign="top">K &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01528.html#aea329d38527ac5c9c79c76f45faeb6fd">operator[]</a> (<a class="el" href="a01528.html#a50a7d3fa728a4b82b4407b134e347190">size_type</a> i)</td></tr>
<tr class="separator:aea329d38527ac5c9c79c76f45faeb6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ec8c05e1b7ad8ca9b67a76882926a4"><td class="memItemLeft" align="right" valign="top">const K &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01528.html#af5ec8c05e1b7ad8ca9b67a76882926a4">operator[]</a> (<a class="el" href="a01528.html#a50a7d3fa728a4b82b4407b134e347190">size_type</a> i) const</td></tr>
<tr class="separator:af5ec8c05e1b7ad8ca9b67a76882926a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61466250acc18c3b87b216310831f6e1"><td class="memItemLeft" align="right" valign="top">K *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01528.html#a61466250acc18c3b87b216310831f6e1">data</a> () noexcept</td></tr>
<tr class="memdesc:a61466250acc18c3b87b216310831f6e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">return pointer to underlying array  <a href="a01528.html#a61466250acc18c3b87b216310831f6e1">More...</a><br /></td></tr>
<tr class="separator:a61466250acc18c3b87b216310831f6e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf84bf7cd074630d98a443f5771a217d"><td class="memItemLeft" align="right" valign="top">const K *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01528.html#adf84bf7cd074630d98a443f5771a217d">data</a> () const noexcept</td></tr>
<tr class="memdesc:adf84bf7cd074630d98a443f5771a217d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return pointer to underlying array  <a href="a01528.html#adf84bf7cd074630d98a443f5771a217d">More...</a><br /></td></tr>
<tr class="separator:adf84bf7cd074630d98a443f5771a217d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4b98fb48e820d4071162c1ec933bf6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a01528.html#a5a7bd4fc26554e6189ecc927bd1bfb4b">container_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01528.html#aef4b98fb48e820d4071162c1ec933bf6">container</a> () const</td></tr>
<tr class="separator:aef4b98fb48e820d4071162c1ec933bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad962bdabce70024ee5ccef0e4684eee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01528.html#a5a7bd4fc26554e6189ecc927bd1bfb4b">container_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01528.html#aad962bdabce70024ee5ccef0e4684eee">container</a> ()</td></tr>
<tr class="separator:aad962bdabce70024ee5ccef0e4684eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa684143b2a15b3739d782a8327d5993c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01440.html#a34e9bf293f856d54796593981ea52c17">derived_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01528.html#aa684143b2a15b3739d782a8327d5993c">operator=</a> (const <a class="el" href="a01528.html#a735233c2a1599812e8cd3e6f4676dd48">value_type</a> &amp;k)</td></tr>
<tr class="memdesc:aa684143b2a15b3739d782a8327d5993c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator for scalar.  <a href="a01528.html#aa684143b2a15b3739d782a8327d5993c">More...</a><br /></td></tr>
<tr class="separator:aa684143b2a15b3739d782a8327d5993c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f5fe5d8925f4d17c957bee69ba70f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01440.html">DenseVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01528.html#ac7f5fe5d8925f4d17c957bee69ba70f7">operator=</a> (const <a class="el" href="a01440.html">DenseVector</a> &amp;)=default</td></tr>
<tr class="memdesc:ac7f5fe5d8925f4d17c957bee69ba70f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator for other <a class="el" href="a01440.html" title="Interface for a class of dense vectors over a given field.">DenseVector</a> of same type.  <a href="a01528.html#ac7f5fe5d8925f4d17c957bee69ba70f7">More...</a><br /></td></tr>
<tr class="separator:ac7f5fe5d8925f4d17c957bee69ba70f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb82fe94311ab1fd83f60b8a3814f881"><td class="memTemplParams" colspan="2">template&lt;typename W , std::enable_if_t&lt; std::is_assignable&lt; value_type &amp;, typename DenseVector&lt; W &gt;::value_type &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aeb82fe94311ab1fd83f60b8a3814f881"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01440.html#a34e9bf293f856d54796593981ea52c17">derived_type</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01528.html#aeb82fe94311ab1fd83f60b8a3814f881">operator=</a> (const <a class="el" href="a01440.html">DenseVector</a>&lt; W &gt; &amp;other)</td></tr>
<tr class="memdesc:aeb82fe94311ab1fd83f60b8a3814f881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator for other <a class="el" href="a01440.html" title="Interface for a class of dense vectors over a given field.">DenseVector</a> of different type.  <a href="a01528.html#aeb82fe94311ab1fd83f60b8a3814f881">More...</a><br /></td></tr>
<tr class="separator:aeb82fe94311ab1fd83f60b8a3814f881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7eb3783fc33c122c1bbd49da49483c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01528.html#a735233c2a1599812e8cd3e6f4676dd48">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#aff7eb3783fc33c122c1bbd49da49483c">front</a> ()</td></tr>
<tr class="memdesc:aff7eb3783fc33c122c1bbd49da49483c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return reference to first element  <a href="a01440.html#aff7eb3783fc33c122c1bbd49da49483c">More...</a><br /></td></tr>
<tr class="separator:aff7eb3783fc33c122c1bbd49da49483c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4535132c8c9be58328d5589de76ce1d3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a01528.html#a735233c2a1599812e8cd3e6f4676dd48">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#a4535132c8c9be58328d5589de76ce1d3">front</a> () const</td></tr>
<tr class="memdesc:a4535132c8c9be58328d5589de76ce1d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">return reference to first element  <a href="a01440.html#a4535132c8c9be58328d5589de76ce1d3">More...</a><br /></td></tr>
<tr class="separator:a4535132c8c9be58328d5589de76ce1d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0802c4d1cc9af0e1da5590013baf4bf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01528.html#a735233c2a1599812e8cd3e6f4676dd48">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#a0802c4d1cc9af0e1da5590013baf4bf7">back</a> ()</td></tr>
<tr class="memdesc:a0802c4d1cc9af0e1da5590013baf4bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">return reference to last element  <a href="a01440.html#a0802c4d1cc9af0e1da5590013baf4bf7">More...</a><br /></td></tr>
<tr class="separator:a0802c4d1cc9af0e1da5590013baf4bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed9667b527c99a1eb172e13c3cffe37"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a01528.html#a735233c2a1599812e8cd3e6f4676dd48">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#a6ed9667b527c99a1eb172e13c3cffe37">back</a> () const</td></tr>
<tr class="memdesc:a6ed9667b527c99a1eb172e13c3cffe37"><td class="mdescLeft">&#160;</td><td class="mdescRight">return reference to last element  <a href="a01440.html#a6ed9667b527c99a1eb172e13c3cffe37">More...</a><br /></td></tr>
<tr class="separator:a6ed9667b527c99a1eb172e13c3cffe37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd39ba30f616bcf4158a1d8b3e4bf872"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#afd39ba30f616bcf4158a1d8b3e4bf872">empty</a> () const</td></tr>
<tr class="memdesc:afd39ba30f616bcf4158a1d8b3e4bf872"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks whether the container is empty  <a href="a01440.html#afd39ba30f616bcf4158a1d8b3e4bf872">More...</a><br /></td></tr>
<tr class="separator:afd39ba30f616bcf4158a1d8b3e4bf872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2154e1f6858db8dad26046187837bc0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01440.html#a6c98d3c53e08f0db8cce3b1e88b45c1a">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#a2154e1f6858db8dad26046187837bc0d">begin</a> ()</td></tr>
<tr class="memdesc:a2154e1f6858db8dad26046187837bc0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">begin iterator  <a href="a01440.html#a2154e1f6858db8dad26046187837bc0d">More...</a><br /></td></tr>
<tr class="separator:a2154e1f6858db8dad26046187837bc0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4806c2eaf07106ccc5bd6b7320c9ecf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01440.html#a284929d58f3df6c66e2a7ad629a7f4f2">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#aa4806c2eaf07106ccc5bd6b7320c9ecf">begin</a> () const</td></tr>
<tr class="memdesc:aa4806c2eaf07106ccc5bd6b7320c9ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">begin ConstIterator  <a href="a01440.html#aa4806c2eaf07106ccc5bd6b7320c9ecf">More...</a><br /></td></tr>
<tr class="separator:aa4806c2eaf07106ccc5bd6b7320c9ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5feee4aa0d88277f19169c7833cd9e9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01440.html#a6c98d3c53e08f0db8cce3b1e88b45c1a">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#a5feee4aa0d88277f19169c7833cd9e9f">end</a> ()</td></tr>
<tr class="memdesc:a5feee4aa0d88277f19169c7833cd9e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">end iterator  <a href="a01440.html#a5feee4aa0d88277f19169c7833cd9e9f">More...</a><br /></td></tr>
<tr class="separator:a5feee4aa0d88277f19169c7833cd9e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a195a839274c030e30ab03f7efabcc3aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01440.html#a284929d58f3df6c66e2a7ad629a7f4f2">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#a195a839274c030e30ab03f7efabcc3aa">end</a> () const</td></tr>
<tr class="memdesc:a195a839274c030e30ab03f7efabcc3aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">end ConstIterator  <a href="a01440.html#a195a839274c030e30ab03f7efabcc3aa">More...</a><br /></td></tr>
<tr class="separator:a195a839274c030e30ab03f7efabcc3aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8352d8d5b5d98f82b0620fdde870b3ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01440.html#a6c98d3c53e08f0db8cce3b1e88b45c1a">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#a8352d8d5b5d98f82b0620fdde870b3ad">beforeEnd</a> ()</td></tr>
<tr class="separator:a8352d8d5b5d98f82b0620fdde870b3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cabf0d4856865d667868784fa511f4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01440.html#a284929d58f3df6c66e2a7ad629a7f4f2">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#a4cabf0d4856865d667868784fa511f4a">beforeEnd</a> () const</td></tr>
<tr class="separator:a4cabf0d4856865d667868784fa511f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23408ea7b99536c94aa32907372cc52b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01440.html#a6c98d3c53e08f0db8cce3b1e88b45c1a">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#a23408ea7b99536c94aa32907372cc52b">beforeBegin</a> ()</td></tr>
<tr class="separator:a23408ea7b99536c94aa32907372cc52b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4723b4cce2f85f275a3d26d21aac6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01440.html#a284929d58f3df6c66e2a7ad629a7f4f2">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#a1f4723b4cce2f85f275a3d26d21aac6f">beforeBegin</a> () const</td></tr>
<tr class="separator:a1f4723b4cce2f85f275a3d26d21aac6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2264c91ca0dfbd9dda13814fc588e60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01440.html#a6c98d3c53e08f0db8cce3b1e88b45c1a">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#af2264c91ca0dfbd9dda13814fc588e60">find</a> (<a class="el" href="a01528.html#a50a7d3fa728a4b82b4407b134e347190">size_type</a> i)</td></tr>
<tr class="memdesc:af2264c91ca0dfbd9dda13814fc588e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">return iterator to given element or <a class="el" href="a01440.html#a5feee4aa0d88277f19169c7833cd9e9f" title="end iterator">end()</a>  <a href="a01440.html#af2264c91ca0dfbd9dda13814fc588e60">More...</a><br /></td></tr>
<tr class="separator:af2264c91ca0dfbd9dda13814fc588e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1903b7bf21abd5d7c60a33182f6bf31d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01440.html#a284929d58f3df6c66e2a7ad629a7f4f2">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#a1903b7bf21abd5d7c60a33182f6bf31d">find</a> (<a class="el" href="a01528.html#a50a7d3fa728a4b82b4407b134e347190">size_type</a> i) const</td></tr>
<tr class="memdesc:a1903b7bf21abd5d7c60a33182f6bf31d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return iterator to given element or <a class="el" href="a01440.html#a5feee4aa0d88277f19169c7833cd9e9f" title="end iterator">end()</a>  <a href="a01440.html#a1903b7bf21abd5d7c60a33182f6bf31d">More...</a><br /></td></tr>
<tr class="separator:a1903b7bf21abd5d7c60a33182f6bf31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f16164643ad187211390a317e0bdf1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01440.html#a34e9bf293f856d54796593981ea52c17">derived_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#a88f16164643ad187211390a317e0bdf1">operator+=</a> (const <a class="el" href="a01440.html">DenseVector</a>&lt; Other &gt; &amp;x)</td></tr>
<tr class="memdesc:a88f16164643ad187211390a317e0bdf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector space addition  <a href="a01440.html#a88f16164643ad187211390a317e0bdf1">More...</a><br /></td></tr>
<tr class="separator:a88f16164643ad187211390a317e0bdf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3237c1a6746c8a5a8cd3aae0b4485c"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_convertible&lt; ValueType, <a class="el" href="a01528.html#a735233c2a1599812e8cd3e6f4676dd48">value_type</a> &gt;::value, <a class="el" href="a01440.html#a34e9bf293f856d54796593981ea52c17">derived_type</a> &gt;::type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#adc3237c1a6746c8a5a8cd3aae0b4485c">operator+=</a> (const ValueType &amp;kk)</td></tr>
<tr class="memdesc:adc3237c1a6746c8a5a8cd3aae0b4485c"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector space add scalar to all comps  <a href="a01440.html#adc3237c1a6746c8a5a8cd3aae0b4485c">More...</a><br /></td></tr>
<tr class="separator:adc3237c1a6746c8a5a8cd3aae0b4485c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00bc8929e2831baa50b93aae523c370"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01440.html#a34e9bf293f856d54796593981ea52c17">derived_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#af00bc8929e2831baa50b93aae523c370">operator-=</a> (const <a class="el" href="a01440.html">DenseVector</a>&lt; Other &gt; &amp;x)</td></tr>
<tr class="memdesc:af00bc8929e2831baa50b93aae523c370"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector space subtraction  <a href="a01440.html#af00bc8929e2831baa50b93aae523c370">More...</a><br /></td></tr>
<tr class="separator:af00bc8929e2831baa50b93aae523c370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca7fedab4084fbbf33c1b1e08bff253"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_convertible&lt; ValueType, <a class="el" href="a01528.html#a735233c2a1599812e8cd3e6f4676dd48">value_type</a> &gt;::value, <a class="el" href="a01440.html#a34e9bf293f856d54796593981ea52c17">derived_type</a> &gt;::type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#a0ca7fedab4084fbbf33c1b1e08bff253">operator-=</a> (const ValueType &amp;kk)</td></tr>
<tr class="memdesc:a0ca7fedab4084fbbf33c1b1e08bff253"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector space subtract scalar from all comps  <a href="a01440.html#a0ca7fedab4084fbbf33c1b1e08bff253">More...</a><br /></td></tr>
<tr class="separator:a0ca7fedab4084fbbf33c1b1e08bff253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c92f5d9bb45d293d88849a7e85404e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01440.html#a34e9bf293f856d54796593981ea52c17">derived_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#a36c92f5d9bb45d293d88849a7e85404e">operator+</a> (const <a class="el" href="a01440.html">DenseVector</a>&lt; Other &gt; &amp;b) const</td></tr>
<tr class="memdesc:a36c92f5d9bb45d293d88849a7e85404e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary vector addition.  <a href="a01440.html#a36c92f5d9bb45d293d88849a7e85404e">More...</a><br /></td></tr>
<tr class="separator:a36c92f5d9bb45d293d88849a7e85404e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2f4380345e7663888d661caa64518c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01440.html#a34e9bf293f856d54796593981ea52c17">derived_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#a6c2f4380345e7663888d661caa64518c">operator-</a> (const <a class="el" href="a01440.html">DenseVector</a>&lt; Other &gt; &amp;b) const</td></tr>
<tr class="memdesc:a6c2f4380345e7663888d661caa64518c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary vector subtraction.  <a href="a01440.html#a6c2f4380345e7663888d661caa64518c">More...</a><br /></td></tr>
<tr class="separator:a6c2f4380345e7663888d661caa64518c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e4c064a337af542311bf3fe2672098"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01440.html#a34e9bf293f856d54796593981ea52c17">derived_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#ae1e4c064a337af542311bf3fe2672098">operator-</a> () const</td></tr>
<tr class="memdesc:ae1e4c064a337af542311bf3fe2672098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector negation.  <a href="a01440.html#ae1e4c064a337af542311bf3fe2672098">More...</a><br /></td></tr>
<tr class="separator:ae1e4c064a337af542311bf3fe2672098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119f5e5f2cec83ef023c1c18ce182f14"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_convertible&lt; FieldType, <a class="el" href="a01440.html#ab40059aac27a618d775bce116b4f3746">field_type</a> &gt;::value, <a class="el" href="a01440.html#a34e9bf293f856d54796593981ea52c17">derived_type</a> &gt;::type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#a119f5e5f2cec83ef023c1c18ce182f14">operator*=</a> (const FieldType &amp;kk)</td></tr>
<tr class="memdesc:a119f5e5f2cec83ef023c1c18ce182f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector space multiplication with scalar  <a href="a01440.html#a119f5e5f2cec83ef023c1c18ce182f14">More...</a><br /></td></tr>
<tr class="separator:a119f5e5f2cec83ef023c1c18ce182f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62eef9cdbbfc1d91e69af823256e1171"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_convertible&lt; FieldType, <a class="el" href="a01440.html#ab40059aac27a618d775bce116b4f3746">field_type</a> &gt;::value, <a class="el" href="a01440.html#a34e9bf293f856d54796593981ea52c17">derived_type</a> &gt;::type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#a62eef9cdbbfc1d91e69af823256e1171">operator/=</a> (const FieldType &amp;kk)</td></tr>
<tr class="memdesc:a62eef9cdbbfc1d91e69af823256e1171"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector space division by scalar  <a href="a01440.html#a62eef9cdbbfc1d91e69af823256e1171">More...</a><br /></td></tr>
<tr class="separator:a62eef9cdbbfc1d91e69af823256e1171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa793f3dffdd5ae987f0792dfc02fa6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#a1fa793f3dffdd5ae987f0792dfc02fa6">operator==</a> (const <a class="el" href="a01440.html">DenseVector</a>&lt; Other &gt; &amp;x) const</td></tr>
<tr class="memdesc:a1fa793f3dffdd5ae987f0792dfc02fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary vector comparison.  <a href="a01440.html#a1fa793f3dffdd5ae987f0792dfc02fa6">More...</a><br /></td></tr>
<tr class="separator:a1fa793f3dffdd5ae987f0792dfc02fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ebb6a081f83f2a80a86b5f417ba133e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#a8ebb6a081f83f2a80a86b5f417ba133e">operator!=</a> (const <a class="el" href="a01440.html">DenseVector</a>&lt; Other &gt; &amp;x) const</td></tr>
<tr class="memdesc:a8ebb6a081f83f2a80a86b5f417ba133e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary vector incomparison.  <a href="a01440.html#a8ebb6a081f83f2a80a86b5f417ba133e">More...</a><br /></td></tr>
<tr class="separator:a8ebb6a081f83f2a80a86b5f417ba133e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31fb1c0efefc27f705e1e70893274e89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01440.html#a34e9bf293f856d54796593981ea52c17">derived_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#a31fb1c0efefc27f705e1e70893274e89">axpy</a> (const <a class="el" href="a01440.html#ab40059aac27a618d775bce116b4f3746">field_type</a> &amp;a, const <a class="el" href="a01440.html">DenseVector</a>&lt; Other &gt; &amp;x)</td></tr>
<tr class="memdesc:a31fb1c0efefc27f705e1e70893274e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector space axpy operation ( *this += a x )  <a href="a01440.html#a31fb1c0efefc27f705e1e70893274e89">More...</a><br /></td></tr>
<tr class="separator:a31fb1c0efefc27f705e1e70893274e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4796b3c38eef54dde846d9b81b5710ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a02404.html">PromotionTraits</a>&lt; <a class="el" href="a01440.html#ab40059aac27a618d775bce116b4f3746">field_type</a>, typename <a class="el" href="a01440.html">DenseVector</a>&lt; Other &gt;::<a class="el" href="a01440.html#ab40059aac27a618d775bce116b4f3746">field_type</a> &gt;::PromotedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#a4796b3c38eef54dde846d9b81b5710ca">operator*</a> (const <a class="el" href="a01440.html">DenseVector</a>&lt; Other &gt; &amp;x) const</td></tr>
<tr class="memdesc:a4796b3c38eef54dde846d9b81b5710ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">indefinite vector dot product <img class="formulaInl" alt="$\left (x^T \cdot y \right)$" src="form_0.png"/> which corresponds to Petsc's VecTDot  <a href="a01440.html#a4796b3c38eef54dde846d9b81b5710ca">More...</a><br /></td></tr>
<tr class="separator:a4796b3c38eef54dde846d9b81b5710ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab686121e2b1fa004158a10defc6d2e24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a02404.html">PromotionTraits</a>&lt; <a class="el" href="a01440.html#ab40059aac27a618d775bce116b4f3746">field_type</a>, typename <a class="el" href="a01440.html">DenseVector</a>&lt; Other &gt;::<a class="el" href="a01440.html#ab40059aac27a618d775bce116b4f3746">field_type</a> &gt;::PromotedType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#ab686121e2b1fa004158a10defc6d2e24">dot</a> (const <a class="el" href="a01440.html">DenseVector</a>&lt; Other &gt; &amp;x) const</td></tr>
<tr class="memdesc:ab686121e2b1fa004158a10defc6d2e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector dot product <img class="formulaInl" alt="$\left (x^H \cdot y \right)$" src="form_1.png"/> which corresponds to Petsc's VecDot  <a href="a01440.html#ab686121e2b1fa004158a10defc6d2e24">More...</a><br /></td></tr>
<tr class="separator:ab686121e2b1fa004158a10defc6d2e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517d6e277a84e9b29dda9701bc8c67d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01748.html">FieldTraits</a>&lt; <a class="el" href="a01528.html#a735233c2a1599812e8cd3e6f4676dd48">value_type</a> &gt;::real_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#a517d6e277a84e9b29dda9701bc8c67d6">one_norm</a> () const</td></tr>
<tr class="memdesc:a517d6e277a84e9b29dda9701bc8c67d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">one norm (sum over absolute values of entries)  <a href="a01440.html#a517d6e277a84e9b29dda9701bc8c67d6">More...</a><br /></td></tr>
<tr class="separator:a517d6e277a84e9b29dda9701bc8c67d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee6d34642b49f809a80f52b00bbcf24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01748.html">FieldTraits</a>&lt; <a class="el" href="a01528.html#a735233c2a1599812e8cd3e6f4676dd48">value_type</a> &gt;::real_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#afee6d34642b49f809a80f52b00bbcf24">one_norm_real</a> () const</td></tr>
<tr class="memdesc:afee6d34642b49f809a80f52b00bbcf24"><td class="mdescLeft">&#160;</td><td class="mdescRight">simplified one norm (uses Manhattan norm for complex values)  <a href="a01440.html#afee6d34642b49f809a80f52b00bbcf24">More...</a><br /></td></tr>
<tr class="separator:afee6d34642b49f809a80f52b00bbcf24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a846f8a5afda7160cbed51d6ebeb61c3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01748.html">FieldTraits</a>&lt; <a class="el" href="a01528.html#a735233c2a1599812e8cd3e6f4676dd48">value_type</a> &gt;::real_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#a846f8a5afda7160cbed51d6ebeb61c3e">two_norm</a> () const</td></tr>
<tr class="memdesc:a846f8a5afda7160cbed51d6ebeb61c3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">two norm sqrt(sum over squared values of entries)  <a href="a01440.html#a846f8a5afda7160cbed51d6ebeb61c3e">More...</a><br /></td></tr>
<tr class="separator:a846f8a5afda7160cbed51d6ebeb61c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc4f5a3599d0a88aa26addc9bc36647"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01748.html">FieldTraits</a>&lt; <a class="el" href="a01528.html#a735233c2a1599812e8cd3e6f4676dd48">value_type</a> &gt;::real_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#a1fc4f5a3599d0a88aa26addc9bc36647">two_norm2</a> () const</td></tr>
<tr class="memdesc:a1fc4f5a3599d0a88aa26addc9bc36647"><td class="mdescLeft">&#160;</td><td class="mdescRight">square of two norm (sum over squared values of entries), need for block recursion  <a href="a01440.html#a1fc4f5a3599d0a88aa26addc9bc36647">More...</a><br /></td></tr>
<tr class="separator:a1fc4f5a3599d0a88aa26addc9bc36647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08cf1d1e315ba9a99499fc907302aa7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01748.html">FieldTraits</a>&lt; vt &gt;::real_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#ab08cf1d1e315ba9a99499fc907302aa7">infinity_norm</a> () const</td></tr>
<tr class="memdesc:ab08cf1d1e315ba9a99499fc907302aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">infinity norm (maximum of absolute values of entries)  <a href="a01440.html#ab08cf1d1e315ba9a99499fc907302aa7">More...</a><br /></td></tr>
<tr class="separator:ab08cf1d1e315ba9a99499fc907302aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08cf1d1e315ba9a99499fc907302aa7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01748.html">FieldTraits</a>&lt; vt &gt;::real_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#ab08cf1d1e315ba9a99499fc907302aa7">infinity_norm</a> () const</td></tr>
<tr class="memdesc:ab08cf1d1e315ba9a99499fc907302aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">infinity norm (maximum of absolute values of entries)  <a href="a01440.html#ab08cf1d1e315ba9a99499fc907302aa7">More...</a><br /></td></tr>
<tr class="separator:ab08cf1d1e315ba9a99499fc907302aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6bdfe70aee7324368e1c54ab3e461d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01748.html">FieldTraits</a>&lt; vt &gt;::real_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#aa6bdfe70aee7324368e1c54ab3e461d0">infinity_norm_real</a> () const</td></tr>
<tr class="memdesc:aa6bdfe70aee7324368e1c54ab3e461d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">simplified infinity norm (uses Manhattan norm for complex values)  <a href="a01440.html#aa6bdfe70aee7324368e1c54ab3e461d0">More...</a><br /></td></tr>
<tr class="separator:aa6bdfe70aee7324368e1c54ab3e461d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6bdfe70aee7324368e1c54ab3e461d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01748.html">FieldTraits</a>&lt; vt &gt;::real_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#aa6bdfe70aee7324368e1c54ab3e461d0">infinity_norm_real</a> () const</td></tr>
<tr class="memdesc:aa6bdfe70aee7324368e1c54ab3e461d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">simplified infinity norm (uses Manhattan norm for complex values)  <a href="a01440.html#aa6bdfe70aee7324368e1c54ab3e461d0">More...</a><br /></td></tr>
<tr class="separator:aa6bdfe70aee7324368e1c54ab3e461d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9aef3e17003431e0f5961c4dc6a812d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01528.html#a50a7d3fa728a4b82b4407b134e347190">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#af9aef3e17003431e0f5961c4dc6a812d">N</a> () const</td></tr>
<tr class="memdesc:af9aef3e17003431e0f5961c4dc6a812d"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of blocks in the vector (are of size 1 here)  <a href="a01440.html#af9aef3e17003431e0f5961c4dc6a812d">More...</a><br /></td></tr>
<tr class="separator:af9aef3e17003431e0f5961c4dc6a812d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480978e0af56a520f3e7745da87d9e20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01528.html#a50a7d3fa728a4b82b4407b134e347190">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html#a480978e0af56a520f3e7745da87d9e20">dim</a> () const</td></tr>
<tr class="memdesc:a480978e0af56a520f3e7745da87d9e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">dimension of the vector space  <a href="a01440.html#a480978e0af56a520f3e7745da87d9e20">More...</a><br /></td></tr>
<tr class="separator:a480978e0af56a520f3e7745da87d9e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ga5fd7ba8e53d3022e0cfe8f94ed6c8ff4"><td class="memTemplParams" colspan="2">template&lt;class K , class Allocator &gt; </td></tr>
<tr class="memitem:ga5fd7ba8e53d3022e0cfe8f94ed6c8ff4"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00414.html#ga5fd7ba8e53d3022e0cfe8f94ed6c8ff4">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="a01528.html">DynamicVector</a>&lt; K, Allocator &gt; &amp;v)</td></tr>
<tr class="memdesc:ga5fd7ba8e53d3022e0cfe8f94ed6c8ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a <a class="el" href="a01528.html" title="Construct a vector with a dynamic size.">DynamicVector</a> from an input stream.  <a href="a00414.html#ga5fd7ba8e53d3022e0cfe8f94ed6c8ff4">More...</a><br /></td></tr>
<tr class="separator:ga5fd7ba8e53d3022e0cfe8f94ed6c8ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf26a8b04e2b33adf0ddc79868ad2b58d"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00414.html#gaf26a8b04e2b33adf0ddc79868ad2b58d">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="a01440.html">DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt; &gt; &amp;v)</td></tr>
<tr class="memdesc:gaf26a8b04e2b33adf0ddc79868ad2b58d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a DenseVector to an output stream.  <a href="a00414.html#gaf26a8b04e2b33adf0ddc79868ad2b58d">More...</a><br /></td></tr>
<tr class="separator:gaf26a8b04e2b33adf0ddc79868ad2b58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class K, class Allocator = std::allocator&lt; K &gt;&gt;<br />
class Dune::DynamicVector&lt; K, Allocator &gt;</h3>

<p>Construct a vector with a dynamic size. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>is the field type (use float, double, complex, etc) </td></tr>
    <tr><td class="paramname">Allocator</td><td>type of allocator object used to define the storage allocation model, default Allocator = std::allocator&lt; K &gt;. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a7565d55f987adf7629660bdc919d3aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7565d55f987adf7629660bdc919d3aff">&#9670;&nbsp;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class Allocator  = std::allocator&lt; K &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Allocator <a class="el" href="a01528.html">Dune::DynamicVector</a>&lt; K, Allocator &gt;::<a class="el" href="a01528.html#a7565d55f987adf7629660bdc919d3aff">allocator_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5e72791f5c4cffc273a43f63a3072d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5e72791f5c4cffc273a43f63a3072d8">&#9670;&nbsp;</a></span>block_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef Traits::value_type <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::<a class="el" href="a01440.html#ab5e72791f5c4cffc273a43f63a3072d8">block_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>export the type representing the components </p>

</div>
</div>
<a id="a08e293015cdccffda5df1fe06070a130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08e293015cdccffda5df1fe06070a130">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a01440.html#a284929d58f3df6c66e2a7ad629a7f4f2">ConstIterator</a> <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::<a class="el" href="a01440.html#a08e293015cdccffda5df1fe06070a130">const_iterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>typedef for stl compliant access </p>

</div>
</div>
<a id="a284929d58f3df6c66e2a7ad629a7f4f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a284929d58f3df6c66e2a7ad629a7f4f2">&#9670;&nbsp;</a></span>ConstIterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a01456.html">DenseIterator</a>&lt;const <a class="el" href="a01440.html">DenseVector</a>,const <a class="el" href="a01528.html#a735233c2a1599812e8cd3e6f4676dd48">value_type</a>&gt; <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::<a class="el" href="a01440.html#a284929d58f3df6c66e2a7ad629a7f4f2">ConstIterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ConstIterator class for sequential access. </p>

</div>
</div>
<a id="a5a7bd4fc26554e6189ecc927bd1bfb4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a7bd4fc26554e6189ecc927bd1bfb4b">&#9670;&nbsp;</a></span>container_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class Allocator  = std::allocator&lt; K &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt; K, Allocator &gt; <a class="el" href="a01528.html">Dune::DynamicVector</a>&lt; K, Allocator &gt;::<a class="el" href="a01528.html#a5a7bd4fc26554e6189ecc927bd1bfb4b">container_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34e9bf293f856d54796593981ea52c17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e9bf293f856d54796593981ea52c17">&#9670;&nbsp;</a></span>derived_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef Traits::derived_type <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::<a class="el" href="a01440.html#a34e9bf293f856d54796593981ea52c17">derived_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>type of derived vector class </p>

</div>
</div>
<a id="ab40059aac27a618d775bce116b4f3746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab40059aac27a618d775bce116b4f3746">&#9670;&nbsp;</a></span>field_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a01748.html">FieldTraits</a>&lt; <a class="el" href="a01528.html#a735233c2a1599812e8cd3e6f4676dd48">value_type</a> &gt;::<a class="el" href="a01440.html#ab40059aac27a618d775bce116b4f3746">field_type</a> <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::<a class="el" href="a01440.html#ab40059aac27a618d775bce116b4f3746">field_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>export the type representing the field </p>

</div>
</div>
<a id="a6c98d3c53e08f0db8cce3b1e88b45c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c98d3c53e08f0db8cce3b1e88b45c1a">&#9670;&nbsp;</a></span>Iterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a01456.html">DenseIterator</a>&lt;<a class="el" href="a01440.html">DenseVector</a>,<a class="el" href="a01528.html#a735233c2a1599812e8cd3e6f4676dd48">value_type</a>&gt; <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::<a class="el" href="a01440.html#a6c98d3c53e08f0db8cce3b1e88b45c1a">Iterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator class for sequential access. </p>

</div>
</div>
<a id="a0d32efa59ca198acd89776fff71d4ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d32efa59ca198acd89776fff71d4ef3">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a01440.html#a6c98d3c53e08f0db8cce3b1e88b45c1a">Iterator</a> <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::<a class="el" href="a01440.html#a0d32efa59ca198acd89776fff71d4ef3">iterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>typedef for stl compliant access </p>

</div>
</div>
<a id="a50a7d3fa728a4b82b4407b134e347190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a7d3fa728a4b82b4407b134e347190">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class Allocator  = std::allocator&lt; K &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a01440.html#a67b4a65a6199d863602f152045f5a5dd">Base::size_type</a> <a class="el" href="a01528.html">Dune::DynamicVector</a>&lt; K, Allocator &gt;::<a class="el" href="a01528.html#a50a7d3fa728a4b82b4407b134e347190">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a735233c2a1599812e8cd3e6f4676dd48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a735233c2a1599812e8cd3e6f4676dd48">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class Allocator  = std::allocator&lt; K &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a01440.html#a007463aa44631abffe62eb8c868ae95d">Base::value_type</a> <a class="el" href="a01528.html">Dune::DynamicVector</a>&lt; K, Allocator &gt;::<a class="el" href="a01528.html#a735233c2a1599812e8cd3e6f4676dd48">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ac53558845f4efcb6623cbddca97c2970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac53558845f4efcb6623cbddca97c2970">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>We are at the leaf of the block recursion. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7ab6b30514c24d5afa6eaf1d12349692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ab6b30514c24d5afa6eaf1d12349692">&#9670;&nbsp;</a></span>DynamicVector() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class Allocator  = std::allocator&lt; K &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01528.html">Dune::DynamicVector</a>&lt; K, Allocator &gt;::<a class="el" href="a01528.html">DynamicVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01528.html#a7565d55f987adf7629660bdc919d3aff">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em> = <code><a class="el" href="a01528.html#a7565d55f987adf7629660bdc919d3aff">allocator_type</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor making uninitialized vector. </p>

</div>
</div>
<a id="abdca3f644f1b4151eb8e8f39656b239c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdca3f644f1b4151eb8e8f39656b239c">&#9670;&nbsp;</a></span>DynamicVector() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class Allocator  = std::allocator&lt; K &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01528.html">Dune::DynamicVector</a>&lt; K, Allocator &gt;::<a class="el" href="a01528.html">DynamicVector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01528.html#a50a7d3fa728a4b82b4407b134e347190">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01528.html#a7565d55f987adf7629660bdc919d3aff">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em> = <code><a class="el" href="a01528.html#a7565d55f987adf7629660bdc919d3aff">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae821be352676f391e19ffa70d9ca3714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae821be352676f391e19ffa70d9ca3714">&#9670;&nbsp;</a></span>DynamicVector() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class Allocator  = std::allocator&lt; K &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01528.html">Dune::DynamicVector</a>&lt; K, Allocator &gt;::<a class="el" href="a01528.html">DynamicVector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01528.html#a50a7d3fa728a4b82b4407b134e347190">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01528.html#a735233c2a1599812e8cd3e6f4676dd48">value_type</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01528.html#a7565d55f987adf7629660bdc919d3aff">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em> = <code><a class="el" href="a01528.html#a7565d55f987adf7629660bdc919d3aff">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor making vector with identical coordinates. </p>

</div>
</div>
<a id="ac816734949044d1f94a33060fcb1da39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac816734949044d1f94a33060fcb1da39">&#9670;&nbsp;</a></span>DynamicVector() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class Allocator  = std::allocator&lt; K &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01528.html">Dune::DynamicVector</a>&lt; K, Allocator &gt;::<a class="el" href="a01528.html">DynamicVector</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; K &gt; const &amp;&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a std::initializer_list. </p>

</div>
</div>
<a id="a2dc74b2715a2e47302d769df2992201b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dc74b2715a2e47302d769df2992201b">&#9670;&nbsp;</a></span>DynamicVector() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class Allocator  = std::allocator&lt; K &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01528.html">Dune::DynamicVector</a>&lt; K, Allocator &gt;::<a class="el" href="a01528.html">DynamicVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01528.html">DynamicVector</a>&lt; K, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor making vector with identical coordinates. </p>

</div>
</div>
<a id="a7e82f8787ae085c459dca22b0ed12d26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e82f8787ae085c459dca22b0ed12d26">&#9670;&nbsp;</a></span>DynamicVector() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class Allocator  = std::allocator&lt; K &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01528.html">Dune::DynamicVector</a>&lt; K, Allocator &gt;::<a class="el" href="a01528.html">DynamicVector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01528.html">DynamicVector</a>&lt; K, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>

</div>
</div>
<a id="ad3719da9dabab00e1de6921c553983a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3719da9dabab00e1de6921c553983a1">&#9670;&nbsp;</a></span>DynamicVector() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class Allocator  = std::allocator&lt; K &gt;&gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01528.html">Dune::DynamicVector</a>&lt; K, Allocator &gt;::<a class="el" href="a01528.html">DynamicVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01528.html">DynamicVector</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aec7d86873cf92f60efa2b17d11298f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec7d86873cf92f60efa2b17d11298f05">&#9670;&nbsp;</a></span>DynamicVector() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class Allocator  = std::allocator&lt; K &gt;&gt; </div>
<div class="memtemplate">
template&lt;class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01528.html">Dune::DynamicVector</a>&lt; K, Allocator &gt;::<a class="el" href="a01528.html">DynamicVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01440.html">DenseVector</a>&lt; X &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01528.html#a7565d55f987adf7629660bdc919d3aff">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em> = <code><a class="el" href="a01528.html#a7565d55f987adf7629660bdc919d3aff">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor from another <a class="el" href="a01440.html" title="Interface for a class of dense vectors over a given field.">DenseVector</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a31fb1c0efefc27f705e1e70893274e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31fb1c0efefc27f705e1e70893274e89">&#9670;&nbsp;</a></span>axpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01440.html#a34e9bf293f856d54796593981ea52c17">derived_type</a>&amp; <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::axpy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01440.html#ab40059aac27a618d775bce116b4f3746">field_type</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01440.html">DenseVector</a>&lt; Other &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>vector space axpy operation ( *this += a x ) </p>

</div>
</div>
<a id="a0802c4d1cc9af0e1da5590013baf4bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0802c4d1cc9af0e1da5590013baf4bf7">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01528.html#a735233c2a1599812e8cd3e6f4676dd48">value_type</a>&amp; <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return reference to last element </p>

</div>
</div>
<a id="a6ed9667b527c99a1eb172e13c3cffe37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ed9667b527c99a1eb172e13c3cffe37">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a01528.html#a735233c2a1599812e8cd3e6f4676dd48">value_type</a>&amp; <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return reference to last element </p>

</div>
</div>
<a id="a23408ea7b99536c94aa32907372cc52b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23408ea7b99536c94aa32907372cc52b">&#9670;&nbsp;</a></span>beforeBegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01440.html#a6c98d3c53e08f0db8cce3b1e88b45c1a">Iterator</a> <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::beforeBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an iterator that is positioned before the first entry of the vector. </dd></dl>

</div>
</div>
<a id="a1f4723b4cce2f85f275a3d26d21aac6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f4723b4cce2f85f275a3d26d21aac6f">&#9670;&nbsp;</a></span>beforeBegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01440.html#a284929d58f3df6c66e2a7ad629a7f4f2">ConstIterator</a> <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::beforeBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an iterator that is positioned before the first entry of the vector. </dd></dl>

</div>
</div>
<a id="a8352d8d5b5d98f82b0620fdde870b3ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8352d8d5b5d98f82b0620fdde870b3ad">&#9670;&nbsp;</a></span>beforeEnd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01440.html#a6c98d3c53e08f0db8cce3b1e88b45c1a">Iterator</a> <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::beforeEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an iterator that is positioned before the end iterator of the vector, i.e. at the last entry. </dd></dl>

</div>
</div>
<a id="a4cabf0d4856865d667868784fa511f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cabf0d4856865d667868784fa511f4a">&#9670;&nbsp;</a></span>beforeEnd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01440.html#a284929d58f3df6c66e2a7ad629a7f4f2">ConstIterator</a> <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::beforeEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an iterator that is positioned before the end iterator of the vector. i.e. at the last element </dd></dl>

</div>
</div>
<a id="a2154e1f6858db8dad26046187837bc0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2154e1f6858db8dad26046187837bc0d">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01440.html#a6c98d3c53e08f0db8cce3b1e88b45c1a">Iterator</a> <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>begin iterator </p>

</div>
</div>
<a id="aa4806c2eaf07106ccc5bd6b7320c9ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4806c2eaf07106ccc5bd6b7320c9ecf">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01440.html#a284929d58f3df6c66e2a7ad629a7f4f2">ConstIterator</a> <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>begin ConstIterator </p>

</div>
</div>
<a id="aa28080f12c895ae6cf7f11f26bb6f729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa28080f12c895ae6cf7f11f26bb6f729">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class Allocator  = std::allocator&lt; K &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01528.html#a50a7d3fa728a4b82b4407b134e347190">size_type</a> <a class="el" href="a01528.html">Dune::DynamicVector</a>&lt; K, Allocator &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of elements for which memory has been allocated. </p>
<p><a class="el" href="a01528.html#aa28080f12c895ae6cf7f11f26bb6f729" title="Number of elements for which memory has been allocated.">capacity()</a> is always greater than or equal to <a class="el" href="a01528.html#a61cc6ffa5d43445b061035c97d58e38e">size()</a>. </p>

</div>
</div>
<a id="aad962bdabce70024ee5ccef0e4684eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad962bdabce70024ee5ccef0e4684eee">&#9670;&nbsp;</a></span>container() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class Allocator  = std::allocator&lt; K &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01528.html#a5a7bd4fc26554e6189ecc927bd1bfb4b">container_type</a>&amp; <a class="el" href="a01528.html">Dune::DynamicVector</a>&lt; K, Allocator &gt;::container </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aef4b98fb48e820d4071162c1ec933bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef4b98fb48e820d4071162c1ec933bf6">&#9670;&nbsp;</a></span>container() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class Allocator  = std::allocator&lt; K &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a01528.html#a5a7bd4fc26554e6189ecc927bd1bfb4b">container_type</a>&amp; <a class="el" href="a01528.html">Dune::DynamicVector</a>&lt; K, Allocator &gt;::container </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adf84bf7cd074630d98a443f5771a217d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf84bf7cd074630d98a443f5771a217d">&#9670;&nbsp;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class Allocator  = std::allocator&lt; K &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const K* <a class="el" href="a01528.html">Dune::DynamicVector</a>&lt; K, Allocator &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return pointer to underlying array </p>

</div>
</div>
<a id="a61466250acc18c3b87b216310831f6e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61466250acc18c3b87b216310831f6e1">&#9670;&nbsp;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class Allocator  = std::allocator&lt; K &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">K* <a class="el" href="a01528.html">Dune::DynamicVector</a>&lt; K, Allocator &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return pointer to underlying array </p>

</div>
</div>
<a id="a480978e0af56a520f3e7745da87d9e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a480978e0af56a520f3e7745da87d9e20">&#9670;&nbsp;</a></span>dim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01528.html#a50a7d3fa728a4b82b4407b134e347190">size_type</a> <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::dim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>dimension of the vector space </p>

</div>
</div>
<a id="ab686121e2b1fa004158a10defc6d2e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab686121e2b1fa004158a10defc6d2e24">&#9670;&nbsp;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02404.html">PromotionTraits</a>&lt;<a class="el" href="a01440.html#ab40059aac27a618d775bce116b4f3746">field_type</a>,typename <a class="el" href="a01440.html">DenseVector</a>&lt;Other&gt;::<a class="el" href="a01440.html#ab40059aac27a618d775bce116b4f3746">field_type</a>&gt;::PromotedType <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01440.html">DenseVector</a>&lt; Other &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>vector dot product <img class="formulaInl" alt="$\left (x^H \cdot y \right)$" src="form_1.png"/> which corresponds to Petsc's VecDot </p>
<p><a href="http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Vec/VecDot.html">http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Vec/VecDot.html</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>other vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="afd39ba30f616bcf4158a1d8b3e4bf872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd39ba30f616bcf4158a1d8b3e4bf872">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>checks whether the container is empty </p>

</div>
</div>
<a id="a5feee4aa0d88277f19169c7833cd9e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5feee4aa0d88277f19169c7833cd9e9f">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01440.html#a6c98d3c53e08f0db8cce3b1e88b45c1a">Iterator</a> <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>end iterator </p>

</div>
</div>
<a id="a195a839274c030e30ab03f7efabcc3aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a195a839274c030e30ab03f7efabcc3aa">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01440.html#a284929d58f3df6c66e2a7ad629a7f4f2">ConstIterator</a> <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>end ConstIterator </p>

</div>
</div>
<a id="af2264c91ca0dfbd9dda13814fc588e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2264c91ca0dfbd9dda13814fc588e60">&#9670;&nbsp;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01440.html#a6c98d3c53e08f0db8cce3b1e88b45c1a">Iterator</a> <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01440.html#a67b4a65a6199d863602f152045f5a5dd">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return iterator to given element or <a class="el" href="a01440.html#a5feee4aa0d88277f19169c7833cd9e9f" title="end iterator">end()</a> </p>

</div>
</div>
<a id="a1903b7bf21abd5d7c60a33182f6bf31d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1903b7bf21abd5d7c60a33182f6bf31d">&#9670;&nbsp;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01440.html#a284929d58f3df6c66e2a7ad629a7f4f2">ConstIterator</a> <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01440.html#a67b4a65a6199d863602f152045f5a5dd">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return iterator to given element or <a class="el" href="a01440.html#a5feee4aa0d88277f19169c7833cd9e9f" title="end iterator">end()</a> </p>

</div>
</div>
<a id="aff7eb3783fc33c122c1bbd49da49483c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff7eb3783fc33c122c1bbd49da49483c">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01528.html#a735233c2a1599812e8cd3e6f4676dd48">value_type</a>&amp; <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return reference to first element </p>

</div>
</div>
<a id="a4535132c8c9be58328d5589de76ce1d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4535132c8c9be58328d5589de76ce1d3">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a01528.html#a735233c2a1599812e8cd3e6f4676dd48">value_type</a>&amp; <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return reference to first element </p>

</div>
</div>
<a id="ab08cf1d1e315ba9a99499fc907302aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab08cf1d1e315ba9a99499fc907302aa7">&#9670;&nbsp;</a></span>infinity_norm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01748.html">FieldTraits</a>&lt;vt&gt;::real_type <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::infinity_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>infinity norm (maximum of absolute values of entries) </p>

</div>
</div>
<a id="ab08cf1d1e315ba9a99499fc907302aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab08cf1d1e315ba9a99499fc907302aa7">&#9670;&nbsp;</a></span>infinity_norm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01748.html">FieldTraits</a>&lt;vt&gt;::real_type <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::infinity_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>infinity norm (maximum of absolute values of entries) </p>

</div>
</div>
<a id="aa6bdfe70aee7324368e1c54ab3e461d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6bdfe70aee7324368e1c54ab3e461d0">&#9670;&nbsp;</a></span>infinity_norm_real() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01748.html">FieldTraits</a>&lt;vt&gt;::real_type <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::infinity_norm_real </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>simplified infinity norm (uses Manhattan norm for complex values) </p>

</div>
</div>
<a id="aa6bdfe70aee7324368e1c54ab3e461d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6bdfe70aee7324368e1c54ab3e461d0">&#9670;&nbsp;</a></span>infinity_norm_real() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01748.html">FieldTraits</a>&lt;vt&gt;::real_type <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::infinity_norm_real </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>simplified infinity norm (uses Manhattan norm for complex values) </p>

</div>
</div>
<a id="af9aef3e17003431e0f5961c4dc6a812d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9aef3e17003431e0f5961c4dc6a812d">&#9670;&nbsp;</a></span>N()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01528.html#a50a7d3fa728a4b82b4407b134e347190">size_type</a> <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::N </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>number of blocks in the vector (are of size 1 here) </p>

</div>
</div>
<a id="a517d6e277a84e9b29dda9701bc8c67d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a517d6e277a84e9b29dda9701bc8c67d6">&#9670;&nbsp;</a></span>one_norm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01748.html">FieldTraits</a>&lt;<a class="el" href="a01528.html#a735233c2a1599812e8cd3e6f4676dd48">value_type</a>&gt;::real_type <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::one_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>one norm (sum over absolute values of entries) </p>

</div>
</div>
<a id="afee6d34642b49f809a80f52b00bbcf24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afee6d34642b49f809a80f52b00bbcf24">&#9670;&nbsp;</a></span>one_norm_real()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01748.html">FieldTraits</a>&lt;<a class="el" href="a01528.html#a735233c2a1599812e8cd3e6f4676dd48">value_type</a>&gt;::real_type <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::one_norm_real </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>simplified one norm (uses Manhattan norm for complex values) </p>

</div>
</div>
<a id="a8ebb6a081f83f2a80a86b5f417ba133e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ebb6a081f83f2a80a86b5f417ba133e">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01440.html">DenseVector</a>&lt; Other &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary vector incomparison. </p>

</div>
</div>
<a id="a4796b3c38eef54dde846d9b81b5710ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4796b3c38eef54dde846d9b81b5710ca">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02404.html">PromotionTraits</a>&lt;<a class="el" href="a01440.html#ab40059aac27a618d775bce116b4f3746">field_type</a>,typename <a class="el" href="a01440.html">DenseVector</a>&lt;Other&gt;::<a class="el" href="a01440.html#ab40059aac27a618d775bce116b4f3746">field_type</a>&gt;::PromotedType <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01440.html">DenseVector</a>&lt; Other &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>indefinite vector dot product <img class="formulaInl" alt="$\left (x^T \cdot y \right)$" src="form_0.png"/> which corresponds to Petsc's VecTDot </p>
<p><a href="http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Vec/VecTDot.html">http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Vec/VecTDot.html</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>other vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a119f5e5f2cec83ef023c1c18ce182f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a119f5e5f2cec83ef023c1c18ce182f14">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_convertible&lt;FieldType, <a class="el" href="a01440.html#ab40059aac27a618d775bce116b4f3746">field_type</a>&gt;::value, <a class="el" href="a01440.html#a34e9bf293f856d54796593981ea52c17">derived_type</a> &gt;::type&amp; <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const FieldType &amp;&#160;</td>
          <td class="paramname"><em>kk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>vector space multiplication with scalar </p>
<p>we use enable_if to avoid an ambiguity, if the function parameter can be converted to field_type implicitly. (see FS#1457)</p>
<p>The function is only enabled, if the parameter is directly convertible to field_type. </p>

</div>
</div>
<a id="a36c92f5d9bb45d293d88849a7e85404e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36c92f5d9bb45d293d88849a7e85404e">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01440.html#a34e9bf293f856d54796593981ea52c17">derived_type</a> <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01440.html">DenseVector</a>&lt; Other &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary vector addition. </p>

</div>
</div>
<a id="a88f16164643ad187211390a317e0bdf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f16164643ad187211390a317e0bdf1">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01440.html#a34e9bf293f856d54796593981ea52c17">derived_type</a>&amp; <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01440.html">DenseVector</a>&lt; Other &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>vector space addition </p>

</div>
</div>
<a id="adc3237c1a6746c8a5a8cd3aae0b4485c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc3237c1a6746c8a5a8cd3aae0b4485c">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_convertible&lt;ValueType, <a class="el" href="a01528.html#a735233c2a1599812e8cd3e6f4676dd48">value_type</a>&gt;::value, <a class="el" href="a01440.html#a34e9bf293f856d54796593981ea52c17">derived_type</a> &gt;::type&amp; <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>kk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>vector space add scalar to all comps </p>
<p>we use enable_if to avoid an ambiguity, if the function parameter can be converted to value_type implicitly. (see FS#1457)</p>
<p>The function is only enabled, if the parameter is directly convertible to value_type. </p>

</div>
</div>
<a id="ae1e4c064a337af542311bf3fe2672098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e4c064a337af542311bf3fe2672098">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01440.html#a34e9bf293f856d54796593981ea52c17">derived_type</a> <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector negation. </p>

</div>
</div>
<a id="a6c2f4380345e7663888d661caa64518c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c2f4380345e7663888d661caa64518c">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01440.html#a34e9bf293f856d54796593981ea52c17">derived_type</a> <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01440.html">DenseVector</a>&lt; Other &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary vector subtraction. </p>

</div>
</div>
<a id="af00bc8929e2831baa50b93aae523c370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00bc8929e2831baa50b93aae523c370">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01440.html#a34e9bf293f856d54796593981ea52c17">derived_type</a>&amp; <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01440.html">DenseVector</a>&lt; Other &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>vector space subtraction </p>

</div>
</div>
<a id="a0ca7fedab4084fbbf33c1b1e08bff253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ca7fedab4084fbbf33c1b1e08bff253">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_convertible&lt;ValueType, <a class="el" href="a01528.html#a735233c2a1599812e8cd3e6f4676dd48">value_type</a>&gt;::value, <a class="el" href="a01440.html#a34e9bf293f856d54796593981ea52c17">derived_type</a> &gt;::type&amp; <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>kk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>vector space subtract scalar from all comps </p>
<p>we use enable_if to avoid an ambiguity, if the function parameter can be converted to value_type implicitly. (see FS#1457)</p>
<p>The function is only enabled, if the parameter is directly convertible to value_type. </p>

</div>
</div>
<a id="a62eef9cdbbfc1d91e69af823256e1171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62eef9cdbbfc1d91e69af823256e1171">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_convertible&lt;FieldType, <a class="el" href="a01440.html#ab40059aac27a618d775bce116b4f3746">field_type</a>&gt;::value, <a class="el" href="a01440.html#a34e9bf293f856d54796593981ea52c17">derived_type</a> &gt;::type&amp; <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const FieldType &amp;&#160;</td>
          <td class="paramname"><em>kk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>vector space division by scalar </p>
<p>we use enable_if to avoid an ambiguity, if the function parameter can be converted to field_type implicitly. (see FS#1457)</p>
<p>The function is only enabled, if the parameter is directly convertible to field_type. </p>

</div>
</div>
<a id="ac7f5fe5d8925f4d17c957bee69ba70f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f5fe5d8925f4d17c957bee69ba70f7">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class Allocator  = std::allocator&lt; K &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01440.html">DenseVector</a>&amp; <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; V &gt;::operator=</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator for other <a class="el" href="a01440.html" title="Interface for a class of dense vectors over a given field.">DenseVector</a> of same type. </p>

</div>
</div>
<a id="aeb82fe94311ab1fd83f60b8a3814f881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb82fe94311ab1fd83f60b8a3814f881">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class Allocator  = std::allocator&lt; K &gt;&gt; </div>
<div class="memtemplate">
template&lt;typename W , std::enable_if_t&lt; std::is_assignable&lt; value_type &amp;, typename DenseVector&lt; W &gt;::value_type &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01440.html#a34e9bf293f856d54796593981ea52c17">derived_type</a>&amp; <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; V &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">typename W&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt; std::is_assignable&lt; <a class="el" href="a01528.html#a735233c2a1599812e8cd3e6f4676dd48">value_type</a> &amp;, typename <a class="el" href="a01440.html">DenseVector</a>&lt; W &gt;::<a class="el" href="a01528.html#a735233c2a1599812e8cd3e6f4676dd48">value_type</a> &gt;::value, int &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator for other <a class="el" href="a01440.html" title="Interface for a class of dense vectors over a given field.">DenseVector</a> of different type. </p>

</div>
</div>
<a id="a61f3befde174fd8fec8a4e9d1d57dd62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61f3befde174fd8fec8a4e9d1d57dd62">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class Allocator  = std::allocator&lt; K &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01528.html">DynamicVector</a>&amp; <a class="el" href="a01528.html">Dune::DynamicVector</a>&lt; K, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01528.html">DynamicVector</a>&lt; K, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>

</div>
</div>
<a id="aa684143b2a15b3739d782a8327d5993c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa684143b2a15b3739d782a8327d5993c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class Allocator  = std::allocator&lt; K &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01440.html#a34e9bf293f856d54796593981ea52c17">derived_type</a>&amp; <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; V &gt;::operator=</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator for scalar. </p>

</div>
</div>
<a id="a1e4d5d1d002528026ab748e22b3d0558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4d5d1d002528026ab748e22b3d0558">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class Allocator  = std::allocator&lt; K &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01528.html">DynamicVector</a>&amp; <a class="el" href="a01528.html">Dune::DynamicVector</a>&lt; K, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01528.html">DynamicVector</a>&lt; K, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>

</div>
</div>
<a id="a1fa793f3dffdd5ae987f0792dfc02fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa793f3dffdd5ae987f0792dfc02fa6">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01440.html">DenseVector</a>&lt; Other &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary vector comparison. </p>

</div>
</div>
<a id="aea329d38527ac5c9c79c76f45faeb6fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea329d38527ac5c9c79c76f45faeb6fd">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class Allocator  = std::allocator&lt; K &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">K&amp; <a class="el" href="a01528.html">Dune::DynamicVector</a>&lt; K, Allocator &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01528.html#a50a7d3fa728a4b82b4407b134e347190">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af5ec8c05e1b7ad8ca9b67a76882926a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5ec8c05e1b7ad8ca9b67a76882926a4">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class Allocator  = std::allocator&lt; K &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const K&amp; <a class="el" href="a01528.html">Dune::DynamicVector</a>&lt; K, Allocator &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01528.html#a50a7d3fa728a4b82b4407b134e347190">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adc5bfe6f530c32091c3dddca5f360b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc5bfe6f530c32091c3dddca5f360b33">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class Allocator  = std::allocator&lt; K &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01528.html">Dune::DynamicVector</a>&lt; K, Allocator &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01528.html#a50a7d3fa728a4b82b4407b134e347190">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1dc5235fd9a477eb17112e4826753b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc5235fd9a477eb17112e4826753b48">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class Allocator  = std::allocator&lt; K &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01528.html">Dune::DynamicVector</a>&lt; K, Allocator &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01528.html#a50a7d3fa728a4b82b4407b134e347190">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a01528.html#a735233c2a1599812e8cd3e6f4676dd48">value_type</a>&#160;</td>
          <td class="paramname"><em>c</em> = <code><a class="el" href="a01528.html#a735233c2a1599812e8cd3e6f4676dd48">value_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a61cc6ffa5d43445b061035c97d58e38e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61cc6ffa5d43445b061035c97d58e38e">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class Allocator  = std::allocator&lt; K &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01528.html#a50a7d3fa728a4b82b4407b134e347190">size_type</a> <a class="el" href="a01528.html">Dune::DynamicVector</a>&lt; K, Allocator &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a846f8a5afda7160cbed51d6ebeb61c3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a846f8a5afda7160cbed51d6ebeb61c3e">&#9670;&nbsp;</a></span>two_norm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01748.html">FieldTraits</a>&lt;<a class="el" href="a01528.html#a735233c2a1599812e8cd3e6f4676dd48">value_type</a>&gt;::real_type <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::two_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>two norm sqrt(sum over squared values of entries) </p>

</div>
</div>
<a id="a1fc4f5a3599d0a88aa26addc9bc36647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fc4f5a3599d0a88aa26addc9bc36647">&#9670;&nbsp;</a></span>two_norm2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01748.html">FieldTraits</a>&lt;<a class="el" href="a01528.html#a735233c2a1599812e8cd3e6f4676dd48">value_type</a>&gt;::real_type <a class="el" href="a01440.html">Dune::DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt;::two_norm2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>square of two norm (sum over squared values of entries), need for block recursion </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="gaf26a8b04e2b33adf0ddc79868ad2b58d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf26a8b04e2b33adf0ddc79868ad2b58d">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01440.html">DenseVector</a>&lt; <a class="el" href="a01528.html">DynamicVector</a>&lt; K, std::allocator&lt; K &gt; &gt;  &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a <a class="el" href="a01440.html" title="Interface for a class of dense vectors over a given field.">DenseVector</a> to an output stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>std :: ostream to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td><a class="el" href="a01440.html" title="Interface for a class of dense vectors over a given field.">DenseVector</a> to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream (s) </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="a00077_source.html">dynvector.hh</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
