<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>dune-common: Library Developer&#39;s Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">dune-common
   &#160;<span id="projectnumber">2.7.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a>  </div>
  <div class="headertitle">
<div class="title">Library Developer's Interface<div class="ingroups"><a class="el" href="a00400.html">Common</a> &raquo; <a class="el" href="a00420.html">Vectorization</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>How to support vectorization in <a class="el" href="a00428.html" title="Dune namespace.">Dune</a> classes.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Library Developer's Interface:</div>
<div class="dyncontent">
<div class="center"><img src="a00422.png" border="0" usemap="#aa00422" alt=""/></div>
<map name="aa00422" id="aa00422">
<area shape="rect" title="How to support vectorization in Dune classes." alt="" coords="152,5,283,45"/>
<area shape="rect" href="a00420.html" title="Abstractions for using vectorization libraries." alt="" coords="5,13,104,38"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:a04383"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a04383.html">simd/interface.hh</a></td></tr>
<tr class="memdesc:a04383"><td class="mdescLeft">&#160;</td><td class="mdescRight">User interface of the SIMD abstraction. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00299"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00299.html">io.hh</a></td></tr>
<tr class="memdesc:a00299"><td class="mdescLeft">&#160;</td><td class="mdescRight">IO interface of the SIMD abstraction. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Basic interface</h2></td></tr>
<tr class="memitem:gaf7f6f3418836afcdb2c033509fd2eb91"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:gaf7f6f3418836afcdb2c033509fd2eb91"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00422.html#gaf7f6f3418836afcdb2c033509fd2eb91">Dune::Simd::Scalar</a> = typename <a class="el" href="a02556.html">Overloads::ScalarType</a>&lt; std::decay_t&lt; V &gt; &gt;::type</td></tr>
<tr class="memdesc:gaf7f6f3418836afcdb2c033509fd2eb91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element type of some SIMD type.  <a href="a00422.html#gaf7f6f3418836afcdb2c033509fd2eb91">More...</a><br /></td></tr>
<tr class="separator:gaf7f6f3418836afcdb2c033509fd2eb91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d4752fe47def6075b211544a932c709"><td class="memTemplParams" colspan="2">template&lt;class S , class V &gt; </td></tr>
<tr class="memitem:ga8d4752fe47def6075b211544a932c709"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00422.html#ga8d4752fe47def6075b211544a932c709">Dune::Simd::Rebind</a> = typename <a class="el" href="a02560.html">Overloads::RebindType</a>&lt; std::decay_t&lt; S &gt;, std::decay_t&lt; V &gt; &gt;::type</td></tr>
<tr class="memdesc:ga8d4752fe47def6075b211544a932c709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct SIMD type with different scalar type.  <a href="a00422.html#ga8d4752fe47def6075b211544a932c709">More...</a><br /></td></tr>
<tr class="separator:ga8d4752fe47def6075b211544a932c709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6a0cf43eb7664581bd8a6954d7ff305"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:gac6a0cf43eb7664581bd8a6954d7ff305"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00422.html#gac6a0cf43eb7664581bd8a6954d7ff305">Dune::Simd::lanes</a> ()</td></tr>
<tr class="memdesc:gac6a0cf43eb7664581bd8a6954d7ff305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of lanes in a SIMD type.  <a href="a00422.html#gac6a0cf43eb7664581bd8a6954d7ff305">More...</a><br /></td></tr>
<tr class="separator:gac6a0cf43eb7664581bd8a6954d7ff305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca5433c99a350b973623f94491e43a86"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:gaca5433c99a350b973623f94491e43a86"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00422.html#gaca5433c99a350b973623f94491e43a86">Dune::Simd::lane</a> (std::size_t l, V &amp;&amp;v)</td></tr>
<tr class="memdesc:gaca5433c99a350b973623f94491e43a86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract an element of a SIMD type.  <a href="a00422.html#gaca5433c99a350b973623f94491e43a86">More...</a><br /></td></tr>
<tr class="separator:gaca5433c99a350b973623f94491e43a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5615170452d6ad3d87596cafef62f7c"><td class="memTemplParams" colspan="2">template&lt;class V , class U &gt; </td></tr>
<tr class="memitem:gab5615170452d6ad3d87596cafef62f7c"><td class="memTemplItemLeft" align="right" valign="top">constexpr V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00422.html#gab5615170452d6ad3d87596cafef62f7c">Dune::Simd::implCast</a> (U &amp;&amp;u)</td></tr>
<tr class="memdesc:gab5615170452d6ad3d87596cafef62f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast an expression from one implementation to another.  <a href="a00422.html#gab5615170452d6ad3d87596cafef62f7c">More...</a><br /></td></tr>
<tr class="separator:gab5615170452d6ad3d87596cafef62f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0d1652bc61cae3351079ca5510e8d4f"><td class="memTemplParams" colspan="2">template&lt;class V , class S &gt; </td></tr>
<tr class="memitem:gaa0d1652bc61cae3351079ca5510e8d4f"><td class="memTemplItemLeft" align="right" valign="top">constexpr V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00422.html#gaa0d1652bc61cae3351079ca5510e8d4f">Dune::Simd::broadcast</a> (S s)</td></tr>
<tr class="memdesc:gaa0d1652bc61cae3351079ca5510e8d4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast a scalar to a vector explicitly.  <a href="a00422.html#gaa0d1652bc61cae3351079ca5510e8d4f">More...</a><br /></td></tr>
<tr class="separator:gaa0d1652bc61cae3351079ca5510e8d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a04d18cec7c2f206e9de49926bfe5a8"><td class="memTemplParams" colspan="2">template&lt;class M , class V &gt; </td></tr>
<tr class="memitem:ga1a04d18cec7c2f206e9de49926bfe5a8"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00422.html#ga1a04d18cec7c2f206e9de49926bfe5a8">Dune::Simd::cond</a> (M &amp;&amp;<a class="el" href="a00422.html#ga3e3f45a22ca7244829e9adf246ac4a9d">mask</a>, const V &amp;ifTrue, const V &amp;ifFalse)</td></tr>
<tr class="memdesc:ga1a04d18cec7c2f206e9de49926bfe5a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like the ?: operator.  <a href="a00422.html#ga1a04d18cec7c2f206e9de49926bfe5a8">More...</a><br /></td></tr>
<tr class="separator:ga1a04d18cec7c2f206e9de49926bfe5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed055bc5f93bbb34cee35cdcba278b3d"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:gaed055bc5f93bbb34cee35cdcba278b3d"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00422.html#gaed055bc5f93bbb34cee35cdcba278b3d">Dune::Simd::cond</a> (bool <a class="el" href="a00422.html#ga3e3f45a22ca7244829e9adf246ac4a9d">mask</a>, const V &amp;ifTrue, const V &amp;ifFalse)</td></tr>
<tr class="memdesc:gaed055bc5f93bbb34cee35cdcba278b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like the ?: operator.  <a href="a00422.html#gaed055bc5f93bbb34cee35cdcba278b3d">More...</a><br /></td></tr>
<tr class="separator:gaed055bc5f93bbb34cee35cdcba278b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6c890aa2ed0432984358e6e0b487b3f"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:gaa6c890aa2ed0432984358e6e0b487b3f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00422.html#gaa6c890aa2ed0432984358e6e0b487b3f">Dune::Simd::max</a> (const V &amp;v1, const V &amp;v2)</td></tr>
<tr class="memdesc:gaa6c890aa2ed0432984358e6e0b487b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The binary maximum value over two simd objects.  <a href="a00422.html#gaa6c890aa2ed0432984358e6e0b487b3f">More...</a><br /></td></tr>
<tr class="separator:gaa6c890aa2ed0432984358e6e0b487b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa18ecd1517a0f3c3ae83c6a6b5e1559"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:gafa18ecd1517a0f3c3ae83c6a6b5e1559"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00422.html#gafa18ecd1517a0f3c3ae83c6a6b5e1559">Dune::Simd::min</a> (const V &amp;v1, const V &amp;v2)</td></tr>
<tr class="memdesc:gafa18ecd1517a0f3c3ae83c6a6b5e1559"><td class="mdescLeft">&#160;</td><td class="mdescRight">The binary minimum value over two simd objects.  <a href="a00422.html#gafa18ecd1517a0f3c3ae83c6a6b5e1559">More...</a><br /></td></tr>
<tr class="separator:gafa18ecd1517a0f3c3ae83c6a6b5e1559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17639369fac8b6c516ebf2125849d0f4"><td class="memTemplParams" colspan="2">template&lt;class Mask &gt; </td></tr>
<tr class="memitem:ga17639369fac8b6c516ebf2125849d0f4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00422.html#ga17639369fac8b6c516ebf2125849d0f4">Dune::Simd::anyTrue</a> (const <a class="el" href="a00422.html#gad41c8f8908cdade89370a34de31ace54">Mask</a> &amp;<a class="el" href="a00422.html#ga3e3f45a22ca7244829e9adf246ac4a9d">mask</a>)</td></tr>
<tr class="memdesc:ga17639369fac8b6c516ebf2125849d0f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether any entry is <code>true</code>  <a href="a00422.html#ga17639369fac8b6c516ebf2125849d0f4">More...</a><br /></td></tr>
<tr class="separator:ga17639369fac8b6c516ebf2125849d0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54577fa7b2752b55d6efd05878ca1e24"><td class="memTemplParams" colspan="2">template&lt;class Mask &gt; </td></tr>
<tr class="memitem:ga54577fa7b2752b55d6efd05878ca1e24"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00422.html#ga54577fa7b2752b55d6efd05878ca1e24">Dune::Simd::allTrue</a> (const <a class="el" href="a00422.html#gad41c8f8908cdade89370a34de31ace54">Mask</a> &amp;<a class="el" href="a00422.html#ga3e3f45a22ca7244829e9adf246ac4a9d">mask</a>)</td></tr>
<tr class="memdesc:ga54577fa7b2752b55d6efd05878ca1e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether all entries are <code>true</code>  <a href="a00422.html#ga54577fa7b2752b55d6efd05878ca1e24">More...</a><br /></td></tr>
<tr class="separator:ga54577fa7b2752b55d6efd05878ca1e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaee5c9c3caa23996397af767ca52845e"><td class="memTemplParams" colspan="2">template&lt;class Mask &gt; </td></tr>
<tr class="memitem:gaaee5c9c3caa23996397af767ca52845e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00422.html#gaaee5c9c3caa23996397af767ca52845e">Dune::Simd::anyFalse</a> (const <a class="el" href="a00422.html#gad41c8f8908cdade89370a34de31ace54">Mask</a> &amp;<a class="el" href="a00422.html#ga3e3f45a22ca7244829e9adf246ac4a9d">mask</a>)</td></tr>
<tr class="memdesc:gaaee5c9c3caa23996397af767ca52845e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether any entry is <code>false</code>  <a href="a00422.html#gaaee5c9c3caa23996397af767ca52845e">More...</a><br /></td></tr>
<tr class="separator:gaaee5c9c3caa23996397af767ca52845e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf404687904c5a04c3ab453b9b19c1562"><td class="memTemplParams" colspan="2">template&lt;class Mask &gt; </td></tr>
<tr class="memitem:gaf404687904c5a04c3ab453b9b19c1562"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00422.html#gaf404687904c5a04c3ab453b9b19c1562">Dune::Simd::allFalse</a> (const <a class="el" href="a00422.html#gad41c8f8908cdade89370a34de31ace54">Mask</a> &amp;<a class="el" href="a00422.html#ga3e3f45a22ca7244829e9adf246ac4a9d">mask</a>)</td></tr>
<tr class="memdesc:gaf404687904c5a04c3ab453b9b19c1562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether all entries are <code>false</code>  <a href="a00422.html#gaf404687904c5a04c3ab453b9b19c1562">More...</a><br /></td></tr>
<tr class="separator:gaf404687904c5a04c3ab453b9b19c1562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88727c2f832123b04cd014d1d6c5f746"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:ga88727c2f832123b04cd014d1d6c5f746"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00422.html#gaf7f6f3418836afcdb2c033509fd2eb91">Scalar</a>&lt; V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00422.html#ga88727c2f832123b04cd014d1d6c5f746">Dune::Simd::max</a> (const V &amp;v)</td></tr>
<tr class="memdesc:ga88727c2f832123b04cd014d1d6c5f746"><td class="mdescLeft">&#160;</td><td class="mdescRight">The horizontal maximum value over all lanes.  <a href="a00422.html#ga88727c2f832123b04cd014d1d6c5f746">More...</a><br /></td></tr>
<tr class="separator:ga88727c2f832123b04cd014d1d6c5f746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17a41b619cc1d658d70bc4b643ac778d"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:ga17a41b619cc1d658d70bc4b643ac778d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00422.html#gaf7f6f3418836afcdb2c033509fd2eb91">Scalar</a>&lt; V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00422.html#ga17a41b619cc1d658d70bc4b643ac778d">Dune::Simd::min</a> (const V &amp;v)</td></tr>
<tr class="memdesc:ga17a41b619cc1d658d70bc4b643ac778d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The horizontal minimum value over all lanes.  <a href="a00422.html#ga17a41b619cc1d658d70bc4b643ac778d">More...</a><br /></td></tr>
<tr class="separator:ga17a41b619cc1d658d70bc4b643ac778d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e3f45a22ca7244829e9adf246ac4a9d"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:ga3e3f45a22ca7244829e9adf246ac4a9d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00422.html#ga3e3f45a22ca7244829e9adf246ac4a9d">Dune::Simd::mask</a> (const V &amp;v)</td></tr>
<tr class="memdesc:ga3e3f45a22ca7244829e9adf246ac4a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to mask, analogue of bool(s) for scalars.  <a href="a00422.html#ga3e3f45a22ca7244829e9adf246ac4a9d">More...</a><br /></td></tr>
<tr class="separator:ga3e3f45a22ca7244829e9adf246ac4a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19a63bc3591ee6c8fd5706c9be4380bf"><td class="memTemplParams" colspan="2">template&lt;class V1 , class V2 &gt; </td></tr>
<tr class="memitem:ga19a63bc3591ee6c8fd5706c9be4380bf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00422.html#ga19a63bc3591ee6c8fd5706c9be4380bf">Dune::Simd::maskOr</a> (const V1 &amp;v1, const V2 &amp;v2)</td></tr>
<tr class="memdesc:ga19a63bc3591ee6c8fd5706c9be4380bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logic or of masks.  <a href="a00422.html#ga19a63bc3591ee6c8fd5706c9be4380bf">More...</a><br /></td></tr>
<tr class="separator:ga19a63bc3591ee6c8fd5706c9be4380bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf74d4b9a4722c8de326046b89e2acef7"><td class="memTemplParams" colspan="2">template&lt;class V1 , class V2 &gt; </td></tr>
<tr class="memitem:gaf74d4b9a4722c8de326046b89e2acef7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00422.html#gaf74d4b9a4722c8de326046b89e2acef7">Dune::Simd::maskAnd</a> (const V1 &amp;v1, const V2 &amp;v2)</td></tr>
<tr class="memdesc:gaf74d4b9a4722c8de326046b89e2acef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logic and of masks.  <a href="a00422.html#gaf74d4b9a4722c8de326046b89e2acef7">More...</a><br /></td></tr>
<tr class="separator:gaf74d4b9a4722c8de326046b89e2acef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Syntactic Sugar</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp5362d9b7287fe8d2b799f97b9bc57ba6"></a>Templates and functions in this group provide syntactic sugar, they are implemented using the functionality from SimdInterfaceBase, and are not customizable by implementations. </p>
</td></tr>
<tr class="memitem:gad41c8f8908cdade89370a34de31ace54"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:gad41c8f8908cdade89370a34de31ace54"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00422.html#gad41c8f8908cdade89370a34de31ace54">Dune::Simd::Mask</a> = <a class="el" href="a00422.html#ga8d4752fe47def6075b211544a932c709">Rebind</a>&lt; bool, V &gt;</td></tr>
<tr class="memdesc:gad41c8f8908cdade89370a34de31ace54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask type type of some SIMD type.  <a href="a00422.html#gad41c8f8908cdade89370a34de31ace54">More...</a><br /></td></tr>
<tr class="separator:gad41c8f8908cdade89370a34de31ace54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cb6eae7fc34d3c9258a35eb318f6e18"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:ga1cb6eae7fc34d3c9258a35eb318f6e18"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00422.html#ga1cb6eae7fc34d3c9258a35eb318f6e18">Dune::Simd::lanes</a> (const V &amp;)</td></tr>
<tr class="memdesc:ga1cb6eae7fc34d3c9258a35eb318f6e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of lanes in a SIMD type.  <a href="a00422.html#ga1cb6eae7fc34d3c9258a35eb318f6e18">More...</a><br /></td></tr>
<tr class="separator:ga1cb6eae7fc34d3c9258a35eb318f6e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">IO interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpb32d0f80280d88188e355b4690d000aa"></a>Templates and functions in this group provide syntactic sugar for IO. They are implemented using the functionality from SimdInterfaceBase, and are not customizable by implementations. </p>
</td></tr>
<tr class="memitem:ga5f024733517533308b22bd0b9a5e0820"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:ga5f024733517533308b22bd0b9a5e0820"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00422.html#ga5f024733517533308b22bd0b9a5e0820">Dune::Simd::vio</a> (const V &amp;v)</td></tr>
<tr class="memdesc:ga5f024733517533308b22bd0b9a5e0820"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct a stream inserter  <a href="a00422.html#ga5f024733517533308b22bd0b9a5e0820">More...</a><br /></td></tr>
<tr class="separator:ga5f024733517533308b22bd0b9a5e0820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47000d8c79bf7ab0548867bc01a56cac"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:ga47000d8c79bf7ab0548867bc01a56cac"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00422.html#ga47000d8c79bf7ab0548867bc01a56cac">Dune::Simd::io</a> (const V &amp;v)</td></tr>
<tr class="memdesc:ga47000d8c79bf7ab0548867bc01a56cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct a stream inserter  <a href="a00422.html#ga47000d8c79bf7ab0548867bc01a56cac">More...</a><br /></td></tr>
<tr class="separator:ga47000d8c79bf7ab0548867bc01a56cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>How to support vectorization in <a class="el" href="a00428.html" title="Dune namespace.">Dune</a> classes. </p>
<p>This module describes how a <a class="el" href="a00428.html" title="Dune namespace.">Dune</a> library developer can add support for vectorization to library facilities.</p>
<h1><a class="anchor" id="understand_simd"></a>
Understanding SIMD types</h1>
<p>The (idealized) model of a SIMD type <code>V</code> used in this abstraction layer is that they are fixed-length vectors of some scalar type <code>S</code>. Operations and operators that take values of type <code>S</code> as arguments, except for <code>operator,()</code>, should be overloaded to support values of type <code>V</code> too. These operations should apply element-wise. If the operation takes more than one argument, it should accept arbitrary combinations of <code>V</code> and <code>S</code>. The exception is the combination of <code>S</code> on the left hand side and <code>V</code> on the right hand side of one of the assignment operators, which does not make sense.</p>
<p>The result of a boolean operation is a mask type <code>M</code>, which is a SIMD type with scalar type <code>bool</code> with the same number of elements as <code>V</code>. The result of all other operations is again of type <code>V</code>, or of some type convertible to <code>V</code>.</p>
<p>This is very similar to <code>std::valarray</code>, with the main difference being that <code>std::valarray</code> is dynamic in size, while for this abstraction the size is static.</p>
<h1><a class="anchor" id="SIMDLibPromoWarn"></a>
Type promotion issues</h1>
<p>True SIMD types have an issue with type promotion, which means they cannot behave completely analogous to built-in integral types (this is a non-issue with floating point types). Essentially, operations on true SIMD types cannot promote their arguments, because the promoted types typically require more storage than the original types, meaning an argument that was passed in a single vector register would need multiple vector registers after promotion, which would mean greater register pressure. Also, there would be conversion operations required, which (at least on x86) is not typically the case for promotions of the built-in types. Lastly, with larger types the vector units can typically operate on fewer lanes at a time.</p>
<p>Omitting integral promotions has in many cases no negative impact, because many programmers do not really expect them anyway. There are however cases where they matter, and for illustration I want to explain one that crept up during unit testing.</p>
<p>Here is a simplified (and somewhat pseudo-code) version of the test. The test checks the result of unary <code>-</code> on <code>Vc::Vector&lt;unsigned short&gt;</code> by comparing the result of unary <code>-</code> when applied to the complete vector to the result of unary <code>-</code> when applied to each lane individually. </p><div class="fragment"><div class="line">Vc::Vector&lt;unsigned short&gt; varg;</div>
<div class="line"><span class="keywordflow">for</span>(std::size_t l = 0; l &lt; <a class="code" href="a00422.html#gac6a0cf43eb7664581bd8a6954d7ff305">lanes</a>(varg); ++l)</div>
<div class="line">  <a class="code" href="a00422.html#gaca5433c99a350b973623f94491e43a86">lane</a>(l, varg) = l + 1;</div>
<div class="line"><span class="keyword">auto</span> vresult = -varg;</div>
<div class="line"><span class="keywordflow">for</span>(std::size_t l = 0; l &lt; <a class="code" href="a00422.html#gac6a0cf43eb7664581bd8a6954d7ff305">lanes</a>(varg); ++l)</div>
<div class="line">  assert(<a class="code" href="a00422.html#gaca5433c99a350b973623f94491e43a86">lane</a>(l, vresult) == -<a class="code" href="a00422.html#gaca5433c99a350b973623f94491e43a86">lane</a>(l, varg));</div>
<div class="ttc" id="aa00422_html_gac6a0cf43eb7664581bd8a6954d7ff305"><div class="ttname"><a href="a00422.html#gac6a0cf43eb7664581bd8a6954d7ff305">Dune::Simd::lanes</a></div><div class="ttdeci">constexpr std::size_t lanes()</div><div class="ttdoc">Number of lanes in a SIMD type.</div><div class="ttdef"><b>Definition:</b> simd/interface.hh:303</div></div>
<div class="ttc" id="aa00422_html_gaca5433c99a350b973623f94491e43a86"><div class="ttname"><a href="a00422.html#gaca5433c99a350b973623f94491e43a86">Dune::Simd::lane</a></div><div class="ttdeci">decltype(auto) lane(std::size_t l, V &amp;&amp;v)</div><div class="ttdoc">Extract an element of a SIMD type.</div><div class="ttdef"><b>Definition:</b> simd/interface.hh:322</div></div>
</div><!-- fragment --><p> The test fails in lane 0. On the left side of the <code>==</code>, <code>lane(0, vresult)</code> is <code>(unsigned short)65535</code>, which is the same as <code>(unsigned short)-1</code>, as it should be. On the right side, <code>lane(0, varg)</code> is <code>(unsigned short)1</code>. <code>-</code> promotes its argument, so that becomes <code>(int)1</code>, and the result of the negation is <code>(int)-1</code>.</p>
<p>Now the comparison is <code>(unsigned short)65535 == (int)-1</code>. The comparison operator applies the <em>usual arithmetic conversions</em> to bring both operands to the same type. In this case this boils down to converting the left side to <code>int</code> via integral promotions and the comparison becomes <code>(int)65535 == (int)-1</code>. The result is of course <code>false</code> and the assertion triggers.</p>
<p>The only way to thoroughly prevent this kind of problem is to convert the result of any operation back to the expected type. In the above example, the assertion would need to be written as <code>assert(lane(l, vresult) == static_cast&lt;unsigned short&gt;(-lane(l, varg)));</code>. In practice, this should only be a problem with operations on unsigned types where the result may be "negative". Most code in <a class="el" href="a00428.html" title="Dune namespace.">Dune</a> will want to operate on floating point types, where this is a non-issue.</p>
<p>(Of couse, this is also a problem for code that operates on untrusted input, but you should not be doing that with <a class="el" href="a00428.html" title="Dune namespace.">Dune</a> anyway).</p>
<p>Still, when writing code using the SIMD abstractions, you should be aware that in the following snippet </p><div class="fragment"><div class="line"><span class="keyword">auto</span> var1 = <a class="code" href="a00422.html#gaca5433c99a350b973623f94491e43a86">lane</a>(0, -vec);</div>
<div class="line"><span class="keyword">auto</span> var2 = -<a class="code" href="a00422.html#gaca5433c99a350b973623f94491e43a86">lane</a>(0, vec);</div>
</div><!-- fragment --><p> the exact types of <code>var1</code> and <code>var2</code> may be somewhat surprising.</p>
<h1><a class="anchor" id="simd_abstraction_limit"></a>
Limitations of the Abstraction Layer</h1>
<p>Since the abstraction layer cannot overload operators of SIMD types (that would be meddling with the domain of the library that provides the SIMD types), nor provide it's own constructors, there are severe limitations in what the abstraction layer guarantees. Besides the standard types, the first SIMD library supported is Vc, so that is where most of the limitations stem from; see <a class="el" href="a00425.html#SIMDVcRestrictions">Restrictions</a> in <a class="el" href="a00425.html">SIMD Abstraction Implementation for Vc</a>.</p>
<p>The biggest limitations are with masks. In Vc masks support a very restricted set of operations compared to other SIMD types, so in what follows we will distinguish between masks with a very small set of operations and between vectors with a larger set of operations.</p>
<p>Here is a compact table of the limitations as a quick reference, together with suggested workarounds for the constructs that don't work. <code>s</code> denotes a scalar object/expression (i.e. of type <code>double</code> or in the case of masks <code>bool</code>). <code>v</code> denotes a vector/mask object/expression. <code>sv</code> means that both scalar and vector arguments are accepted. <code>V</code> denotes a vector/mask type. <code>@</code> means any applicable operator that is not otherwise listed.</p>
<div class="fragment"><div class="line">|                         | Vectors | workaround                 | Masks       | workaround       |</div>
<div class="line">|-------------------------+---------+----------------------------+-------------+------------------|</div>
<div class="line">| V v(s);                 | y       |                            | y           |                  |</div>
<div class="line">| V v = s;                | y       | V v(s);                    | *N*         | V v(s);          |</div>
<div class="line">| V v{s};                 | *N*     | V v(s);                    | y           | V v(s);          |</div>
<div class="line">| V v = {s};              | *N*     | V v(s);                    | y           | V v(s);          |</div>
<div class="line">|-------------------------+---------+----------------------------+-------------+------------------|</div>
<div class="line">| v = s;                  | y       | v = V(s);                  | *N*         | v = V(s);        |</div>
<div class="line">| v = {s};                | *N*     | v = V(s);                  | *N*         | v = V(s);        |</div>
<div class="line">|-------------------------+---------+----------------------------+-------------+------------------|</div>
<div class="line">| v++; ++v;               | *N*     | v += Scalar&lt;V&gt;(1);         | *N*(n/a)[2] | v = V(<span class="keyword">true</span>);     |</div>
<div class="line">| v--; --v;               | *N*     | v -= Scalar&lt;V&gt;(1);         | n/a         |                  |</div>
<div class="line">|-------------------------+---------+----------------------------+-------------+------------------|</div>
<div class="line">| +v; -v;                 | y       |                            | *N*         | none             |</div>
<div class="line">| !v;                     | y       |                            | y           |                  |</div>
<div class="line">| ~v;                     | y       |                            | *N*         | none             |</div>
<div class="line">|-------------------------+---------+----------------------------+-------------+------------------|</div>
<div class="line">| sv @ sv; but see below  | y       |                            | *N*         | none             |</div>
<div class="line">|-------------------------+---------+----------------------------+-------------+------------------|</div>
<div class="line">| s &lt;&lt; v; s &gt;&gt; v;         | *N*     | v &lt;&lt; V(s);                 | *N*         | none             |</div>
<div class="line">|-------------------------+---------+----------------------------+-------------+------------------|</div>
<div class="line">| v == v; v != v;         | y       |                            | *N* [1]     | !(v ^ v); v ^ v; |</div>
<div class="line">|-------------------------+---------+----------------------------+-------------+------------------|</div>
<div class="line">| v &amp; v; v ^ v; v ¦ v;    | y       |                            | y           |                  |</div>
<div class="line">| v &amp;&amp; v; v ¦¦ v;         | *N*     | <a class="code" href="a00422.html#gaf74d4b9a4722c8de326046b89e2acef7">maskAnd</a>(v,v); <a class="code" href="a00422.html#ga19a63bc3591ee6c8fd5706c9be4380bf">maskOr</a>(v,v); | y           |                  |</div>
<div class="line">|-------------------------+---------+----------------------------+-------------+------------------|</div>
<div class="line">| v @= sv; but see below  | y       |                            | *N*         | none             |</div>
<div class="line">| v &amp;= v; v ^= v; v ¦= v; | y       |                            | y           |                  |</div>
<div class="line">|-------------------------+---------+----------------------------+-------------+------------------|</div>
<div class="line">| v, v;[3,4]              | *N*     | void(v), v;                | y           |                  |</div>
<div class="ttc" id="aa00422_html_ga19a63bc3591ee6c8fd5706c9be4380bf"><div class="ttname"><a href="a00422.html#ga19a63bc3591ee6c8fd5706c9be4380bf">Dune::Simd::maskOr</a></div><div class="ttdeci">auto maskOr(const V1 &amp;v1, const V2 &amp;v2)</div><div class="ttdoc">Logic or of masks.</div><div class="ttdef"><b>Definition:</b> simd/interface.hh:497</div></div>
<div class="ttc" id="aa00422_html_gaf74d4b9a4722c8de326046b89e2acef7"><div class="ttname"><a href="a00422.html#gaf74d4b9a4722c8de326046b89e2acef7">Dune::Simd::maskAnd</a></div><div class="ttdeci">auto maskAnd(const V1 &amp;v1, const V2 &amp;v2)</div><div class="ttdoc">Logic and of masks.</div><div class="ttdef"><b>Definition:</b> simd/interface.hh:507</div></div>
</div><!-- fragment --><p>Notes:</p>
<ul>
<li>[1] In Vc, mask-mask <code>==</code> and <code>!=</code> operations exist, but the result is of type <code>bool</code>, i.e. a scalar.</li>
<li>[2] <code>++</code> (either kind) on bools is deprecated by the standard. Our test suite does not check for it on masks, but it was supported by Vc masks at some point.</li>
<li>[3] Contrary to the other operators, the expected result for <code>(sv1, sv2)</code> is exactly <code>sv2</code>, no broadcasting applied.</li>
<li>[4] Try to avoid the use of <code>operator,</code> unless both operands are built-in types if possible. Libraries had a tendency to overload <code>operator,</code> to provide for things like container initialization before C++11, and these overloads may still be present in the library you are using and replace the default meaning of <code>operator,</code>.</li>
</ul>
<p>Support levels:</p>
<ul>
<li><code>y</code>: operation generally works; some instances of the operation may not apply</li>
<li><code>*N*</code>: operation generally does not work; some instances of the operation may not apply</li>
<li><code>n/a</code>: operation does not apply (i.e. bitwise operations to floating-point operands, <code>--</code> (and in the future possibly <code>++</code>) to boolean operands, assignment operators to scalar left hand sides) </li>
</ul>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gad41c8f8908cdade89370a34de31ace54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad41c8f8908cdade89370a34de31ace54">&#9670;&nbsp;</a></span>Mask</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00422.html#gad41c8f8908cdade89370a34de31ace54">Dune::Simd::Mask</a> = typedef <a class="el" href="a00422.html#ga8d4752fe47def6075b211544a932c709">Rebind</a>&lt;bool, V&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mask type type of some SIMD type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>The SIMD (mask or vector) type. <code>const</code>, <code>volatile</code> or reference qualifiers are automatically ignored.</td></tr>
  </table>
  </dd>
</dl>
<p>The mask type is kind of a SIMD vector of <code>bool</code> with the same number of lanes as <code>V</code>. It results from comparison operations between values of type <code>V</code>. It is only "kind of" a SIMD vector, because the guaranteed supported operations are extremely limited. <a class="el" href="a03024.html" title="Reverse element access.">At</a> the moment only the logical operators <code>&amp;&amp;</code>, <code>||</code> and <code>!</code> and the "bitwise" operators <code>&amp;</code>, <code>^</code> and <code>|</code> between masks are supported, and even with those operators you cannot rely on automatic broadcasting of <code>bool</code> values.</p>
<dl class="section note"><dt>Note</dt><dd>In particular, masks do not support comparison. As a workaround you can use <code>^</code> instead of <code>!=</code> and <code>!(m1 ^ m2)</code> instead of <code>m1 == m2</code>. (The reason why comparison is not supported is because in Vc <code>==</code> and <code>!=</code> between masks yield a single <code>bool</code> result and not a mask.)</dd></dl>
<p>This is an alias for <code>Rebind&lt;bool, V&gt;</code>. </p>

</div>
</div>
<a id="ga8d4752fe47def6075b211544a932c709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d4752fe47def6075b211544a932c709">&#9670;&nbsp;</a></span>Rebind</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S , class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00422.html#ga8d4752fe47def6075b211544a932c709">Dune::Simd::Rebind</a> = typedef typename <a class="el" href="a02560.html">Overloads::RebindType</a>&lt;std::decay_t&lt;S&gt;, std::decay_t&lt;V&gt; &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct SIMD type with different scalar type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>The new scalar type </td></tr>
    <tr><td class="paramname">V</td><td>The SIMD (mask or vector) type.</td></tr>
  </table>
  </dd>
</dl>
<p>The resulting type a SIMD vector of <code>S</code> with the same number of lanes as <code>V</code>. <code>const</code>, <code>volatile</code> or reference qualifiers in <code>S</code> and <code>V</code> are automatically ignored, and the result will have no such qualifiers.</p>
<p>Implementations shall rebind to <code><a class="el" href="a02572.html">LoopSIMD</a>&lt;S, lanes&lt;V&gt;()&gt;</code> if they can't support a particular rebind natively.</p>
<p>Implemented by <code><a class="el" href="a02560.html" title="should have a member type type">Overloads::RebindType</a></code>. </p>

</div>
</div>
<a id="gaf7f6f3418836afcdb2c033509fd2eb91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7f6f3418836afcdb2c033509fd2eb91">&#9670;&nbsp;</a></span>Scalar</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00422.html#gaf7f6f3418836afcdb2c033509fd2eb91">Dune::Simd::Scalar</a> = typedef typename <a class="el" href="a02556.html">Overloads::ScalarType</a>&lt;std::decay_t&lt;V&gt; &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element type of some SIMD type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>The SIMD (mask or vector) type. <code>const</code>, <code>volatile</code> or reference qualifiers are automatically ignored.</td></tr>
  </table>
  </dd>
</dl>
<p>Not all operations that access the element of a vector return (a reference to) the scalar type &ndash; some may return proxy objects instead. Use <code><a class="el" href="a00409.html#gab256c9245e4037f7f42aa453e00fd97a" title="Autonomous copy of an expression&#39;s value for use in auto type deduction.">autoCopy()</a></code> to make sure you are getting a prvalue of the scalar type.</p>
<p>Implemented by <code><a class="el" href="a02556.html" title="should have a member type type">Overloads::ScalarType</a></code>. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf404687904c5a04c3ab453b9b19c1562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf404687904c5a04c3ab453b9b19c1562">&#9670;&nbsp;</a></span>allFalse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Mask &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Dune::Simd::allFalse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00422.html#gad41c8f8908cdade89370a34de31ace54">Mask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether all entries are <code>false</code> </p>
<p>Implemented by <code><a class="el" href="a00423.html#ga537e92d4cfd4637707852c7f93c73c74" title="implements Simd::allFalse()">Overloads::allFalse()</a></code>. </p>

</div>
</div>
<a id="ga54577fa7b2752b55d6efd05878ca1e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54577fa7b2752b55d6efd05878ca1e24">&#9670;&nbsp;</a></span>allTrue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Mask &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Dune::Simd::allTrue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00422.html#gad41c8f8908cdade89370a34de31ace54">Mask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether all entries are <code>true</code> </p>
<p>Implemented by <code><a class="el" href="a00423.html#ga6850149b7bbe8eff67835ecfd8471f7d" title="implements Simd::allTrue()">Overloads::allTrue()</a></code>. </p>

</div>
</div>
<a id="gaaee5c9c3caa23996397af767ca52845e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaee5c9c3caa23996397af767ca52845e">&#9670;&nbsp;</a></span>anyFalse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Mask &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Dune::Simd::anyFalse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00422.html#gad41c8f8908cdade89370a34de31ace54">Mask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether any entry is <code>false</code> </p>
<p>Implemented by <code><a class="el" href="a00423.html#gaa272813526339482ae077b1a0e52a01e" title="implements Simd::anyFalse()">Overloads::anyFalse()</a></code>. </p>

</div>
</div>
<a id="ga17639369fac8b6c516ebf2125849d0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17639369fac8b6c516ebf2125849d0f4">&#9670;&nbsp;</a></span>anyTrue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Mask &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Dune::Simd::anyTrue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00422.html#gad41c8f8908cdade89370a34de31ace54">Mask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether any entry is <code>true</code> </p>
<p>Implemented by <code><a class="el" href="a00433.html#a19296f860eb9fda0a58ab8c43747370d">Overloads::anyTrue()</a></code>. </p>

</div>
</div>
<a id="gaa0d1652bc61cae3351079ca5510e8d4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0d1652bc61cae3351079ca5510e8d4f">&#9670;&nbsp;</a></span>broadcast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr V Dune::Simd::broadcast </td>
          <td>(</td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Broadcast a scalar to a vector explicitly. </p>
<p>Implemented by <code><a class="el" href="a00423.html#gac82cb295f767f7aece888fd9216db1b3" title="implements Simd::broadcast&lt;V&gt;()">Overloads::broadcast()</a></code></p>
<p>This is useful because the syntax for broadcasting can vary wildly between implementations.</p>
<dl class="section note"><dt>Note</dt><dd>One of the few functions that explicitly take a template argument (<code>V</code> in this case). </dd></dl>

</div>
</div>
<a id="gaed055bc5f93bbb34cee35cdcba278b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed055bc5f93bbb34cee35cdcba278b3d">&#9670;&nbsp;</a></span>cond() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V Dune::Simd::cond </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>ifTrue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>ifFalse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like the ?: operator. </p>
<p>Overload for plain bool masks, accepting any simd type</p>
<p>Implemented by <code><a class="el" href="a00433.html#a29d26ea99826519efddbd223d5b5da59">Overloads::cond()</a></code>. </p>

</div>
</div>
<a id="ga1a04d18cec7c2f206e9de49926bfe5a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a04d18cec7c2f206e9de49926bfe5a8">&#9670;&nbsp;</a></span>cond() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V Dune::Simd::cond </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>ifTrue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>ifFalse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like the ?: operator. </p>
<p>Equivalent to </p><div class="fragment"><div class="line">V result;</div>
<div class="line"><span class="keywordflow">for</span>(std::size_t l = 0; l &lt; <a class="code" href="a00422.html#gac6a0cf43eb7664581bd8a6954d7ff305">lanes</a>(<a class="code" href="a00422.html#ga3e3f45a22ca7244829e9adf246ac4a9d">mask</a>); ++l)</div>
<div class="line">  <a class="code" href="a00422.html#gaca5433c99a350b973623f94491e43a86">lane</a>(l, result) =</div>
<div class="line">    ( <a class="code" href="a00422.html#gaca5433c99a350b973623f94491e43a86">lane</a>(l, <a class="code" href="a00422.html#ga3e3f45a22ca7244829e9adf246ac4a9d">mask</a>) ? <a class="code" href="a00422.html#gaca5433c99a350b973623f94491e43a86">lane</a>(l, ifTrue) : <a class="code" href="a00422.html#gaca5433c99a350b973623f94491e43a86">lane</a>(l ifFalse) );</div>
<div class="line"><span class="keywordflow">return</span> result;</div>
<div class="ttc" id="aa00422_html_ga3e3f45a22ca7244829e9adf246ac4a9d"><div class="ttname"><a href="a00422.html#ga3e3f45a22ca7244829e9adf246ac4a9d">Dune::Simd::mask</a></div><div class="ttdeci">auto mask(const V &amp;v)</div><div class="ttdoc">Convert to mask, analogue of bool(s) for scalars.</div><div class="ttdef"><b>Definition:</b> simd/interface.hh:487</div></div>
</div><!-- fragment --><p>Implemented by <code><a class="el" href="a00433.html#a29d26ea99826519efddbd223d5b5da59">Overloads::cond()</a></code>. </p>

</div>
</div>
<a id="gab5615170452d6ad3d87596cafef62f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5615170452d6ad3d87596cafef62f7c">&#9670;&nbsp;</a></span>implCast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr V Dune::Simd::implCast </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast an expression from one implementation to another. </p>
<p>Implemented by <code><a class="el" href="a00423.html#ga2d92cc23bb0b95ca627fa2560c2f9006" title="implements Simd::implCast&lt;V&gt;(V)">Overloads::implCast()</a></code></p>
<p>Requires the scalar type and the number of lanes to match exactly.</p>
<p>This is particularly useful for masks, which often know the type they were derived from. This can become a problem when doing a conditional operation e.g. on some floating point vector type, but with a mask derived from some index vector type.</p>
<dl class="section note"><dt>Note</dt><dd>One of the few functions that explicitly take a template argument (<code>V</code> in this case). </dd></dl>

</div>
</div>
<a id="ga47000d8c79bf7ab0548867bc01a56cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47000d8c79bf7ab0548867bc01a56cac">&#9670;&nbsp;</a></span>io()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Dune::Simd::io </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>construct a stream inserter </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>The SIMD (mask or vector) type.</td></tr>
  </table>
  </dd>
</dl>
<p>Construct an object that can be inserted into an output stream. For one-lane vectors, behaves the same as scalar insertion. For multi-lane vectors, behaves as the inserter returned by <code><a class="el" href="a00422.html#ga5f024733517533308b22bd0b9a5e0820" title="construct a stream inserter">vio()</a></code>: insertion prints the vector values separated by a comma and a space, and surrounded by angular brackets. </p>

</div>
</div>
<a id="gaca5433c99a350b973623f94491e43a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca5433c99a350b973623f94491e43a86">&#9670;&nbsp;</a></span>lane()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) Dune::Simd::lane </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract an element of a SIMD type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>Number of lane to extract </td></tr>
    <tr><td class="paramname">v</td><td>SIMD object to extract from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <code>v</code> is a non-<code>const</code> lvalue, a reference <code>Scalar&lt;decay_t&lt;V&gt;&gt;&amp;</code>, or a proxy object through which the element of <code>v</code> may be modified. Overwise, <code>v</code> is a <code>const</code> lvalue or an rvalue, and the result is a prvalue (a temporary) of type <code>Scalar&lt;decay_t&lt;V&gt;&gt;</code>.</dd></dl>
<p>Implemented by <code><a class="el" href="a00433.html#a296f66754aaa4414985e2a8c6ded7527">Overloads::lane()</a></code>. </p>

</div>
</div>
<a id="gac6a0cf43eb7664581bd8a6954d7ff305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6a0cf43eb7664581bd8a6954d7ff305">&#9670;&nbsp;</a></span>lanes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t Dune::Simd::lanes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of lanes in a SIMD type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>The SIMD (mask or vector) type. <code>const</code>, <code>volatile</code> or reference qualifiers are automatically ignored.</td></tr>
  </table>
  </dd>
</dl>
<p>Implemented by <code><a class="el" href="a02564.html" title="should be derived from a Dune::index_constant">Overloads::LaneCount</a></code>. </p>

</div>
</div>
<a id="ga1cb6eae7fc34d3c9258a35eb318f6e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cb6eae7fc34d3c9258a35eb318f6e18">&#9670;&nbsp;</a></span>lanes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Dune::Simd::lanes </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of lanes in a SIMD type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>The SIMD (mask or vector) type.</td></tr>
  </table>
  </dd>
</dl>
<p>The value of the parameter is ignored; the call is simply forwarded to <code>lanes&lt;V&gt;()</code>. </p>

</div>
</div>
<a id="ga3e3f45a22ca7244829e9adf246ac4a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e3f45a22ca7244829e9adf246ac4a9d">&#9670;&nbsp;</a></span>mask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Dune::Simd::mask </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to mask, analogue of bool(s) for scalars. </p>
<p>Implemented by <code><a class="el" href="a00423.html#ga739860dc7b3d5e5bffd0af618aa07f20" title="implements Simd::mask()">Overloads::mask()</a></code>. </p>

</div>
</div>
<a id="gaf74d4b9a4722c8de326046b89e2acef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf74d4b9a4722c8de326046b89e2acef7">&#9670;&nbsp;</a></span>maskAnd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Dune::Simd::maskAnd </td>
          <td>(</td>
          <td class="paramtype">const V1 &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V2 &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logic and of masks. </p>
<p>Implemented by <code><a class="el" href="a00423.html#ga77595bdf5b1cfe2377baa16cc52b1cee" title="implements Simd::maskAnd()">Overloads::maskAnd()</a></code>. </p>

</div>
</div>
<a id="ga19a63bc3591ee6c8fd5706c9be4380bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19a63bc3591ee6c8fd5706c9be4380bf">&#9670;&nbsp;</a></span>maskOr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V1 , class V2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Dune::Simd::maskOr </td>
          <td>(</td>
          <td class="paramtype">const V1 &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V2 &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logic or of masks. </p>
<p>Implemented by <code><a class="el" href="a00423.html#ga8ae87f60e149f0ab44b71fc6624da25d" title="implements Simd::maskOr()">Overloads::maskOr()</a></code>. </p>

</div>
</div>
<a id="ga88727c2f832123b04cd014d1d6c5f746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88727c2f832123b04cd014d1d6c5f746">&#9670;&nbsp;</a></span>max() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00422.html#gaf7f6f3418836afcdb2c033509fd2eb91">Scalar</a>&lt;V&gt; Dune::Simd::max </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The horizontal maximum value over all lanes. </p>
<p>Implemented by <code><a class="el" href="a00423.html#gafb35651a7a1777d932462357552bb90c" title="implements binary Simd::max()">Overloads::max()</a></code>. </p>

</div>
</div>
<a id="gaa6c890aa2ed0432984358e6e0b487b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6c890aa2ed0432984358e6e0b487b3f">&#9670;&nbsp;</a></span>max() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Dune::Simd::max </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The binary maximum value over two simd objects. </p>
<p>Implemented by <code><a class="el" href="a00423.html#gafb35651a7a1777d932462357552bb90c" title="implements binary Simd::max()">Overloads::max()</a></code>. </p>

</div>
</div>
<a id="ga17a41b619cc1d658d70bc4b643ac778d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17a41b619cc1d658d70bc4b643ac778d">&#9670;&nbsp;</a></span>min() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00422.html#gaf7f6f3418836afcdb2c033509fd2eb91">Scalar</a>&lt;V&gt; Dune::Simd::min </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The horizontal minimum value over all lanes. </p>
<p>Implemented by <code><a class="el" href="a00423.html#gab9dde84db30133b70a28c0b89399bc71" title="implements binary Simd::min()">Overloads::min()</a></code>. </p>

</div>
</div>
<a id="gafa18ecd1517a0f3c3ae83c6a6b5e1559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa18ecd1517a0f3c3ae83c6a6b5e1559">&#9670;&nbsp;</a></span>min() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Dune::Simd::min </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The binary minimum value over two simd objects. </p>
<p>Implemented by <code><a class="el" href="a00423.html#gab9dde84db30133b70a28c0b89399bc71" title="implements binary Simd::min()">Overloads::min()</a></code>. </p>

</div>
</div>
<a id="ga5f024733517533308b22bd0b9a5e0820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f024733517533308b22bd0b9a5e0820">&#9670;&nbsp;</a></span>vio()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Dune::Simd::vio </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>construct a stream inserter </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>The SIMD (mask or vector) type.</td></tr>
  </table>
  </dd>
</dl>
<p>Construct an object that can be inserted into an output stream. Insertion prints the vector values separated by a comma and a space, and surrounded by angular brackets. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
