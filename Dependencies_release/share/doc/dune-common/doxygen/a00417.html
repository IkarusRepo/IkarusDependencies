<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>dune-common: Iterator facades</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">dune-common
   &#160;<span id="projectnumber">2.8.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Iterator facades<div class="ingroups"><a class="el" href="a00400.html">Common</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Iterator facades for writing stl conformant iterators.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Iterator facades:</div>
<div class="dyncontent">
<div class="center"><img src="a00417.png" border="0" usemap="#aa00417" alt=""/></div>
<map name="aa00417" id="aa00417">
<area shape="rect" href="a00400.html" title="foundation classes" alt="" coords="5,5,80,31"/>
<area shape="rect" title="Iterator facades for writing stl conformant iterators." alt="" coords="128,5,239,31"/>
<area shape="rect" href="a00416.html" title="Generic Iterator class for writing stl conformant iterators for any container class with operator[]." alt="" coords="287,5,393,31"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:a00416"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00416.html">GenericIterator</a></td></tr>
<tr class="memdesc:a00416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic Iterator class for writing stl conformant iterators for any container class with operator[]. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01873.html">Dune::ForwardIteratorFacade&lt; T, V, R, D &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for stl conformant forward iterators.  <a href="a01873.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01877.html">Dune::BidirectionalIteratorFacade&lt; T, V, R, D &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Facade class for stl conformant bidirectional iterators.  <a href="a01877.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01881.html">Dune::RandomAccessIteratorFacade&lt; T, V, R, D &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for stl conformant forward iterators.  <a href="a01881.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad89f7fc265d9bd63c5b5a8da6748d8af"><td class="memTemplParams" colspan="2">template&lt;class T1 , class V1 , class R1 , class D , class T2 , class V2 , class R2 &gt; </td></tr>
<tr class="memitem:gad89f7fc265d9bd63c5b5a8da6748d8af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a03065.html">EnableIfInterOperable</a>&lt; T1, T2, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00417.html#gad89f7fc265d9bd63c5b5a8da6748d8af">Dune::operator==</a> (const <a class="el" href="a01873.html">ForwardIteratorFacade</a>&lt; T1, V1, R1, D &gt; &amp;lhs, const <a class="el" href="a01873.html">ForwardIteratorFacade</a>&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gad89f7fc265d9bd63c5b5a8da6748d8af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for equality.  <a href="a00417.html#gad89f7fc265d9bd63c5b5a8da6748d8af">More...</a><br /></td></tr>
<tr class="separator:gad89f7fc265d9bd63c5b5a8da6748d8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1369bc3ae1876892c6567eff7987620f"><td class="memTemplParams" colspan="2">template&lt;class T1 , class V1 , class R1 , class D , class T2 , class V2 , class R2 &gt; </td></tr>
<tr class="memitem:ga1369bc3ae1876892c6567eff7987620f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a03065.html">EnableIfInterOperable</a>&lt; T1, T2, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00417.html#ga1369bc3ae1876892c6567eff7987620f">Dune::operator!=</a> (const <a class="el" href="a01873.html">ForwardIteratorFacade</a>&lt; T1, V1, R1, D &gt; &amp;lhs, const <a class="el" href="a01873.html">ForwardIteratorFacade</a>&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1369bc3ae1876892c6567eff7987620f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for inequality.  <a href="a00417.html#ga1369bc3ae1876892c6567eff7987620f">More...</a><br /></td></tr>
<tr class="separator:ga1369bc3ae1876892c6567eff7987620f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a147b2ec114b90e57366216029b40bc"><td class="memTemplParams" colspan="2">template&lt;class T1 , class V1 , class R1 , class D , class T2 , class V2 , class R2 &gt; </td></tr>
<tr class="memitem:ga0a147b2ec114b90e57366216029b40bc"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_convertible&lt; T2, T1 &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00417.html#ga0a147b2ec114b90e57366216029b40bc">Dune::operator==</a> (const <a class="el" href="a01877.html">BidirectionalIteratorFacade</a>&lt; T1, V1, R1, D &gt; &amp;lhs, const <a class="el" href="a01877.html">BidirectionalIteratorFacade</a>&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga0a147b2ec114b90e57366216029b40bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for equality.  <a href="a00417.html#ga0a147b2ec114b90e57366216029b40bc">More...</a><br /></td></tr>
<tr class="separator:ga0a147b2ec114b90e57366216029b40bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace8cd0fee28b999a64ce7a75ca582cae"><td class="memTemplParams" colspan="2">template&lt;class T1 , class V1 , class R1 , class D , class T2 , class V2 , class R2 &gt; </td></tr>
<tr class="memitem:gace8cd0fee28b999a64ce7a75ca582cae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a03065.html">EnableIfInterOperable</a>&lt; T1, T2, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00417.html#gace8cd0fee28b999a64ce7a75ca582cae">Dune::operator!=</a> (const <a class="el" href="a01877.html">BidirectionalIteratorFacade</a>&lt; T1, V1, R1, D &gt; &amp;lhs, const <a class="el" href="a01877.html">BidirectionalIteratorFacade</a>&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gace8cd0fee28b999a64ce7a75ca582cae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for inequality.  <a href="a00417.html#gace8cd0fee28b999a64ce7a75ca582cae">More...</a><br /></td></tr>
<tr class="separator:gace8cd0fee28b999a64ce7a75ca582cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga639a6e346454c1d6635f21ea15af4032"><td class="memTemplParams" colspan="2">template&lt;class T1 , class V1 , class R1 , class D , class T2 , class V2 , class R2 &gt; </td></tr>
<tr class="memitem:ga639a6e346454c1d6635f21ea15af4032"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a03065.html">EnableIfInterOperable</a>&lt; T1, T2, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00417.html#ga639a6e346454c1d6635f21ea15af4032">Dune::operator==</a> (const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T1, V1, R1, D &gt; &amp;lhs, const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga639a6e346454c1d6635f21ea15af4032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for equality.  <a href="a00417.html#ga639a6e346454c1d6635f21ea15af4032">More...</a><br /></td></tr>
<tr class="separator:ga639a6e346454c1d6635f21ea15af4032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78d64b70022a4945cb797908fb3f6d65"><td class="memTemplParams" colspan="2">template&lt;class T1 , class V1 , class R1 , class D , class T2 , class V2 , class R2 &gt; </td></tr>
<tr class="memitem:ga78d64b70022a4945cb797908fb3f6d65"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a03065.html">EnableIfInterOperable</a>&lt; T1, T2, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00417.html#ga78d64b70022a4945cb797908fb3f6d65">Dune::operator!=</a> (const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T1, V1, R1, D &gt; &amp;lhs, const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga78d64b70022a4945cb797908fb3f6d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for inequality.  <a href="a00417.html#ga78d64b70022a4945cb797908fb3f6d65">More...</a><br /></td></tr>
<tr class="separator:ga78d64b70022a4945cb797908fb3f6d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5760aff14000ebe9042e042b31db949"><td class="memTemplParams" colspan="2">template&lt;class T1 , class V1 , class R1 , class D , class T2 , class V2 , class R2 &gt; </td></tr>
<tr class="memitem:gaa5760aff14000ebe9042e042b31db949"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a03065.html">EnableIfInterOperable</a>&lt; T1, T2, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00417.html#gaa5760aff14000ebe9042e042b31db949">Dune::operator&lt;</a> (const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T1, V1, R1, D &gt; &amp;lhs, const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa5760aff14000ebe9042e042b31db949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="a00417.html#gaa5760aff14000ebe9042e042b31db949">More...</a><br /></td></tr>
<tr class="separator:gaa5760aff14000ebe9042e042b31db949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf0c29cb2d498e30122d48b15db41f7f"><td class="memTemplParams" colspan="2">template&lt;class T1 , class V1 , class R1 , class D , class T2 , class V2 , class R2 &gt; </td></tr>
<tr class="memitem:gadf0c29cb2d498e30122d48b15db41f7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a03065.html">EnableIfInterOperable</a>&lt; T1, T2, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00417.html#gadf0c29cb2d498e30122d48b15db41f7f">Dune::operator&lt;=</a> (const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T1, V1, R1, D &gt; &amp;lhs, const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gadf0c29cb2d498e30122d48b15db41f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="a00417.html#gadf0c29cb2d498e30122d48b15db41f7f">More...</a><br /></td></tr>
<tr class="separator:gadf0c29cb2d498e30122d48b15db41f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cd2214e489cbe140c0394a24f7d77fa"><td class="memTemplParams" colspan="2">template&lt;class T1 , class V1 , class R1 , class D , class T2 , class V2 , class R2 &gt; </td></tr>
<tr class="memitem:ga4cd2214e489cbe140c0394a24f7d77fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a03065.html">EnableIfInterOperable</a>&lt; T1, T2, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00417.html#ga4cd2214e489cbe140c0394a24f7d77fa">Dune::operator&gt;</a> (const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T1, V1, R1, D &gt; &amp;lhs, const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga4cd2214e489cbe140c0394a24f7d77fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="a00417.html#ga4cd2214e489cbe140c0394a24f7d77fa">More...</a><br /></td></tr>
<tr class="separator:ga4cd2214e489cbe140c0394a24f7d77fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd0f438316b237180be4c98e915da261"><td class="memTemplParams" colspan="2">template&lt;class T1 , class V1 , class R1 , class D , class T2 , class V2 , class R2 &gt; </td></tr>
<tr class="memitem:gadd0f438316b237180be4c98e915da261"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a03065.html">EnableIfInterOperable</a>&lt; T1, T2, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00417.html#gadd0f438316b237180be4c98e915da261">Dune::operator&gt;=</a> (const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T1, V1, R1, D &gt; &amp;lhs, const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gadd0f438316b237180be4c98e915da261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="a00417.html#gadd0f438316b237180be4c98e915da261">More...</a><br /></td></tr>
<tr class="separator:gadd0f438316b237180be4c98e915da261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga567e9701961fedd3a613c9f6d3b68b5d"><td class="memTemplParams" colspan="2">template&lt;class T1 , class V1 , class R1 , class D , class T2 , class V2 , class R2 &gt; </td></tr>
<tr class="memitem:ga567e9701961fedd3a613c9f6d3b68b5d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a03065.html">EnableIfInterOperable</a>&lt; T1, T2, D &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00417.html#ga567e9701961fedd3a613c9f6d3b68b5d">Dune::operator-</a> (const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T1, V1, R1, D &gt; &amp;lhs, const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga567e9701961fedd3a613c9f6d3b68b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the difference between two pointers.  <a href="a00417.html#ga567e9701961fedd3a613c9f6d3b68b5d">More...</a><br /></td></tr>
<tr class="separator:ga567e9701961fedd3a613c9f6d3b68b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Iterator facades for writing stl conformant iterators. </p>
<p>With using these facades writing iterators for arbitrary containers becomes much less cumbersome as only few functions have to be implemented. All other functions needed by the stl are provided by the facades using the Barton-Nackman trick (also known as curiously recurring template pattern).</p>
<p>The following example illustrates how a random access iterator might be written:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include&lt;<a class="code" href="a00146.html">dune/common/iteratorfacades.hh</a>&gt;</span></div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">template&lt;<span class="keyword">class </span>C, class T&gt;</div>
<div class="line">class TestIterator : <span class="keyword">public</span> <a class="code" href="a01877.html">Dune::BidirectionalIteratorFacade</a>&lt;TestIterator&lt;C,T&gt;,T, T&amp;, int&gt;</div>
<div class="line">{</div>
<div class="line"> <span class="keyword">friend</span> <span class="keyword">class </span>TestIterator&lt;typename std::remove_const&lt;C&gt;::type, typename std::remove_const&lt;T&gt;::type &gt;;</div>
<div class="line"> friend class TestIterator&lt;const typename std::remove_const&lt;C&gt;::type, const typename std::remove_const&lt;T&gt;::type &gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Constructors needed by the facade iterators.</span></div>
<div class="line"> TestIterator(): container_(0), position_(0)</div>
<div class="line"> { }</div>
<div class="line"> </div>
<div class="line"> TestIterator(C&amp; cont, <span class="keywordtype">int</span> pos)</div>
<div class="line">   : container_(&amp;cont), position_(pos)</div>
<div class="line"> {}</div>
<div class="line"> </div>
<div class="line"> TestIterator(<span class="keyword">const</span> TestIterator&lt;<span class="keyword">typename</span> std::remove_const&lt;C&gt;::type, <span class="keyword">typename</span> std::remove_const&lt;T&gt;::type &gt;&amp; other)</div>
<div class="line">   : container_(other.container_), position_(other.position_)</div>
<div class="line"> {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> TestIterator(<span class="keyword">const</span> TestIterator&lt;<span class="keyword">const</span> <span class="keyword">typename</span> std::remove_const&lt;C&gt;::type, <span class="keyword">const</span> <span class="keyword">typename</span> std::remove_const&lt;T&gt;::type &gt;&amp; other)</div>
<div class="line">   : container_(other.container_), position_(other.position_)</div>
<div class="line"> {}</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Methods needed by the forward iterator</span></div>
<div class="line"> <span class="keywordtype">bool</span> equals(<span class="keyword">const</span> TestIterator&lt;<span class="keyword">typename</span> std::remove_const&lt;C&gt;::type,<span class="keyword">typename</span> std::remove_const&lt;T&gt;::type&gt;&amp; other)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line">   <span class="keywordflow">return</span> position_ == other.position_ &amp;&amp; container_ == other.container_;</div>
<div class="line"> }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> <span class="keywordtype">bool</span> equals(<span class="keyword">const</span> TestIterator&lt;<span class="keyword">const</span> <span class="keyword">typename</span> std::remove_const&lt;C&gt;::type,<span class="keyword">const</span> <span class="keyword">typename</span> std::remove_const&lt;T&gt;::type&gt;&amp; other)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line">   <span class="keywordflow">return</span> position_ == other.position_ &amp;&amp; container_ == other.container_;</div>
<div class="line"> }</div>
<div class="line"> </div>
<div class="line"> T&amp; dereference()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line">   <span class="keywordflow">return</span> container_-&gt;values_[position_];</div>
<div class="line"> }</div>
<div class="line"> </div>
<div class="line"> <span class="keywordtype">void</span> increment()</div>
<div class="line"> {</div>
<div class="line">++position_;</div>
<div class="line"> }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Additional function needed by BidirectionalIterator</span></div>
<div class="line"> <span class="keywordtype">void</span> decrement()</div>
<div class="line">{</div>
<div class="line">   --position_;</div>
<div class="line"> }</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Additional function needed by RandomAccessIterator</span></div>
<div class="line"> T&amp; elementAt(<span class="keywordtype">int</span> i)<span class="keyword">const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line">   <span class="keywordflow">return</span> container_-&gt;operator[](position_+i);</div>
<div class="line"> }</div>
<div class="line"> </div>
<div class="line"> <span class="keywordtype">void</span> advance(<span class="keywordtype">int</span> n)</div>
<div class="line"> {</div>
<div class="line">   position_=position_+n;</div>
<div class="line"> }</div>
<div class="line"> </div>
<div class="line"> std::ptrdiff_t distanceTo(TestIterator&lt;<span class="keyword">const</span> <span class="keyword">typename</span> std::remove_const&lt;C&gt;::type,<span class="keyword">const</span> <span class="keyword">typename</span> std::remove_const&lt;T&gt;::type&gt; other)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line">   assert(other.container_==container_);</div>
<div class="line">   <span class="keywordflow">return</span> other.position_ - position_;</div>
<div class="line"> }</div>
<div class="line"> </div>
<div class="line"> std::ptrdiff_t distanceTo(TestIterator&lt;<span class="keyword">const</span> <span class="keyword">typename</span> std::remove_const&lt;C&gt;::type, <span class="keyword">typename</span> std::remove_const&lt;T&gt;::type&gt; other)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"> </span>{</div>
<div class="line">   assert(other.container_==container_);</div>
<div class="line">   <span class="keywordflow">return</span> other.position_ - position_;</div>
<div class="line"> }</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line"> C *container_;</div>
<div class="line"> <span class="keywordtype">size_t</span> position_;</div>
<div class="line">};</div>
<div class="ttc" id="aa00146_html"><div class="ttname"><a href="a00146.html">iteratorfacades.hh</a></div><div class="ttdoc">This file implements iterator facade classes for writing stl conformant iterators.</div></div>
<div class="ttc" id="aa01877_html"><div class="ttname"><a href="a01877.html">Dune::BidirectionalIteratorFacade</a></div><div class="ttdoc">Facade class for stl conformant bidirectional iterators.</div><div class="ttdef"><b>Definition:</b> iteratorfacades.hh:272</div></div>
</div><!-- fragment --><p> See dune/common/test/iteratorbase.hh for details. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gace8cd0fee28b999a64ce7a75ca582cae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace8cd0fee28b999a64ce7a75ca582cae">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class V1 , class R1 , class D , class T2 , class V2 , class R2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a03065.html">EnableIfInterOperable</a>&lt;T1,T2,bool&gt;::type Dune::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01877.html">BidirectionalIteratorFacade</a>&lt; T1, V1, R1, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01877.html">BidirectionalIteratorFacade</a>&lt; T2, V2, R2, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks for inequality. </p>
<p>This operation is only defined if either D2 is convertible to D1 or vice versa. If that is not the case the compiler will report an error as EnableIfInterOperable&lt;D1,D2,bool&gt;::type is not defined. </p>

</div>
</div>
<a id="ga1369bc3ae1876892c6567eff7987620f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1369bc3ae1876892c6567eff7987620f">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class V1 , class R1 , class D , class T2 , class V2 , class R2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a03065.html">EnableIfInterOperable</a>&lt;T1,T2,bool&gt;::type Dune::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01873.html">ForwardIteratorFacade</a>&lt; T1, V1, R1, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01873.html">ForwardIteratorFacade</a>&lt; T2, V2, R2, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks for inequality. </p>
<p>This operation is only defined if either D2 is convertible to D1 or vice versa. If that is not the case the compiler will report an error as EnableIfInterOperable&lt;D1,D2,bool&gt;::type is not defined. </p>

</div>
</div>
<a id="ga78d64b70022a4945cb797908fb3f6d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78d64b70022a4945cb797908fb3f6d65">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class V1 , class R1 , class D , class T2 , class V2 , class R2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a03065.html">EnableIfInterOperable</a>&lt;T1,T2,bool&gt;::type Dune::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T1, V1, R1, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T2, V2, R2, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks for inequality. </p>
<p>This operation is only defined if either D2 is convertible to D1 or vice versa. If that is not the case the compiler will report an error as EnableIfInterOperable&lt;D1,D2,bool&gt;::type is not defined. </p>

</div>
</div>
<a id="ga567e9701961fedd3a613c9f6d3b68b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga567e9701961fedd3a613c9f6d3b68b5d">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class V1 , class R1 , class D , class T2 , class V2 , class R2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a03065.html">EnableIfInterOperable</a>&lt;T1,T2,D&gt;::type Dune::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T1, V1, R1, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T2, V2, R2, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the difference between two pointers. </p>
<p>This operation is only defined if either D2 is convertible to D1 or vice versa. If that is not the case the compiler will report an error as EnableIfInterOperable&lt;D1,D2,bool&gt;::type is not defined. </p>

</div>
</div>
<a id="gaa5760aff14000ebe9042e042b31db949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5760aff14000ebe9042e042b31db949">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class V1 , class R1 , class D , class T2 , class V2 , class R2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a03065.html">EnableIfInterOperable</a>&lt;T1,T2,bool&gt;::type Dune::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T1, V1, R1, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T2, V2, R2, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>This operation is only defined if either D2 is convertible to D1 or vice versa. If that is not the case the compiler will report an error as EnableIfInterOperable&lt;D1,D2,bool&gt;::type is not defined. </p>

</div>
</div>
<a id="gadf0c29cb2d498e30122d48b15db41f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf0c29cb2d498e30122d48b15db41f7f">&#9670;&nbsp;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class V1 , class R1 , class D , class T2 , class V2 , class R2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a03065.html">EnableIfInterOperable</a>&lt;T1,T2,bool&gt;::type Dune::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T1, V1, R1, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T2, V2, R2, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>This operation is only defined if either D2 is convertible to D1 or vice versa. If that is not the case the compiler will report an error as EnableIfInterOperable&lt;D1,D2,bool&gt;::type is not defined. </p>

</div>
</div>
<a id="ga0a147b2ec114b90e57366216029b40bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a147b2ec114b90e57366216029b40bc">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class V1 , class R1 , class D , class T2 , class V2 , class R2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_convertible&lt;T2,T1&gt;::value,bool&gt;::type Dune::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01877.html">BidirectionalIteratorFacade</a>&lt; T1, V1, R1, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01877.html">BidirectionalIteratorFacade</a>&lt; T2, V2, R2, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks for equality. </p>
<p>This operation is only defined if T2 is convertible to T1, otherwise it is removed from the overload set since the enable_if for the return type yield an invalid type expression. </p>

</div>
</div>
<a id="gad89f7fc265d9bd63c5b5a8da6748d8af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad89f7fc265d9bd63c5b5a8da6748d8af">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class V1 , class R1 , class D , class T2 , class V2 , class R2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a03065.html">EnableIfInterOperable</a>&lt;T1,T2,bool&gt;::type Dune::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01873.html">ForwardIteratorFacade</a>&lt; T1, V1, R1, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01873.html">ForwardIteratorFacade</a>&lt; T2, V2, R2, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks for equality. </p>
<p>This operation is only defined if either D2 is convertible to D1 or vice versa. If that is not the case the compiler will report an error as EnableIfInterOperable&lt;D1,D2,bool&gt;::type is not defined. </p>

</div>
</div>
<a id="ga639a6e346454c1d6635f21ea15af4032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga639a6e346454c1d6635f21ea15af4032">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class V1 , class R1 , class D , class T2 , class V2 , class R2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a03065.html">EnableIfInterOperable</a>&lt;T1,T2,bool&gt;::type Dune::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T1, V1, R1, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T2, V2, R2, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks for equality. </p>
<p>This operation is only defined if either D2 is convertible to D1 or vice versa. If that is not the case the compiler will report an error as EnableIfInterOperable&lt;D1,D2,bool&gt;::type is not defined. </p>

</div>
</div>
<a id="ga4cd2214e489cbe140c0394a24f7d77fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cd2214e489cbe140c0394a24f7d77fa">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class V1 , class R1 , class D , class T2 , class V2 , class R2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a03065.html">EnableIfInterOperable</a>&lt;T1,T2,bool&gt;::type Dune::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T1, V1, R1, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T2, V2, R2, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>This operation is only defined if either D2 is convertible to D1 or vice versa. If that is not the case the compiler will report an error as EnableIfInterOperable&lt;D1,D2,bool&gt;::type is not defined. </p>

</div>
</div>
<a id="gadd0f438316b237180be4c98e915da261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd0f438316b237180be4c98e915da261">&#9670;&nbsp;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class V1 , class R1 , class D , class T2 , class V2 , class R2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a03065.html">EnableIfInterOperable</a>&lt;T1,T2,bool&gt;::type Dune::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T1, V1, R1, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T2, V2, R2, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison operator. </p>
<p>This operation is only defined if either D2 is convertible to D1 or vice versa. If that is not the case the compiler will report an error as EnableIfInterOperable&lt;D1,D2,bool&gt;::type is not defined. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
