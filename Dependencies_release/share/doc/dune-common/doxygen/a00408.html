<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>dune-common: Hybrid Utilities</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">dune-common
   &#160;<span id="projectnumber">2.7.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Hybrid Utilities<div class="ingroups"><a class="el" href="a00400.html">Common</a> &raquo; <a class="el" href="a00402.html">Utilities</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Hybrid utility functions that work on homogeneous as well as heterogeneous containers.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Hybrid Utilities:</div>
<div class="dyncontent">
<div class="center"><img src="a00408.png" border="0" usemap="#aa00408" alt=""/></div>
<map name="aa00408" id="aa00408">
<area shape="rect" title="Hybrid utility functions that work on homogeneous as well as heterogeneous containers." alt="" coords="119,5,225,31"/>
<area shape="rect" href="a00402.html" title="Collection of helper classes, type traits, etc." alt="" coords="5,5,71,31"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0df72c8cdbb69ecf6da9483d5cdac1de"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga0df72c8cdbb69ecf6da9483d5cdac1de"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00408.html#ga0df72c8cdbb69ecf6da9483d5cdac1de">Dune::Hybrid::size</a> (const T &amp;t)</td></tr>
<tr class="memdesc:ga0df72c8cdbb69ecf6da9483d5cdac1de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size query.  <a href="a00408.html#ga0df72c8cdbb69ecf6da9483d5cdac1de">More...</a><br /></td></tr>
<tr class="separator:ga0df72c8cdbb69ecf6da9483d5cdac1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac85f9d601905a3d0001edd94bd67b2d7"><td class="memTemplParams" colspan="2">template&lt;class Container , class Index &gt; </td></tr>
<tr class="memitem:gac85f9d601905a3d0001edd94bd67b2d7"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00408.html#gac85f9d601905a3d0001edd94bd67b2d7">Dune::Hybrid::elementAt</a> (Container &amp;&amp;c, Index &amp;&amp;i)</td></tr>
<tr class="memdesc:gac85f9d601905a3d0001edd94bd67b2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get element at given position from container.  <a href="a00408.html#gac85f9d601905a3d0001edd94bd67b2d7">More...</a><br /></td></tr>
<tr class="separator:gac85f9d601905a3d0001edd94bd67b2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacd5d1927ffa1d96adf1db1fdbaba28c"><td class="memTemplParams" colspan="2">template&lt;class Begin , class End &gt; </td></tr>
<tr class="memitem:gaacd5d1927ffa1d96adf1db1fdbaba28c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00408.html#gaacd5d1927ffa1d96adf1db1fdbaba28c">Dune::Hybrid::integralRange</a> (const Begin &amp;begin, const End &amp;end)</td></tr>
<tr class="memdesc:gaacd5d1927ffa1d96adf1db1fdbaba28c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an integral range.  <a href="a00408.html#gaacd5d1927ffa1d96adf1db1fdbaba28c">More...</a><br /></td></tr>
<tr class="separator:gaacd5d1927ffa1d96adf1db1fdbaba28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a44b7c50255662ec8d3553925ce9b46"><td class="memTemplParams" colspan="2">template&lt;class End &gt; </td></tr>
<tr class="memitem:ga1a44b7c50255662ec8d3553925ce9b46"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00408.html#ga1a44b7c50255662ec8d3553925ce9b46">Dune::Hybrid::integralRange</a> (const End &amp;end)</td></tr>
<tr class="memdesc:ga1a44b7c50255662ec8d3553925ce9b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an integral range starting from 0.  <a href="a00408.html#ga1a44b7c50255662ec8d3553925ce9b46">More...</a><br /></td></tr>
<tr class="separator:ga1a44b7c50255662ec8d3553925ce9b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2df9e60e21091ed59c4a636b99abbedc"><td class="memTemplParams" colspan="2">template&lt;class Range , class F &gt; </td></tr>
<tr class="memitem:ga2df9e60e21091ed59c4a636b99abbedc"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00408.html#ga2df9e60e21091ed59c4a636b99abbedc">Dune::Hybrid::forEach</a> (Range &amp;&amp;<a class="el" href="a00428.html#a9749b12765838700df3504bcae783e35">range</a>, F &amp;&amp;f)</td></tr>
<tr class="memdesc:ga2df9e60e21091ed59c4a636b99abbedc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range based for loop.  <a href="a00408.html#ga2df9e60e21091ed59c4a636b99abbedc">More...</a><br /></td></tr>
<tr class="separator:ga2df9e60e21091ed59c4a636b99abbedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga606e67b2302cc9d78705ad16af9da02c"><td class="memTemplParams" colspan="2">template&lt;class Range , class T , class F &gt; </td></tr>
<tr class="memitem:ga606e67b2302cc9d78705ad16af9da02c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00408.html#ga606e67b2302cc9d78705ad16af9da02c">Dune::Hybrid::accumulate</a> (Range &amp;&amp;<a class="el" href="a00428.html#a9749b12765838700df3504bcae783e35">range</a>, T value, F &amp;&amp;f)</td></tr>
<tr class="memdesc:ga606e67b2302cc9d78705ad16af9da02c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate values.  <a href="a00408.html#ga606e67b2302cc9d78705ad16af9da02c">More...</a><br /></td></tr>
<tr class="separator:ga606e67b2302cc9d78705ad16af9da02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac1691e6004f0428bdacab6407152807"><td class="memTemplParams" colspan="2">template&lt;class Condition , class IfFunc , class ElseFunc &gt; </td></tr>
<tr class="memitem:gaac1691e6004f0428bdacab6407152807"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00408.html#gaac1691e6004f0428bdacab6407152807">Dune::Hybrid::ifElse</a> (const Condition &amp;condition, IfFunc &amp;&amp;ifFunc, ElseFunc &amp;&amp;elseFunc)</td></tr>
<tr class="memdesc:gaac1691e6004f0428bdacab6407152807"><td class="mdescLeft">&#160;</td><td class="mdescRight">A conditional expression.  <a href="a00408.html#gaac1691e6004f0428bdacab6407152807">More...</a><br /></td></tr>
<tr class="separator:gaac1691e6004f0428bdacab6407152807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga044cfa54089ac3509d0a3a24b85ef42b"><td class="memTemplParams" colspan="2">template&lt;class Condition , class IfFunc &gt; </td></tr>
<tr class="memitem:ga044cfa54089ac3509d0a3a24b85ef42b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00408.html#ga044cfa54089ac3509d0a3a24b85ef42b">Dune::Hybrid::ifElse</a> (const Condition &amp;condition, IfFunc &amp;&amp;ifFunc)</td></tr>
<tr class="memdesc:ga044cfa54089ac3509d0a3a24b85ef42b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A conditional expression.  <a href="a00408.html#ga044cfa54089ac3509d0a3a24b85ef42b">More...</a><br /></td></tr>
<tr class="separator:ga044cfa54089ac3509d0a3a24b85ef42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f6da8119c5af45fe0413b9f75ef9861"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:ga1f6da8119c5af45fe0413b9f75ef9861"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00408.html#ga1f6da8119c5af45fe0413b9f75ef9861">Dune::Hybrid::equals</a> (T1 &amp;&amp;t1, T2 &amp;&amp;t2)</td></tr>
<tr class="memdesc:ga1f6da8119c5af45fe0413b9f75ef9861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison.  <a href="a00408.html#ga1f6da8119c5af45fe0413b9f75ef9861">More...</a><br /></td></tr>
<tr class="separator:ga1f6da8119c5af45fe0413b9f75ef9861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57705e4850c91cd0a92b452384bdc0a0"><td class="memTemplParams" colspan="2">template&lt;class Cases , class Value , class Branches , class ElseBranch &gt; </td></tr>
<tr class="memitem:ga57705e4850c91cd0a92b452384bdc0a0"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00408.html#ga57705e4850c91cd0a92b452384bdc0a0">Dune::Hybrid::switchCases</a> (const Cases &amp;cases, const Value &amp;value, Branches &amp;&amp;branches, ElseBranch &amp;&amp;elseBranch)</td></tr>
<tr class="memdesc:ga57705e4850c91cd0a92b452384bdc0a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch statement.  <a href="a00408.html#ga57705e4850c91cd0a92b452384bdc0a0">More...</a><br /></td></tr>
<tr class="separator:ga57705e4850c91cd0a92b452384bdc0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3c378c2ae090a6b608ec667486ede4b"><td class="memTemplParams" colspan="2">template&lt;class Cases , class Value , class Branches &gt; </td></tr>
<tr class="memitem:gaa3c378c2ae090a6b608ec667486ede4b"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00408.html#gaa3c378c2ae090a6b608ec667486ede4b">Dune::Hybrid::switchCases</a> (const Cases &amp;cases, const Value &amp;value, Branches &amp;&amp;branches)</td></tr>
<tr class="memdesc:gaa3c378c2ae090a6b608ec667486ede4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch statement.  <a href="a00408.html#gaa3c378c2ae090a6b608ec667486ede4b">More...</a><br /></td></tr>
<tr class="separator:gaa3c378c2ae090a6b608ec667486ede4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Hybrid utility functions that work on homogeneous as well as heterogeneous containers. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga606e67b2302cc9d78705ad16af9da02c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga606e67b2302cc9d78705ad16af9da02c">&#9670;&nbsp;</a></span>accumulate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Range , class T , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Dune::Hybrid::accumulate </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accumulate values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Range</td><td>Type of given range </td></tr>
    <tr><td class="paramname">T</td><td>Type of accumulated value </td></tr>
    <tr><td class="paramname">F</td><td>Type of binary accumulation operator</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>The range of values to accumulate </td></tr>
    <tr><td class="paramname">value</td><td>Initial value for accumulation </td></tr>
    <tr><td class="paramname">f</td><td>Binary operator for accumulation</td></tr>
  </table>
  </dd>
</dl>
<p>This supports looping over the same ranges as <a class="el" href="a00408.html#ga2df9e60e21091ed59c4a636b99abbedc" title="Range based for loop.">Hybrid::forEach</a> </p>

</div>
</div>
<a id="gac85f9d601905a3d0001edd94bd67b2d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac85f9d601905a3d0001edd94bd67b2d7">&#9670;&nbsp;</a></span>elementAt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , class Index &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) Dune::Hybrid::elementAt </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index &amp;&amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get element at given position from container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>Type of given container </td></tr>
    <tr><td class="paramname">Index</td><td>Type of index</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Given container </td></tr>
    <tr><td class="paramname">i</td><td>Index of element to obtain</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element at position i, i.e. c[i]</dd></dl>
<p>If this returns the i-th entry of c. It supports the following containers</p><ul>
<li>Containers providing dynamic access via operator[]</li>
<li>Heterogeneous containers providing access via operator[](integral_constant&lt;...&gt;)</li>
<li>std::tuple&lt;...&gt;</li>
<li>std::integer_sequence </li>
</ul>

</div>
</div>
<a id="ga1f6da8119c5af45fe0413b9f75ef9861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f6da8119c5af45fe0413b9f75ef9861">&#9670;&nbsp;</a></span>equals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto Dune::Hybrid::equals </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison. </p>
<p>If both types have a static member value, the result of comparing these is returned as std::integral_constant&lt;bool, *&gt;. Otherwise the result of a runtime comparison of t1 and t2 is directly returned. </p>

</div>
</div>
<a id="ga2df9e60e21091ed59c4a636b99abbedc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2df9e60e21091ed59c4a636b99abbedc">&#9670;&nbsp;</a></span>forEach()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Range , class F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void Dune::Hybrid::forEach </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Range based for loop. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Range</td><td>Type of given range </td></tr>
    <tr><td class="paramname">F</td><td>Type of given predicate</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>The range to loop over </td></tr>
    <tr><td class="paramname">f</td><td>A predicate that will be called with each entry of the range</td></tr>
  </table>
  </dd>
</dl>
<p>This supports looping over the following ranges</p><ul>
<li>ranges obtained from <a class="el" href="a00408.html#gaacd5d1927ffa1d96adf1db1fdbaba28c" title="Create an integral range.">integralRange()</a></li>
<li>all ranges that provide <a class="el" href="a00408.html#ga0df72c8cdbb69ecf6da9483d5cdac1de" title="Size query.">Hybrid::size()</a> and <a class="el" href="a00408.html#gac85f9d601905a3d0001edd94bd67b2d7" title="Get element at given position from container.">Hybrid::elementAt()</a></li>
</ul>
<p>This especially included instances of std::integer_sequence, std::tuple, <a class="el" href="a03080.html" title="A class augmenting std::tuple by element access via operator[].">Dune::TupleVector</a>, and Dune::MultiTypeBlockVector. </p>

</div>
</div>
<a id="ga044cfa54089ac3509d0a3a24b85ef42b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga044cfa54089ac3509d0a3a24b85ef42b">&#9670;&nbsp;</a></span>ifElse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Condition , class IfFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::Hybrid::ifElse </td>
          <td>(</td>
          <td class="paramtype">const Condition &amp;&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IfFunc &amp;&amp;&#160;</td>
          <td class="paramname"><em>ifFunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A conditional expression. </p>
<p>This provides an ifElse conditional with empty else clause. </p>

</div>
</div>
<a id="gaac1691e6004f0428bdacab6407152807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac1691e6004f0428bdacab6407152807">&#9670;&nbsp;</a></span>ifElse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Condition , class IfFunc , class ElseFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) Dune::Hybrid::ifElse </td>
          <td>(</td>
          <td class="paramtype">const Condition &amp;&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IfFunc &amp;&amp;&#160;</td>
          <td class="paramname"><em>ifFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElseFunc &amp;&amp;&#160;</td>
          <td class="paramname"><em>elseFunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A conditional expression. </p>
<p>This will call either ifFunc or elseFunc depending on the condition. In any case a single argument will be passed to the called function. This will always be the identity function. Passing an expression through this function will lead to lazy evaluation. This way both 'branches' can contain expressions that are only valid within this branch if the condition is a std::integral_constant&lt;bool,*&gt;.</p>
<p>In order to do this, the passed functors must have a single argument of type auto.</p>
<p>Due to the lazy evaluation mechanism and support for std::integral_constant&lt;bool,*&gt; this allows to emulate a static if statement. </p>

</div>
</div>
<a id="gaacd5d1927ffa1d96adf1db1fdbaba28c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacd5d1927ffa1d96adf1db1fdbaba28c">&#9670;&nbsp;</a></span>integralRange() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Begin , class End &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto Dune::Hybrid::integralRange </td>
          <td>(</td>
          <td class="paramtype">const Begin &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const End &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an integral range. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Begin</td><td>Type of begin entry of the range </td></tr>
    <tr><td class="paramname">End</td><td>Type of end entry of the range</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>First entry of the range </td></tr>
    <tr><td class="paramname">end</td><td>One past the last entry of the range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An object encoding the given range</dd></dl>
<p>If Begin and End are both instances of type std::integral_constant, the returned range encodes begin and end statically. </p>

</div>
</div>
<a id="ga1a44b7c50255662ec8d3553925ce9b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a44b7c50255662ec8d3553925ce9b46">&#9670;&nbsp;</a></span>integralRange() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class End &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto Dune::Hybrid::integralRange </td>
          <td>(</td>
          <td class="paramtype">const End &amp;&#160;</td>
          <td class="paramname"><em>end</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an integral range starting from 0. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">End</td><td>Type of end entry of the range</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">end</td><td>One past the last entry of the range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An object encoding the given range</dd></dl>
<p>This is a short cut for integralRange(_0, end). </p>

</div>
</div>
<a id="ga0df72c8cdbb69ecf6da9483d5cdac1de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0df72c8cdbb69ecf6da9483d5cdac1de">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto Dune::Hybrid::size </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size query. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of container whose size is queried</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Container whose size is queried</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of t</dd></dl>
<p>If the size of t is known at compile type the size is returned as std::integral_constant&lt;std::size_t, size&gt;. Otherwise the result of <a class="el" href="a00408.html#ga0df72c8cdbb69ecf6da9483d5cdac1de" title="Size query.">t.size()</a> is returned.</p>
<p>Supported types for deriving the size at compile time are:</p><ul>
<li>instances of std::integer_sequence</li>
<li>all types std::tuple_size is implemented for</li>
<li>all typed that have a static method <a class="el" href="a00408.html#ga0df72c8cdbb69ecf6da9483d5cdac1de" title="Size query.">size()</a></li>
<li>instances of <a class="el" href="a01420.html" title="vector space out of a tensor product of fields.">Dune::FieldVector</a> </li>
</ul>

</div>
</div>
<a id="gaa3c378c2ae090a6b608ec667486ede4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3c378c2ae090a6b608ec667486ede4b">&#9670;&nbsp;</a></span>switchCases() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Cases , class Value , class Branches &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void Dune::Hybrid::switchCases </td>
          <td>(</td>
          <td class="paramtype">const Cases &amp;&#160;</td>
          <td class="paramname"><em>cases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Branches &amp;&amp;&#160;</td>
          <td class="paramname"><em>branches</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Switch statement. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Cases</td><td>Type of case range </td></tr>
    <tr><td class="paramname">Value</td><td>Type of value to check against the cases </td></tr>
    <tr><td class="paramname">Branches</td><td>Type of branch function</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cases</td><td>A range of cases to check for </td></tr>
    <tr><td class="paramname">value</td><td>The value to check against the cases </td></tr>
    <tr><td class="paramname">branches</td><td>A callback that will be executed with matching entry from case list</td></tr>
  </table>
  </dd>
</dl>
<p>Value is checked against all entries of the given range. If one matches, then branches is executed with the matching value as single argument. If the range is an std::integer_sequence, the value is passed as std::integral_constant. If non of the entries matches, then elseBranch is executed without any argument. </p>

</div>
</div>
<a id="ga57705e4850c91cd0a92b452384bdc0a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57705e4850c91cd0a92b452384bdc0a0">&#9670;&nbsp;</a></span>switchCases() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Cases , class Value , class Branches , class ElseBranch &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) Dune::Hybrid::switchCases </td>
          <td>(</td>
          <td class="paramtype">const Cases &amp;&#160;</td>
          <td class="paramname"><em>cases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Branches &amp;&amp;&#160;</td>
          <td class="paramname"><em>branches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElseBranch &amp;&amp;&#160;</td>
          <td class="paramname"><em>elseBranch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Switch statement. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Cases</td><td>Type of case range </td></tr>
    <tr><td class="paramname">Value</td><td>Type of value to check against the cases </td></tr>
    <tr><td class="paramname">Branches</td><td>Type of branch function </td></tr>
    <tr><td class="paramname">ElseBranch</td><td>Type of branch function</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cases</td><td>A range of cases to check for </td></tr>
    <tr><td class="paramname">value</td><td>The value to check against the cases </td></tr>
    <tr><td class="paramname">branches</td><td>A callback that will be executed with matching entry from case list </td></tr>
    <tr><td class="paramname">elseBranch</td><td>A callback that will be executed if no other entry matches</td></tr>
  </table>
  </dd>
</dl>
<p>Value is checked against all entries of the given range. If one matches, then branches is executed with the matching value as single argument. If the range is an std::integer_sequence, the value is passed as std::integral_constant. If non of the entries matches, then elseBranch is executed without any argument.</p>
<p>Notice that this short circuits, e.g., if one case matches, the others are no longer evaluated.</p>
<p>The return value will be deduced from the else branch. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
