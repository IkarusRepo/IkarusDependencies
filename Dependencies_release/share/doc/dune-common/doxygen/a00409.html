<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>dune-common: C++ utilities and backports</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">dune-common
   &#160;<span id="projectnumber">2.8.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">C++ utilities and backports<div class="ingroups"><a class="el" href="a00400.html">Common</a> &raquo; <a class="el" href="a00402.html">Utilities</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Standard library features backported from newer C++ versions or technical specifications and DUNE-specific utilities.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for C++ utilities and backports:</div>
<div class="dyncontent">
<div class="center"><img src="a00409.png" border="0" usemap="#aa00409" alt=""/></div>
<map name="aa00409" id="aa00409">
<area shape="rect" title="Standard library features backported from newer C++ versions or technical specifications and DUNE&#45;spe..." alt="" coords="119,5,297,31"/>
<area shape="rect" href="a00402.html" title="Collection of helper classes, type traits, etc." alt="" coords="5,5,71,31"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:a00152"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html">keywords.hh</a></td></tr>
<tr class="memdesc:a00152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions of several macros that conditionally make C++ syntax available. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00272"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00272.html">proxymemberaccess.hh</a></td></tr>
<tr class="memdesc:a00272"><td class="mdescLeft">&#160;</td><td class="mdescRight">infrastructure for supporting operator-&gt;() on both references and proxies <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01885.html">Dune::IteratorRange&lt; Iterator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple range between a begin and an end iterator.  <a href="a01885.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02849.html">Dune::Std::is_callable&lt; D, R &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class to check if function is callable.  <a href="a02849.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02853.html">Dune::Std::is_callable&lt; F(Args...), R &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class to check if function is callable.  <a href="a02853.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02857.html">Dune::Std::is_invocable&lt; F, Args &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class to check if function is invocable.  <a href="a02857.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02861.html">Dune::Std::is_invocable_r&lt; R, F, Args &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class to check if function is invocable and the return type is compatible.  <a href="a02861.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02865.html">Dune::Std::nonesuch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type representing a lookup failure by std::detected_or and friends.  <a href="a02865.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02869.html">Dune::Std::conjunction&lt; B &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">forms the logical conjunction of the type traits B...  <a href="a02869.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02873.html">Dune::Std::disjunction&lt; B &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">forms the logical disjunction of the type traits B...  <a href="a02873.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02877.html">Dune::Std::negation&lt; B &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">forms the logical negation of the type traits B...  <a href="a02877.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03057.html">Dune::Empty</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just an empty class.  <a href="a03057.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03061.html">Dune::IsInteroperable&lt; T1, T2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether two types are interoperable.  <a href="a03061.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03065.html">Dune::EnableIfInterOperable&lt; T1, T2, Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable typedef if two types are interoperable.  <a href="a03065.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03069.html">Dune::AlwaysFalse&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">template which always yields a false value  <a href="a03069.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03073.html">Dune::AlwaysTrue&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">template which always yields a true value  <a href="a03073.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03077.html">Dune::IsCallable&lt; D, R &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is callable with ()-operator and given arguments.  <a href="a03077.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03081.html">Dune::IsCallable&lt; F(Args...), R &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is callable with ()-operator and given arguments.  <a href="a03081.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03085.html">Dune::IsNumber&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this type acts as a scalar in the context of (hierarchically blocked) containers.  <a href="a03085.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03089.html">Dune::HasNaN&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this type has a value of NaN.  <a href="a03089.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03093.html">Dune::IsIndexable&lt; T, I &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine whether an instance of T has an operator[](I), i.e. whether it can be indexed with an index of type I.  <a href="a03093.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03097.html">Dune::IsIterable&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">typetrait to check that a class has begin() and end() members  <a href="a03097.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03101.html">Dune::IsTuple&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if T is a std::tuple&lt;...&gt;  <a href="a03101.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03105.html">Dune::IsTupleOrDerived&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if T derived from a std::tuple&lt;...&gt;  <a href="a03105.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03109.html">Dune::IsIntegralConstant&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if T is an std::integral_constant&lt;I, i&gt;  <a href="a03109.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03113.html">Dune::SizeOf&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute size of variadic type list.  <a href="a03113.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03117.html">Dune::IntegerSequenceEntry&lt; IntegerSequence, index &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get entry of std::integer_sequence.  <a href="a03117.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03121.html">Dune::AutonomousValueType&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type free of internal references that <code>T</code> can be converted to.  <a href="a03121.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03125.html">Dune::AutonomousValueType&lt; T &amp; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization to remove lvalue references.  <a href="a03125.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03129.html">Dune::AutonomousValueType&lt; T &amp;&amp; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization to remove rvalue references.  <a href="a03129.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03133.html">Dune::AutonomousValueType&lt; const T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization to remove const qualifiers.  <a href="a03133.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03137.html">Dune::AutonomousValueType&lt; volatile T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization to remove volatile qualifiers.  <a href="a03137.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03141.html">Dune::AutonomousValueType&lt; std::vector&lt; bool &gt;::reference &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the proxies of <code>vector&lt;bool&gt;</code>  <a href="a03141.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03145.html">Dune::AutonomousValueType&lt; volatile const T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization to remove both const and volatile qualifiers.  <a href="a03145.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02841.html">Dune::Std::to_false_type&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">template mapping a type to <code>std::false_type</code>  <a href="a02841.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02845.html">Dune::Std::to_true_type&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">template mapping a type to <code>std::true_type</code>  <a href="a02845.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga902aaece2c20a75cbf6daad4957ba069"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00409.html#ga902aaece2c20a75cbf6daad4957ba069">DUNE_ASSERT_AND_RETURN</a>(C,  X)&#160;&#160;&#160;(!(C) ? throw [&amp;](){assert(!#C);return 0;}() : 0), X</td></tr>
<tr class="memdesc:ga902aaece2c20a75cbf6daad4957ba069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserts a condition and return on success in constexpr context.  <a href="a00409.html#ga902aaece2c20a75cbf6daad4957ba069">More...</a><br /></td></tr>
<tr class="separator:ga902aaece2c20a75cbf6daad4957ba069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab56b68b6f47fe5b4f2bbd28d2227ca4a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00409.html#gab56b68b6f47fe5b4f2bbd28d2227ca4a">DUNE_DEPRECATED</a></td></tr>
<tr class="memdesc:gab56b68b6f47fe5b4f2bbd28d2227ca4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark some entity as deprecated.  <a href="a00409.html#gab56b68b6f47fe5b4f2bbd28d2227ca4a">More...</a><br /></td></tr>
<tr class="separator:gab56b68b6f47fe5b4f2bbd28d2227ca4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98dcbe0cf30aec44df67e481fd82414c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00409.html#ga98dcbe0cf30aec44df67e481fd82414c">DUNE_DEPRECATED_MSG</a>(text)&#160;&#160;&#160;<a class="el" href="a00409.html#gab56b68b6f47fe5b4f2bbd28d2227ca4a">DUNE_DEPRECATED</a></td></tr>
<tr class="memdesc:ga98dcbe0cf30aec44df67e481fd82414c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark some entity as deprecated.  <a href="a00409.html#ga98dcbe0cf30aec44df67e481fd82414c">More...</a><br /></td></tr>
<tr class="separator:ga98dcbe0cf30aec44df67e481fd82414c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74d440d098178dc5a4adea8f7c160e99"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00409.html#ga74d440d098178dc5a4adea8f7c160e99">DUNE_NO_DEPRECATED_BEGIN</a>&#160;&#160;&#160;...</td></tr>
<tr class="memdesc:ga74d440d098178dc5a4adea8f7c160e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ignore deprecation warnings (start)  <a href="a00409.html#ga74d440d098178dc5a4adea8f7c160e99">More...</a><br /></td></tr>
<tr class="separator:ga74d440d098178dc5a4adea8f7c160e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga664ae9266c2a074c71746e68aaa8eb6a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00409.html#ga664ae9266c2a074c71746e68aaa8eb6a">DUNE_NO_DEPRECATED_END</a>&#160;&#160;&#160;...</td></tr>
<tr class="memdesc:ga664ae9266c2a074c71746e68aaa8eb6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ignore deprecation warnings (end)  <a href="a00409.html#ga664ae9266c2a074c71746e68aaa8eb6a">More...</a><br /></td></tr>
<tr class="separator:ga664ae9266c2a074c71746e68aaa8eb6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53be527752cf155b994e29d457629050"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00409.html#ga53be527752cf155b994e29d457629050">DUNE_UNUSED</a></td></tr>
<tr class="memdesc:ga53be527752cf155b994e29d457629050"><td class="mdescLeft">&#160;</td><td class="mdescRight">A macro for marking variables that the compiler mistakenly flags as unused, which sometimes happens due to templates.  <a href="a00409.html#ga53be527752cf155b994e29d457629050">More...</a><br /></td></tr>
<tr class="separator:ga53be527752cf155b994e29d457629050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabedfe90a62e9dfc989b8298fec44801b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00409.html#gabedfe90a62e9dfc989b8298fec44801b">DUNE_UNUSED_PARAMETER</a>(parm)&#160;&#160;&#160;static_cast&lt;void&gt;(parm)</td></tr>
<tr class="separator:gabedfe90a62e9dfc989b8298fec44801b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gadb4713b99082ef169f74666e0ec7a46e"><td class="memTemplParams" colspan="2">template&lt;typename Default , template&lt; typename... &gt; class Op, typename... Args&gt; </td></tr>
<tr class="memitem:gadb4713b99082ef169f74666e0ec7a46e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00409.html#gadb4713b99082ef169f74666e0ec7a46e">Dune::Std::detected_or</a> = Impl::detector&lt; Default, void, Op, Args... &gt;</td></tr>
<tr class="memdesc:gadb4713b99082ef169f74666e0ec7a46e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects whether <code>Op&lt;Args...&gt;</code> is valid and makes the result available.  <a href="a00409.html#gadb4713b99082ef169f74666e0ec7a46e">More...</a><br /></td></tr>
<tr class="separator:gadb4713b99082ef169f74666e0ec7a46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccaa5104ef0c27be164435f42ef81fd5"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename... &gt; class Op, typename... Args&gt; </td></tr>
<tr class="memitem:gaccaa5104ef0c27be164435f42ef81fd5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00409.html#gaccaa5104ef0c27be164435f42ef81fd5">Dune::Std::is_detected</a> = typename <a class="el" href="a00409.html#gadb4713b99082ef169f74666e0ec7a46e">detected_or</a>&lt; <a class="el" href="a02865.html">nonesuch</a>, Op, Args... &gt;::value_t</td></tr>
<tr class="memdesc:gaccaa5104ef0c27be164435f42ef81fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects whether <code>Op&lt;Args...&gt;</code> is valid.  <a href="a00409.html#gaccaa5104ef0c27be164435f42ef81fd5">More...</a><br /></td></tr>
<tr class="separator:gaccaa5104ef0c27be164435f42ef81fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67b8ffda29f365419403a66e49ec0ffe"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename... &gt; class Op, typename... Args&gt; </td></tr>
<tr class="memitem:ga67b8ffda29f365419403a66e49ec0ffe"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00409.html#ga67b8ffda29f365419403a66e49ec0ffe">Dune::Std::detected_t</a> = typename <a class="el" href="a00409.html#gadb4713b99082ef169f74666e0ec7a46e">detected_or</a>&lt; <a class="el" href="a02865.html">nonesuch</a>, Op, Args... &gt;::type</td></tr>
<tr class="memdesc:ga67b8ffda29f365419403a66e49ec0ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>Op&lt;Args...&gt;</code> if that is valid; otherwise returns nonesuch.  <a href="a00409.html#ga67b8ffda29f365419403a66e49ec0ffe">More...</a><br /></td></tr>
<tr class="separator:ga67b8ffda29f365419403a66e49ec0ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f49a21b2f60f94fa8911db7e32c9703"><td class="memTemplParams" colspan="2">template&lt;typename Default , template&lt; typename... &gt; class Op, typename... Args&gt; </td></tr>
<tr class="memitem:ga2f49a21b2f60f94fa8911db7e32c9703"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00409.html#ga2f49a21b2f60f94fa8911db7e32c9703">Dune::Std::detected_or_t</a> = typename <a class="el" href="a00409.html#gadb4713b99082ef169f74666e0ec7a46e">detected_or</a>&lt; Default, Op, Args... &gt;::type</td></tr>
<tr class="memdesc:ga2f49a21b2f60f94fa8911db7e32c9703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>Op&lt;Args...&gt;</code> if that is valid; otherwise returns the fallback type <code>Default</code>.  <a href="a00409.html#ga2f49a21b2f60f94fa8911db7e32c9703">More...</a><br /></td></tr>
<tr class="separator:ga2f49a21b2f60f94fa8911db7e32c9703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6778de5ea60a45fdae6db8b6d8c8b6f7"><td class="memTemplParams" colspan="2">template&lt;typename Expected , template&lt; typename... &gt; class Op, typename... Args&gt; </td></tr>
<tr class="memitem:ga6778de5ea60a45fdae6db8b6d8c8b6f7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00409.html#ga6778de5ea60a45fdae6db8b6d8c8b6f7">Dune::Std::is_detected_exact</a> = std::is_same&lt; Expected, <a class="el" href="a00409.html#ga67b8ffda29f365419403a66e49ec0ffe">detected_t</a>&lt; Op, Args... &gt; &gt;</td></tr>
<tr class="memdesc:ga6778de5ea60a45fdae6db8b6d8c8b6f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>Op&lt;Args...&gt;</code> is <code>Expected</code> without causing an error if <code>Op&lt;Args...&gt;</code> is invalid.  <a href="a00409.html#ga6778de5ea60a45fdae6db8b6d8c8b6f7">More...</a><br /></td></tr>
<tr class="separator:ga6778de5ea60a45fdae6db8b6d8c8b6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf26ed902d20da735bae252683a9ac5ce"><td class="memTemplParams" colspan="2">template&lt;typename Target , template&lt; typename... &gt; class Op, typename... Args&gt; </td></tr>
<tr class="memitem:gaf26ed902d20da735bae252683a9ac5ce"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00409.html#gaf26ed902d20da735bae252683a9ac5ce">Dune::Std::is_detected_convertible</a> = std::is_convertible&lt; Target, <a class="el" href="a00409.html#ga67b8ffda29f365419403a66e49ec0ffe">detected_t</a>&lt; Op, Args... &gt; &gt;</td></tr>
<tr class="memdesc:gaf26ed902d20da735bae252683a9ac5ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>Op&lt;Args...&gt;</code> is convertible to <code>Target</code> without causing an error if <code>Op&lt;Args...&gt;</code> is invalid.  <a href="a00409.html#gaf26ed902d20da735bae252683a9ac5ce">More...</a><br /></td></tr>
<tr class="separator:gaf26ed902d20da735bae252683a9ac5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a3de1d2dbd47536c4b007d3a3b108a2"><td class="memTemplParams" colspan="2">template&lt;class... Types&gt; </td></tr>
<tr class="memitem:ga6a3de1d2dbd47536c4b007d3a3b108a2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00409.html#ga6a3de1d2dbd47536c4b007d3a3b108a2">Dune::void_t</a> = typename Impl::voider&lt; Types... &gt;::type</td></tr>
<tr class="memdesc:ga6a3de1d2dbd47536c4b007d3a3b108a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is void for all valid input types. The workhorse for C++11 SFINAE-techniques.  <a href="a00409.html#ga6a3de1d2dbd47536c4b007d3a3b108a2">More...</a><br /></td></tr>
<tr class="separator:ga6a3de1d2dbd47536c4b007d3a3b108a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadd3a3e69d0220b41bb40ebc442d79ae"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:gaadd3a3e69d0220b41bb40ebc442d79ae"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00409.html#gaadd3a3e69d0220b41bb40ebc442d79ae">Dune::field_t</a> = typename <a class="el" href="a01733.html">FieldTraits</a>&lt; Type &gt;::field_type</td></tr>
<tr class="memdesc:gaadd3a3e69d0220b41bb40ebc442d79ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient access to <a class="el" href="a01733.html#aaaf5412c6ed2f4ac627eec87a2d1de1b" title="export the type representing the field">FieldTraits&lt;Type&gt;::field_type</a>.  <a href="a00409.html#gaadd3a3e69d0220b41bb40ebc442d79ae">More...</a><br /></td></tr>
<tr class="separator:gaadd3a3e69d0220b41bb40ebc442d79ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48aa0bb0268c390d251495eabdac4ae6"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:ga48aa0bb0268c390d251495eabdac4ae6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00409.html#ga48aa0bb0268c390d251495eabdac4ae6">Dune::real_t</a> = typename <a class="el" href="a01733.html">FieldTraits</a>&lt; Type &gt;::real_type</td></tr>
<tr class="memdesc:ga48aa0bb0268c390d251495eabdac4ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient access to <a class="el" href="a01733.html#ab1c1583160e1c47c4909273c82ae7a63" title="export the type representing the real type of the field">FieldTraits&lt;Type&gt;::real_type</a>.  <a href="a00409.html#ga48aa0bb0268c390d251495eabdac4ae6">More...</a><br /></td></tr>
<tr class="separator:ga48aa0bb0268c390d251495eabdac4ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64c2d9377550162293c4fabd163f457b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga64c2d9377550162293c4fabd163f457b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00409.html#ga64c2d9377550162293c4fabd163f457b">Dune::AutonomousValue</a> = typename <a class="el" href="a03121.html">AutonomousValueType</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:ga64c2d9377550162293c4fabd163f457b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type free of internal references that <code>T</code> can be converted to.  <a href="a00409.html#ga64c2d9377550162293c4fabd163f457b">More...</a><br /></td></tr>
<tr class="separator:ga64c2d9377550162293c4fabd163f457b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae007ebc02578de3fe994b28e4378fd80"><td class="memTemplParams" colspan="2">template&lt;class... F&gt; </td></tr>
<tr class="memitem:gae007ebc02578de3fe994b28e4378fd80"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00409.html#gae007ebc02578de3fe994b28e4378fd80">Dune::overload</a> (F &amp;&amp;... f)</td></tr>
<tr class="memdesc:gae007ebc02578de3fe994b28e4378fd80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an overload set.  <a href="a00409.html#gae007ebc02578de3fe994b28e4378fd80">More...</a><br /></td></tr>
<tr class="separator:gae007ebc02578de3fe994b28e4378fd80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85390a9ae268b1ed2be79b8637e8becd"><td class="memTemplParams" colspan="2">template&lt;class... F&gt; </td></tr>
<tr class="memitem:ga85390a9ae268b1ed2be79b8637e8becd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00409.html#ga85390a9ae268b1ed2be79b8637e8becd">Dune::orderedOverload</a> (F &amp;&amp;... f)</td></tr>
<tr class="memdesc:ga85390a9ae268b1ed2be79b8637e8becd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an ordered overload set.  <a href="a00409.html#ga85390a9ae268b1ed2be79b8637e8becd">More...</a><br /></td></tr>
<tr class="separator:ga85390a9ae268b1ed2be79b8637e8becd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab204e4c1df410966214b242af99406a1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab204e4c1df410966214b242af99406a1"><td class="memTemplItemLeft" align="right" valign="top">pointer_or_proxy_holder&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00409.html#gab204e4c1df410966214b242af99406a1">Dune::handle_proxy_member_access</a> (T &amp;&amp;t)</td></tr>
<tr class="memdesc:gab204e4c1df410966214b242af99406a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transparent support for providing member access to both lvalues and rvalues (temporary proxies).  <a href="a00409.html#gab204e4c1df410966214b242af99406a1">More...</a><br /></td></tr>
<tr class="separator:gab204e4c1df410966214b242af99406a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bc9a120a411bddf93f2c58977befa63"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ga4bc9a120a411bddf93f2c58977befa63"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; typename std::common_type&lt; Args... &gt;::type, sizeof...(Args)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00409.html#ga4bc9a120a411bddf93f2c58977befa63">Dune::Std::make_array</a> (const Args &amp;... args)</td></tr>
<tr class="memdesc:ga4bc9a120a411bddf93f2c58977befa63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and initialize an array.  <a href="a00409.html#ga4bc9a120a411bddf93f2c58977befa63">More...</a><br /></td></tr>
<tr class="separator:ga4bc9a120a411bddf93f2c58977befa63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fe355ad7447f0f4bc8ae0b6a39f6318"><td class="memTemplParams" colspan="2">template&lt;class T , T... t, std::size_t index&gt; </td></tr>
<tr class="memitem:ga0fe355ad7447f0f4bc8ae0b6a39f6318"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00409.html#ga0fe355ad7447f0f4bc8ae0b6a39f6318">Dune::integerSequenceEntry</a> (std::integer_sequence&lt; T, t... &gt;, std::integral_constant&lt; std::size_t, index &gt; i)</td></tr>
<tr class="memdesc:ga0fe355ad7447f0f4bc8ae0b6a39f6318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get entry of std::integer_sequence.  <a href="a00409.html#ga0fe355ad7447f0f4bc8ae0b6a39f6318">More...</a><br /></td></tr>
<tr class="separator:ga0fe355ad7447f0f4bc8ae0b6a39f6318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab256c9245e4037f7f42aa453e00fd97a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gab256c9245e4037f7f42aa453e00fd97a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a00409.html#ga64c2d9377550162293c4fabd163f457b">AutonomousValue</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00409.html#gab256c9245e4037f7f42aa453e00fd97a">Dune::autoCopy</a> (T &amp;&amp;v)</td></tr>
<tr class="memdesc:gab256c9245e4037f7f42aa453e00fd97a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Autonomous copy of an expression's value for use in <code>auto</code> type deduction.  <a href="a00409.html#gab256c9245e4037f7f42aa453e00fd97a">More...</a><br /></td></tr>
<tr class="separator:gab256c9245e4037f7f42aa453e00fd97a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga9f0b8af5e80b339c8346a327f28bab33"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename... &gt; class Op, typename... Args&gt; </td></tr>
<tr class="memitem:ga9f0b8af5e80b339c8346a327f28bab33"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00409.html#ga9f0b8af5e80b339c8346a327f28bab33">Dune::Std::is_detected_v</a> = <a class="el" href="a00409.html#gaccaa5104ef0c27be164435f42ef81fd5">is_detected</a>&lt;Op,Args...&gt;::value</td></tr>
<tr class="memdesc:ga9f0b8af5e80b339c8346a327f28bab33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects whether <code>Op&lt;Args...&gt;</code> is valid and makes the result available as a value.  <a href="a00409.html#ga9f0b8af5e80b339c8346a327f28bab33">More...</a><br /></td></tr>
<tr class="separator:ga9f0b8af5e80b339c8346a327f28bab33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga043d312181849f21d950de3f7198bac6"><td class="memTemplParams" colspan="2">template&lt;typename Expected , template&lt; typename... &gt; class Op, typename... Args&gt; </td></tr>
<tr class="memitem:ga043d312181849f21d950de3f7198bac6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00409.html#ga043d312181849f21d950de3f7198bac6">Dune::Std::is_detected_exact_v</a> = <a class="el" href="a00409.html#ga6778de5ea60a45fdae6db8b6d8c8b6f7">is_detected_exact</a>&lt;Expected,Op,Args...&gt;::value</td></tr>
<tr class="memdesc:ga043d312181849f21d950de3f7198bac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient access to the result value of is_detected_exact.  <a href="a00409.html#ga043d312181849f21d950de3f7198bac6">More...</a><br /></td></tr>
<tr class="separator:ga043d312181849f21d950de3f7198bac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga044daf77dd81fbaeb71a7ce6d15bf761"><td class="memTemplParams" colspan="2">template&lt;typename Target , template&lt; typename... &gt; class Op, typename... Args&gt; </td></tr>
<tr class="memitem:ga044daf77dd81fbaeb71a7ce6d15bf761"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00409.html#ga044daf77dd81fbaeb71a7ce6d15bf761">Dune::Std::is_detected_convertible_v</a> = <a class="el" href="a00409.html#gaf26ed902d20da735bae252683a9ac5ce">is_detected_convertible</a>&lt;Target,Op,Args...&gt;::value</td></tr>
<tr class="memdesc:ga044daf77dd81fbaeb71a7ce6d15bf761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient access to the result value of is_detected_convertible.  <a href="a00409.html#ga044daf77dd81fbaeb71a7ce6d15bf761">More...</a><br /></td></tr>
<tr class="separator:ga044daf77dd81fbaeb71a7ce6d15bf761"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Standard library features backported from newer C++ versions or technical specifications and DUNE-specific utilities. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga902aaece2c20a75cbf6daad4957ba069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga902aaece2c20a75cbf6daad4957ba069">&#9670;&nbsp;</a></span>DUNE_ASSERT_AND_RETURN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DUNE_ASSERT_AND_RETURN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">C, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">X&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(!(C) ? throw [&amp;](){assert(!#C);return 0;}() : 0), X</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asserts a condition and return on success in constexpr context. </p>
<p>The macro DUNE_ASSERT_AND_RETURN can be used as expression in the return statement of a constexpr function to have assert() and constexpr at the same time. It first uses assert for the condition given by the first argument and then returns the value of the second argument. </p>

</div>
</div>
<a id="gab56b68b6f47fe5b4f2bbd28d2227ca4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab56b68b6f47fe5b4f2bbd28d2227ca4a">&#9670;&nbsp;</a></span>DUNE_DEPRECATED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DUNE_DEPRECATED</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark some entity as deprecated. </p>
<dl class="deprecated"><dt><b><a class="el" href="a00399.html#_deprecated000002">Deprecated:</a></b></dt><dd>Use C++14's</dd></dl>
<div class="fragment"><div class="line">[[deprecated]]</div>
</div><!-- fragment --><p> instead. It will be removed after <a class="el" href="a00428.html" title="Dune namespace.">Dune</a> 2.8. Be aware that it must be sometimes placed at different position in the code. </p>

</div>
</div>
<a id="ga98dcbe0cf30aec44df67e481fd82414c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98dcbe0cf30aec44df67e481fd82414c">&#9670;&nbsp;</a></span>DUNE_DEPRECATED_MSG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DUNE_DEPRECATED_MSG</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">text</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="a00409.html#gab56b68b6f47fe5b4f2bbd28d2227ca4a">DUNE_DEPRECATED</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark some entity as deprecated. </p>
<dl class="deprecated"><dt><b><a class="el" href="a00399.html#_deprecated000003">Deprecated:</a></b></dt><dd>Use C++14's</dd></dl>
<div class="fragment"><div class="line">[[deprecated(msg)]]</div>
</div><!-- fragment --><p> instead. It will be removed after <a class="el" href="a00428.html" title="Dune namespace.">Dune</a> 2.8. Be aware that it must be sometimes placed at different position in the code. </p>

</div>
</div>
<a id="ga74d440d098178dc5a4adea8f7c160e99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74d440d098178dc5a4adea8f7c160e99">&#9670;&nbsp;</a></span>DUNE_NO_DEPRECATED_BEGIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DUNE_NO_DEPRECATED_BEGIN&#160;&#160;&#160;...</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ignore deprecation warnings (start) </p>
<p>This macro can be used together with <code>DUNE_NO_DEPRECATED_END</code> to mark a block in which deprecation warnings are ignored. This can be useful for implementations of deprecated methods that call other deprecated methods or for testing deprecated methods in the testsuite.</p>
<div class="fragment"><div class="line"><a class="code" href="a00409.html#ga74d440d098178dc5a4adea8f7c160e99">DUNE_NO_DEPRECATED_BEGIN</a></div>
<div class="line">some_deprecated_function();</div>
<div class="line">another_deprecated_function();</div>
<div class="line"><a class="code" href="a00409.html#ga664ae9266c2a074c71746e68aaa8eb6a">DUNE_NO_DEPRECATED_END</a></div>
<div class="ttc" id="aa00409_html_ga664ae9266c2a074c71746e68aaa8eb6a"><div class="ttname"><a href="a00409.html#ga664ae9266c2a074c71746e68aaa8eb6a">DUNE_NO_DEPRECATED_END</a></div><div class="ttdeci">#define DUNE_NO_DEPRECATED_END</div><div class="ttdoc">Ignore deprecation warnings (end)</div><div class="ttdef"><b>Definition:</b> deprecated.hh:61</div></div>
<div class="ttc" id="aa00409_html_ga74d440d098178dc5a4adea8f7c160e99"><div class="ttname"><a href="a00409.html#ga74d440d098178dc5a4adea8f7c160e99">DUNE_NO_DEPRECATED_BEGIN</a></div><div class="ttdeci">#define DUNE_NO_DEPRECATED_BEGIN</div><div class="ttdoc">Ignore deprecation warnings (start)</div><div class="ttdef"><b>Definition:</b> deprecated.hh:55</div></div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>This macro must always be used together with <code>DUNE_NO_DEPRECATED_END</code> </dd></dl>

</div>
</div>
<a id="ga664ae9266c2a074c71746e68aaa8eb6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga664ae9266c2a074c71746e68aaa8eb6a">&#9670;&nbsp;</a></span>DUNE_NO_DEPRECATED_END</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DUNE_NO_DEPRECATED_END&#160;&#160;&#160;...</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ignore deprecation warnings (end) </p>
<dl class="section warning"><dt>Warning</dt><dd>This macro must always be used together with <code>DUNE_NO_DEPRECATED_BEGIN</code> </dd></dl>

</div>
</div>
<a id="ga53be527752cf155b994e29d457629050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53be527752cf155b994e29d457629050">&#9670;&nbsp;</a></span>DUNE_UNUSED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DUNE_UNUSED</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A macro for marking variables that the compiler mistakenly flags as unused, which sometimes happens due to templates. </p>
<dl class="deprecated"><dt><b><a class="el" href="a00399.html#_deprecated000018">Deprecated:</a></b></dt><dd>Use C++17's</dd></dl>
<div class="fragment"><div class="line">[[maybe_unused]]</div>
</div><!-- fragment --><p> instead. This macro will be removed after <a class="el" href="a00428.html" title="Dune namespace.">Dune</a> 2.8. Be aware that it must be sometimes placed at a different position in the code. </p>

</div>
</div>
<a id="gabedfe90a62e9dfc989b8298fec44801b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabedfe90a62e9dfc989b8298fec44801b">&#9670;&nbsp;</a></span>DUNE_UNUSED_PARAMETER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DUNE_UNUSED_PARAMETER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">parm</td><td>)</td>
          <td>&#160;&#160;&#160;static_cast&lt;void&gt;(parm)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A macro to mark intentionally unused function parameters with.</p>
<p>If possible use C++17's</p><div class="fragment"><div class="line">[[maybe_unused]]</div>
</div><!-- fragment --><p> instead. Due to a bug prior to GCC 9.3 it cannot be used for the first argument of a constructor (bug 81429). </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga64c2d9377550162293c4fabd163f457b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64c2d9377550162293c4fabd163f457b">&#9670;&nbsp;</a></span>AutonomousValue</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00409.html#ga64c2d9377550162293c4fabd163f457b">Dune::AutonomousValue</a> = typedef typename <a class="el" href="a03121.html">AutonomousValueType</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type free of internal references that <code>T</code> can be converted to. </p>
<p>Specialize <code><a class="el" href="a03121.html" title="Type free of internal references that T can be converted to.">AutonomousValueType</a></code> to add your own mapping. Use <code><a class="el" href="a00409.html#gab256c9245e4037f7f42aa453e00fd97a" title="Autonomous copy of an expression&#39;s value for use in auto type deduction.">autoCopy()</a></code> to convert an expression of type <code>T</code> to <code>AutonomousValue&lt;T&gt;</code>.</p>
<p>This type alias determines a type that <code>T</code> can be converted to, but that will be free of references to other objects that it does not manage. In practice it will act like <code>std::decay_t</code>, but in addition to removing references it will also determine the types that proxies stand in for, and the types that expression templates will evaluate to.</p>
<p>"Free of references" means that the converted object will always be valid and does not alias any other objects directly or indirectly. The "other
objects that it does not manage" restriction means that the converted object may still contain internal references, but they must be to resources that it manages itself. So, an <code>std::vector</code> would be an autonomous value even though it contains internal references to the storage for the elements since it manages that storage itself.</p>
<dl class="section note"><dt>Note</dt><dd>For pointers, iterators, and the like the "value" for the purpose of <code>AutonomousValue</code> is considered to be the identity of the pointed-to object, so that object should not be cloned. But then you should hopefully never need an autonomous value for those anyway... </dd></dl>

</div>
</div>
<a id="gadb4713b99082ef169f74666e0ec7a46e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb4713b99082ef169f74666e0ec7a46e">&#9670;&nbsp;</a></span>detected_or</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Default , template&lt; typename... &gt; class Op, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00409.html#gadb4713b99082ef169f74666e0ec7a46e">Dune::Std::detected_or</a> = typedef Impl::detector&lt;Default,void,Op,Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detects whether <code>Op&lt;Args...&gt;</code> is valid and makes the result available. </p>
<p>This alias template is an alias for an unspecified class type with two nested <code>typedefs</code> <code>value_t</code> and <code>type</code>. It can be used to detect whether the meta function call <code>Op&lt;Args...&gt;</code> is valid and access the result of the call by inspecting the returned type, which is defined as follows:</p>
<ul>
<li>If <code>Op&lt;Args...&gt;</code> can be instantiated, <code>value_t</code> is an alias for <code>std::true_type</code> and <code>type</code> is an alias for <code>Op&lt;Args...&gt;</code>.</li>
<li>If <code>Op&lt;Args...&gt;</code> is invalid, <code>value_t</code> is an alias for <code>std::false_type</code> and <code>type</code> is an alias for <code>Default</code>.</li>
</ul>
<p>This can be used to safely extract a nested <code>typedef</code> from a type <code>T</code> that might not define the <code>typedef</code>: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>A { <span class="keyword">using</span> size_type = int ; };</div>
<div class="line"><span class="keyword">struct </span>B;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">using</span> SizeType = <span class="keyword">typename</span> T::size_type;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// this extracts the nested typedef for int</span></div>
<div class="line"><span class="keyword">using</span> st_a = <span class="keyword">typename</span> detected_or&lt;std::size_t,SizeType,A&gt;::type;</div>
<div class="line"><span class="comment">// as there is no nested typedef in B, this yields std::size_t</span></div>
<div class="line"><span class="keyword">using</span> st_b = <span class="keyword">typename</span> detected_or&lt;std::size_t,SizeType,B&gt;::type;</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This functionality is part of the C++ library fundamentals TS v2 and might or might not became part of C++2a. </dd></dl>

</div>
</div>
<a id="ga2f49a21b2f60f94fa8911db7e32c9703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f49a21b2f60f94fa8911db7e32c9703">&#9670;&nbsp;</a></span>detected_or_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Default , template&lt; typename... &gt; class Op, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00409.html#ga2f49a21b2f60f94fa8911db7e32c9703">Dune::Std::detected_or_t</a> = typedef typename <a class="el" href="a00409.html#gadb4713b99082ef169f74666e0ec7a46e">detected_or</a>&lt;Default,Op,Args...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>Op&lt;Args...&gt;</code> if that is valid; otherwise returns the fallback type <code>Default</code>. </p>
<p>This alias template can be used to instantiate <code>Op&lt;Args...&gt;</code> in a context that is not SFINAE-safe by appropriately wrapping the instantiation and automatically falling back to <code>Default</code> if instantiation fails.</p>
<dl class="section note"><dt>Note</dt><dd>This functionality is part of the C++ library fundamentals TS v2 and might or might not became part of C++2a. </dd></dl>

</div>
</div>
<a id="ga67b8ffda29f365419403a66e49ec0ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67b8ffda29f365419403a66e49ec0ffe">&#9670;&nbsp;</a></span>detected_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename... &gt; class Op, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00409.html#ga67b8ffda29f365419403a66e49ec0ffe">Dune::Std::detected_t</a> = typedef typename <a class="el" href="a00409.html#gadb4713b99082ef169f74666e0ec7a46e">detected_or</a>&lt;<a class="el" href="a02865.html">nonesuch</a>,Op,Args...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>Op&lt;Args...&gt;</code> if that is valid; otherwise returns nonesuch. </p>
<p>This alias template can be used to instantiate <code>Op&lt;Args...&gt;</code> in a context that is not SFINAE-safe by appropriately wrapping the instantiation. If instantiation fails, the marker type nonesuch is returned instead.</p>
<dl class="section note"><dt>Note</dt><dd>This functionality is part of the C++ library fundamentals TS v2 and might or might not became part of C++2a. </dd></dl>

</div>
</div>
<a id="gaadd3a3e69d0220b41bb40ebc442d79ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadd3a3e69d0220b41bb40ebc442d79ae">&#9670;&nbsp;</a></span>field_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00409.html#gaadd3a3e69d0220b41bb40ebc442d79ae">Dune::field_t</a> = typedef typename <a class="el" href="a01733.html">FieldTraits</a>&lt;Type&gt;::field_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenient access to <a class="el" href="a01733.html#aaaf5412c6ed2f4ac627eec87a2d1de1b" title="export the type representing the field">FieldTraits&lt;Type&gt;::field_type</a>. </p>

</div>
</div>
<a id="gaccaa5104ef0c27be164435f42ef81fd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccaa5104ef0c27be164435f42ef81fd5">&#9670;&nbsp;</a></span>is_detected</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename... &gt; class Op, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00409.html#gaccaa5104ef0c27be164435f42ef81fd5">Dune::Std::is_detected</a> = typedef typename <a class="el" href="a00409.html#gadb4713b99082ef169f74666e0ec7a46e">detected_or</a>&lt;<a class="el" href="a02865.html">nonesuch</a>,Op,Args...&gt;::value_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detects whether <code>Op&lt;Args...&gt;</code> is valid. </p>
<p>This alias template checks whether <code>Op&lt;Args...&gt;</code> can be instantiated. It is equivalent to <code>typename detected_or&lt;nonesuch,Op,Args...&gt;::value_t</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This functionality is part of the C++ library fundamentals TS v2 and might or might not became part of C++2a. </dd></dl>

</div>
</div>
<a id="gaf26ed902d20da735bae252683a9ac5ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf26ed902d20da735bae252683a9ac5ce">&#9670;&nbsp;</a></span>is_detected_convertible</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Target , template&lt; typename... &gt; class Op, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00409.html#gaf26ed902d20da735bae252683a9ac5ce">Dune::Std::is_detected_convertible</a> = typedef std::is_convertible&lt;Target,<a class="el" href="a00409.html#ga67b8ffda29f365419403a66e49ec0ffe">detected_t</a>&lt;Op,Args...&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether <code>Op&lt;Args...&gt;</code> is convertible to <code>Target</code> without causing an error if <code>Op&lt;Args...&gt;</code> is invalid. </p>
<dl class="section note"><dt>Note</dt><dd>This functionality is part of the C++ library fundamentals TS v2 and might or might not became part of C++2a. </dd></dl>

</div>
</div>
<a id="ga6778de5ea60a45fdae6db8b6d8c8b6f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6778de5ea60a45fdae6db8b6d8c8b6f7">&#9670;&nbsp;</a></span>is_detected_exact</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Expected , template&lt; typename... &gt; class Op, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00409.html#ga6778de5ea60a45fdae6db8b6d8c8b6f7">Dune::Std::is_detected_exact</a> = typedef std::is_same&lt;Expected,<a class="el" href="a00409.html#ga67b8ffda29f365419403a66e49ec0ffe">detected_t</a>&lt;Op,Args...&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether <code>Op&lt;Args...&gt;</code> is <code>Expected</code> without causing an error if <code>Op&lt;Args...&gt;</code> is invalid. </p>
<dl class="section note"><dt>Note</dt><dd>This functionality is part of the C++ library fundamentals TS v2 and might or might not became part of C++2a. </dd></dl>

</div>
</div>
<a id="ga48aa0bb0268c390d251495eabdac4ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48aa0bb0268c390d251495eabdac4ae6">&#9670;&nbsp;</a></span>real_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00409.html#ga48aa0bb0268c390d251495eabdac4ae6">Dune::real_t</a> = typedef typename <a class="el" href="a01733.html">FieldTraits</a>&lt;Type&gt;::real_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenient access to <a class="el" href="a01733.html#ab1c1583160e1c47c4909273c82ae7a63" title="export the type representing the real type of the field">FieldTraits&lt;Type&gt;::real_type</a>. </p>

</div>
</div>
<a id="ga6a3de1d2dbd47536c4b007d3a3b108a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a3de1d2dbd47536c4b007d3a3b108a2">&#9670;&nbsp;</a></span>void_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00409.html#ga6a3de1d2dbd47536c4b007d3a3b108a2">Dune::void_t</a> = typedef typename Impl::voider&lt;Types...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is void for all valid input types. The workhorse for C++11 SFINAE-techniques. </p>
<p>Note, since c++17 there is also <code>std::void_t</code> that should be preferred. But, due to an issue in the c++ standard, see CWG issue #1980. "Equivalent but not functionally-equivalent redeclarations", and a corresponding failure in some clang compilers, this tool is left here as a workaround. Use it if you want to specialize multiple classes using <code>void_t</code>. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab256c9245e4037f7f42aa453e00fd97a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab256c9245e4037f7f42aa453e00fd97a">&#9670;&nbsp;</a></span>autoCopy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a00409.html#ga64c2d9377550162293c4fabd163f457b">AutonomousValue</a>&lt;T&gt; Dune::autoCopy </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Autonomous copy of an expression's value for use in <code>auto</code> type deduction. </p>
<p>This function is an unproxyfier or an expression evaluator or a fancy cast to ensure an expression can be used in <code>auto</code> type deduction. It ensures two things:</p>
<ol type="1">
<li>The return value is a prvalue,</li>
<li>the returned value is self-sufficient, or "autonomous".</li>
</ol>
<p>The latter means that there will be no references into other objects (like containers) which are not guaranteed to be kept alive during the lifetime of the returned value.</p>
<p>An example usage would be </p><div class="fragment"><div class="line">{c++}</div>
<div class="line"> std::vector&lt;bool&gt; bitvector{24};</div>
<div class="line"> <span class="keyword">auto</span> value = <a class="code" href="a00409.html#gab256c9245e4037f7f42aa453e00fd97a">autoCopy</a>(bitvector[23]);</div>
<div class="line"> bitvector.resize(42);</div>
<div class="line"> <span class="comment">// value still valid</span></div>
<div class="ttc" id="aa00409_html_gab256c9245e4037f7f42aa453e00fd97a"><div class="ttname"><a href="a00409.html#gab256c9245e4037f7f42aa453e00fd97a">Dune::autoCopy</a></div><div class="ttdeci">constexpr AutonomousValue&lt; T &gt; autoCopy(T &amp;&amp;v)</div><div class="ttdoc">Autonomous copy of an expression's value for use in auto type deduction.</div><div class="ttdef"><b>Definition:</b> typetraits.hh:642</div></div>
</div><!-- fragment --><p> Since <code>vector&lt;bool&gt;</code> may use proxies, <code>auto value = bitvector[23];</code> would mean that the type of <code>value</code> is such a proxy. The proxy keeps internal references into the vector, and thus can be invalidated by anything that modifies the vector &ndash; such as a later call to <code>resize()</code>. <code><a class="el" href="a00409.html#gab256c9245e4037f7f42aa453e00fd97a" title="Autonomous copy of an expression&#39;s value for use in auto type deduction.">autoCopy()</a></code> lets you work around that problem by copying the value referenced by the proxy and converting it to a <code>bool</code>.</p>
<p>Another example would be an automatic differentiation library that lets you track the operations in a computation, and later ask for derivatives. Imagine that your operation involves a parameter function, and you want to use that function both with plain types and with automatic differentiation types. You might write the parameter function as follows: </p><div class="fragment"><div class="line">{c++}</div>
<div class="line"> <span class="keyword">template</span>&lt;<span class="keyword">class</span> NumberType&gt;</div>
<div class="line"> <span class="keyword">auto</span> param(NumberType v)</div>
<div class="line"> {</div>
<div class="line">   <span class="keywordflow">return</span> 2*v;</div>
<div class="line"> }</div>
</div><!-- fragment --><p> If the automatic differentiation library is Adept, this would lead to use-after-end-of-life-bugs. The reason is that for efficiency reasons Adept does not immidiately evaluate the expression, but instead it constructs an expression object that records the kind of expression and references to the operands. The expression object is only evaluated when it is assigned to an object of some number type &ndash; which will only happen after the operands (<code>v</code> and the temporary object representing <code>2</code>) have gone out of scope and been destroyed. Basically, Adept was invented before <code>auto</code> and rvalue-references were a thing.</p>
<p>This can be handled with <code><a class="el" href="a00409.html#gab256c9245e4037f7f42aa453e00fd97a" title="Autonomous copy of an expression&#39;s value for use in auto type deduction.">autoCopy()</a></code>: </p><div class="fragment"><div class="line">{c++}</div>
<div class="line"> <span class="keyword">template</span>&lt;<span class="keyword">class</span> NumberType&gt;</div>
<div class="line"> <span class="keyword">auto</span> param(NumberType v)</div>
<div class="line"> {</div>
<div class="line">   <span class="keywordflow">return</span> <a class="code" href="a00409.html#gab256c9245e4037f7f42aa453e00fd97a">autoCopy</a>(2*v);</div>
<div class="line"> }</div>
</div><!-- fragment --><p> Of course, <code><a class="el" href="a00409.html#gab256c9245e4037f7f42aa453e00fd97a" title="Autonomous copy of an expression&#39;s value for use in auto type deduction.">autoCopy()</a></code> needs to be taught about the expression objects of Adept for this to work.</p>
<p><code><a class="el" href="a00409.html#gab256c9245e4037f7f42aa453e00fd97a" title="Autonomous copy of an expression&#39;s value for use in auto type deduction.">autoCopy()</a></code> will by default simply return the argument as a prvalue of the same type with cv-qualifiers removed. This involves one or more copy/move operation, so it will only work with types that are in fact copyable. And it will incur one copy if the compiler cannot use a move, such as when the type of the expression is a <code>std::array</code> or a <code><a class="el" href="a01401.html" title="A dense n x m matrix.">FieldMatrix</a></code>. (Any second copy that may semantically be necessary will be elided.)</p>
<p>To teach <code><a class="el" href="a00409.html#gab256c9245e4037f7f42aa453e00fd97a" title="Autonomous copy of an expression&#39;s value for use in auto type deduction.">autoCopy()</a></code> about a particular proxy type, specialize <code><a class="el" href="a03121.html" title="Type free of internal references that T can be converted to.">Dune::AutonomousValueType</a></code>.</p>
<dl class="section note"><dt>Note</dt><dd>Do not overload <code><a class="el" href="a00409.html#gab256c9245e4037f7f42aa453e00fd97a" title="Autonomous copy of an expression&#39;s value for use in auto type deduction.">Dune::autoCopy()</a></code> directly. It is meant to be found by unqualified or qualified lookup, not by ADL. There is little guarantee that your overload will be declared before the definition of internal <a class="el" href="a00428.html" title="Dune namespace.">Dune</a> functions that use <code><a class="el" href="a00409.html#gab256c9245e4037f7f42aa453e00fd97a" title="Autonomous copy of an expression&#39;s value for use in auto type deduction.">autoCopy()</a></code>. They would need the lazy binding provided by ADL to find your overload, but they will probably use unqualified lookup. </dd></dl>

</div>
</div>
<a id="gab204e4c1df410966214b242af99406a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab204e4c1df410966214b242af99406a1">&#9670;&nbsp;</a></span>handle_proxy_member_access()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">pointer_or_proxy_holder Dune::handle_proxy_member_access </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transparent support for providing member access to both lvalues and rvalues (temporary proxies). </p>
<p>If an iterator facade (like entity iterators) wants to allow the embedded implementation to return either an (internally stored) reference or a temporary object and expose these two behaviors to enable performance optimizations, operator-&gt;() needs special handling: If the implementation returns a reference, operator-&gt;() in the facade can simply return the address of the referenced object, but if the returned object is a temporary, we need to capture and store it in a helper object to make sure it outlives the member access. This function transparently supports both variants. It should be used like this:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>iterator</div>
<div class="line">{</div>
<div class="line">  ...</div>
<div class="line"> </div>
<div class="line">  decltype(<a class="code" href="a00409.html#gab204e4c1df410966214b242af99406a1">handle_proxy_member_access</a>(implementation.dereference()))</div>
<div class="line">  operator-&gt;()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="a00409.html#gab204e4c1df410966214b242af99406a1">handle_proxy_member_access</a>(implementation.dereference());</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  ...</div>
<div class="line">};</div>
<div class="ttc" id="aa00409_html_gab204e4c1df410966214b242af99406a1"><div class="ttname"><a href="a00409.html#gab204e4c1df410966214b242af99406a1">Dune::handle_proxy_member_access</a></div><div class="ttdeci">pointer_or_proxy_holder handle_proxy_member_access(T &amp;&amp;t)</div><div class="ttdoc">Transparent support for providing member access to both lvalues and rvalues (temporary proxies).</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This function exploits the special type deduction rules for unqualified rvalue references to distinguish between lvalues and rvalues and thus needs to be passed the object returned by the implementation. </dd></dl>

</div>
</div>
<a id="ga0fe355ad7447f0f4bc8ae0b6a39f6318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fe355ad7447f0f4bc8ae0b6a39f6318">&#9670;&nbsp;</a></span>integerSequenceEntry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , T... t, std::size_t index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto Dune::integerSequenceEntry </td>
          <td>(</td>
          <td class="paramtype">std::integer_sequence&lt; T, t... &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::integral_constant&lt; std::size_t, index &gt;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get entry of std::integer_sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>An object of type std::integer_sequence&lt;...&gt; </td></tr>
    <tr><td class="paramname">i</td><td>Index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The i-th entry of the integer_sequence encoded as std::integral_constant&lt;std::size_t, entry&gt;. </dd></dl>

</div>
</div>
<a id="ga4bc9a120a411bddf93f2c58977befa63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bc9a120a411bddf93f2c58977befa63">&#9670;&nbsp;</a></span>make_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;typename std::common_type&lt;Args...&gt;::type, sizeof...(Args)&gt; Dune::Std::make_array </td>
          <td>(</td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and initialize an array. </p>
<dl class="section note"><dt>Note</dt><dd>This method is a somewhat limited dune-specific version of <a class="el" href="a00409.html#ga4bc9a120a411bddf93f2c58977befa63" title="Create and initialize an array.">make_array()</a> as proposed for C++17 (see <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4391.html">N4391</a>, accepted <a href="https://botondballo.wordpress.com/2015/06/05/trip-report-c-standards-meeting-in-lenexa-may-2015/">May 2015</a>). The differences are that this version should never be used with expliclitly given template arguments, or with std::reference_wrapper&lt;...&gt; arguments, and we do not give a diagnostic when anyone happens to do that.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="a00399.html#_deprecated000008">Deprecated:</a></b></dt><dd>Use deduction guide of <code>std::array</code> or <code>std::to_array</code>. </dd></dl>

</div>
</div>
<a id="ga85390a9ae268b1ed2be79b8637e8becd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85390a9ae268b1ed2be79b8637e8becd">&#9670;&nbsp;</a></span>orderedOverload()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... F&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Dune::orderedOverload </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;...&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an ordered overload set. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>List of function object types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>List of function objects</td></tr>
  </table>
  </dd>
</dl>
<p>This returns an object that contains all operator() implementations of the passed functions. All those are available when calling operator() of the returned object.</p>
<p>In contrast to <a class="el" href="a00409.html#gae007ebc02578de3fe994b28e4378fd80" title="Create an overload set.">overload()</a> these overloads are ordered in the sense that the first matching overload for the given arguments is selected and later ones are ignored. Hence such a call is never ambiguous.</p>
<p>Notice that the passed function objects are stored by value and must be copy-constructible. </p>

</div>
</div>
<a id="gae007ebc02578de3fe994b28e4378fd80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae007ebc02578de3fe994b28e4378fd80">&#9670;&nbsp;</a></span>overload()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... F&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Dune::overload </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;...&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an overload set. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>List of function object types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>List of function objects</td></tr>
  </table>
  </dd>
</dl>
<p>This returns an object that contains all operator() implementations of the passed functions. All those are available when calling operator() of the returned object.</p>
<p>The returned object derives from those implementations such that it contains all operator() implementations in its overload set. When calling operator() this will select the best overload. If multiple overload are equally good this will lead to ambiguity.</p>
<p>Notice that the passed function objects are stored by value and must be copy-constructible. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga044daf77dd81fbaeb71a7ce6d15bf761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga044daf77dd81fbaeb71a7ce6d15bf761">&#9670;&nbsp;</a></span>is_detected_convertible_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Target , template&lt; typename... &gt; class Op, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool Dune::Std::is_detected_convertible_v = <a class="el" href="a00409.html#gaf26ed902d20da735bae252683a9ac5ce">is_detected_convertible</a>&lt;Target,Op,Args...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenient access to the result value of is_detected_convertible. </p>
<dl class="section note"><dt>Note</dt><dd>This functionality is part of the C++ library fundamentals TS v2 and might or might not became part of C++2a. </dd></dl>

</div>
</div>
<a id="ga043d312181849f21d950de3f7198bac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga043d312181849f21d950de3f7198bac6">&#9670;&nbsp;</a></span>is_detected_exact_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Expected , template&lt; typename... &gt; class Op, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool Dune::Std::is_detected_exact_v = <a class="el" href="a00409.html#ga6778de5ea60a45fdae6db8b6d8c8b6f7">is_detected_exact</a>&lt;Expected,Op,Args...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenient access to the result value of is_detected_exact. </p>
<dl class="section note"><dt>Note</dt><dd>This functionality is part of the C++ library fundamentals TS v2 and might or might not became part of C++2a. </dd></dl>

</div>
</div>
<a id="ga9f0b8af5e80b339c8346a327f28bab33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f0b8af5e80b339c8346a327f28bab33">&#9670;&nbsp;</a></span>is_detected_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename... &gt; class Op, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool Dune::Std::is_detected_v = <a class="el" href="a00409.html#gaccaa5104ef0c27be164435f42ef81fd5">is_detected</a>&lt;Op,Args...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detects whether <code>Op&lt;Args...&gt;</code> is valid and makes the result available as a value. </p>
<p>This constexpr variable checks whether <code>Op&lt;Args...&gt;</code> can be instantiated. It is equivalent to <code>is_detected&lt;Op,Args...&gt;::value</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This functionality is part of the C++ library fundamentals TS v2 and might or might not became part of C++2a. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
