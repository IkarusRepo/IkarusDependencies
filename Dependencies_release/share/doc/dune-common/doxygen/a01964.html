<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>dune-common: Dune::Communication&lt; Communicator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">dune-common
   &#160;<span id="projectnumber">2.7.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00428.html">Dune</a></li><li class="navelem"><a class="el" href="a01964.html">Communication</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="a01961.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Dune::Communication&lt; Communicator &gt; Class Template Reference<div class="ingroups"><a class="el" href="a00400.html">Common</a> &raquo; <a class="el" href="a00418.html">Parallel Communication</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Collective communication interface and sequential default implementation.  
 <a href="a01964.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00179_source.html">dune/common/parallel/communication.hh</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af9873f31f9e81114b4edcc50b01b0a3c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01964.html#af9873f31f9e81114b4edcc50b01b0a3c">Communication</a> ()</td></tr>
<tr class="memdesc:af9873f31f9e81114b4edcc50b01b0a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct default object.  <a href="a01964.html#af9873f31f9e81114b4edcc50b01b0a3c">More...</a><br /></td></tr>
<tr class="separator:af9873f31f9e81114b4edcc50b01b0a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0e5bd2a26b9faa9e838f6511251299"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01964.html#a8e0e5bd2a26b9faa9e838f6511251299">Communication</a> (const Communicator &amp;)</td></tr>
<tr class="memdesc:a8e0e5bd2a26b9faa9e838f6511251299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with a given communicator.  <a href="a01964.html#a8e0e5bd2a26b9faa9e838f6511251299">More...</a><br /></td></tr>
<tr class="separator:a8e0e5bd2a26b9faa9e838f6511251299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef747573e83679ea7e2051d7f774a24"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01964.html#a1ef747573e83679ea7e2051d7f774a24">rank</a> () const</td></tr>
<tr class="memdesc:a1ef747573e83679ea7e2051d7f774a24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return rank, is between 0 and <a class="el" href="a01964.html#a52ca21c831f476ec12f4735d3e79a00a" title="Number of processes in set, is greater than 0.">size()</a>-1.  <a href="a01964.html#a1ef747573e83679ea7e2051d7f774a24">More...</a><br /></td></tr>
<tr class="separator:a1ef747573e83679ea7e2051d7f774a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ca21c831f476ec12f4735d3e79a00a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01964.html#a52ca21c831f476ec12f4735d3e79a00a">size</a> () const</td></tr>
<tr class="memdesc:a52ca21c831f476ec12f4735d3e79a00a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of processes in set, is greater than 0.  <a href="a01964.html#a52ca21c831f476ec12f4735d3e79a00a">More...</a><br /></td></tr>
<tr class="separator:a52ca21c831f476ec12f4735d3e79a00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a143c0006dd1b9810968fef841cf47ef8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a143c0006dd1b9810968fef841cf47ef8"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01964.html#a143c0006dd1b9810968fef841cf47ef8">send</a> (const T &amp;data, int dest_rank, int tag)</td></tr>
<tr class="memdesc:a143c0006dd1b9810968fef841cf47ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the data to the dest_rank.  <a href="a01964.html#a143c0006dd1b9810968fef841cf47ef8">More...</a><br /></td></tr>
<tr class="separator:a143c0006dd1b9810968fef841cf47ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbd9bef0b34627831203f5b4a7c210e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5fbd9bef0b34627831203f5b4a7c210e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02048.html">PseudoFuture</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01964.html#a5fbd9bef0b34627831203f5b4a7c210e">isend</a> (const T &amp;&amp;data, int dest_rank, int tag)</td></tr>
<tr class="memdesc:a5fbd9bef0b34627831203f5b4a7c210e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the data to the dest_rank nonblocking.  <a href="a01964.html#a5fbd9bef0b34627831203f5b4a7c210e">More...</a><br /></td></tr>
<tr class="separator:a5fbd9bef0b34627831203f5b4a7c210e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a271d9ce3fa319a1a08e4a2764dd3cc53"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a271d9ce3fa319a1a08e4a2764dd3cc53"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01964.html#a271d9ce3fa319a1a08e4a2764dd3cc53">recv</a> (T &amp;&amp;data, int source_rank, int tag, void *status=0)</td></tr>
<tr class="memdesc:a271d9ce3fa319a1a08e4a2764dd3cc53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives the data from the source_rank.  <a href="a01964.html#a271d9ce3fa319a1a08e4a2764dd3cc53">More...</a><br /></td></tr>
<tr class="separator:a271d9ce3fa319a1a08e4a2764dd3cc53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340e9ce6be4464a3044fdf0b3212c567"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a340e9ce6be4464a3044fdf0b3212c567"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02048.html">PseudoFuture</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01964.html#a340e9ce6be4464a3044fdf0b3212c567">irecv</a> (T &amp;&amp;data, int source_rank, int tag)</td></tr>
<tr class="memdesc:a340e9ce6be4464a3044fdf0b3212c567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives the data from the source_rank nonblocking.  <a href="a01964.html#a340e9ce6be4464a3044fdf0b3212c567">More...</a><br /></td></tr>
<tr class="separator:a340e9ce6be4464a3044fdf0b3212c567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad589246156b329251657975f23990f6c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad589246156b329251657975f23990f6c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01964.html#ad589246156b329251657975f23990f6c">rrecv</a> (T &amp;&amp;data, int source_rank, int tag, void *status=0) const</td></tr>
<tr class="separator:ad589246156b329251657975f23990f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc87be60f9760a9480c9dc152930440"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1fc87be60f9760a9480c9dc152930440"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01964.html#a1fc87be60f9760a9480c9dc152930440">sum</a> (const T &amp;in) const</td></tr>
<tr class="memdesc:a1fc87be60f9760a9480c9dc152930440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sum of the argument over all processes and return the result in every process. Assumes that T has an operator+.  <a href="a01964.html#a1fc87be60f9760a9480c9dc152930440">More...</a><br /></td></tr>
<tr class="separator:a1fc87be60f9760a9480c9dc152930440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643e8f723bd2f0a4e2f1d6ca4c265500"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a643e8f723bd2f0a4e2f1d6ca4c265500"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01964.html#a643e8f723bd2f0a4e2f1d6ca4c265500">sum</a> (T *inout, int len) const</td></tr>
<tr class="memdesc:a643e8f723bd2f0a4e2f1d6ca4c265500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sum over all processes for each component of an array and return the result in every process. Assumes that T has an operator+.  <a href="a01964.html#a643e8f723bd2f0a4e2f1d6ca4c265500">More...</a><br /></td></tr>
<tr class="separator:a643e8f723bd2f0a4e2f1d6ca4c265500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4689220c1adca5ccb16ee21266fdf71"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa4689220c1adca5ccb16ee21266fdf71"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01964.html#aa4689220c1adca5ccb16ee21266fdf71">prod</a> (const T &amp;in) const</td></tr>
<tr class="memdesc:aa4689220c1adca5ccb16ee21266fdf71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the product of the argument over all processes and return the result in every process. Assumes that T has an operator*.  <a href="a01964.html#aa4689220c1adca5ccb16ee21266fdf71">More...</a><br /></td></tr>
<tr class="separator:aa4689220c1adca5ccb16ee21266fdf71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26749d8448ff4842677e4d6c27f5161b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a26749d8448ff4842677e4d6c27f5161b"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01964.html#a26749d8448ff4842677e4d6c27f5161b">prod</a> (T *inout, int len) const</td></tr>
<tr class="memdesc:a26749d8448ff4842677e4d6c27f5161b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the product over all processes for each component of an array and return the result in every process. Assumes that T has an operator*.  <a href="a01964.html#a26749d8448ff4842677e4d6c27f5161b">More...</a><br /></td></tr>
<tr class="separator:a26749d8448ff4842677e4d6c27f5161b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c5b8222c61c324476264ebd441232e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a69c5b8222c61c324476264ebd441232e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01964.html#a69c5b8222c61c324476264ebd441232e">min</a> (const T &amp;in) const</td></tr>
<tr class="memdesc:a69c5b8222c61c324476264ebd441232e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the minimum of the argument over all processes and return the result in every process. Assumes that T has an operator&lt;.  <a href="a01964.html#a69c5b8222c61c324476264ebd441232e">More...</a><br /></td></tr>
<tr class="separator:a69c5b8222c61c324476264ebd441232e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6effcdaaf4be799480e88294bdacac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adc6effcdaaf4be799480e88294bdacac"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01964.html#adc6effcdaaf4be799480e88294bdacac">min</a> (T *inout, int len) const</td></tr>
<tr class="memdesc:adc6effcdaaf4be799480e88294bdacac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the minimum over all processes for each component of an array and return the result in every process. Assumes that T has an operator&lt;.  <a href="a01964.html#adc6effcdaaf4be799480e88294bdacac">More...</a><br /></td></tr>
<tr class="separator:adc6effcdaaf4be799480e88294bdacac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173db854792edfe07f776458740857d2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a173db854792edfe07f776458740857d2"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01964.html#a173db854792edfe07f776458740857d2">max</a> (const T &amp;in) const</td></tr>
<tr class="memdesc:a173db854792edfe07f776458740857d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the maximum of the argument over all processes and return the result in every process. Assumes that T has an operator&lt;.  <a href="a01964.html#a173db854792edfe07f776458740857d2">More...</a><br /></td></tr>
<tr class="separator:a173db854792edfe07f776458740857d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f237a3d7c5b370b8edc11c602a22e7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a91f237a3d7c5b370b8edc11c602a22e7"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01964.html#a91f237a3d7c5b370b8edc11c602a22e7">max</a> (T *inout, int len) const</td></tr>
<tr class="memdesc:a91f237a3d7c5b370b8edc11c602a22e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the maximum over all processes for each component of an array and return the result in every process. Assumes that T has an operator&lt;.  <a href="a01964.html#a91f237a3d7c5b370b8edc11c602a22e7">More...</a><br /></td></tr>
<tr class="separator:a91f237a3d7c5b370b8edc11c602a22e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17ea8bcd9c51be5dfb5e13442eb62fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01964.html#ae17ea8bcd9c51be5dfb5e13442eb62fc">barrier</a> () const</td></tr>
<tr class="memdesc:ae17ea8bcd9c51be5dfb5e13442eb62fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until all processes have arrived at this point in the program.  <a href="a01964.html#ae17ea8bcd9c51be5dfb5e13442eb62fc">More...</a><br /></td></tr>
<tr class="separator:ae17ea8bcd9c51be5dfb5e13442eb62fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101987dc3496ad7eb1b8215ccbdbb9de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a02048.html">PseudoFuture</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01964.html#a101987dc3496ad7eb1b8215ccbdbb9de">ibarrier</a> () const</td></tr>
<tr class="memdesc:a101987dc3496ad7eb1b8215ccbdbb9de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nonblocking barrier.  <a href="a01964.html#a101987dc3496ad7eb1b8215ccbdbb9de">More...</a><br /></td></tr>
<tr class="separator:a101987dc3496ad7eb1b8215ccbdbb9de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b5af3669253e473ed3512b27cb30bc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac8b5af3669253e473ed3512b27cb30bc"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01964.html#ac8b5af3669253e473ed3512b27cb30bc">broadcast</a> (T *inout, int len, int root) const</td></tr>
<tr class="memdesc:ac8b5af3669253e473ed3512b27cb30bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distribute an array from the process with rank root to all other processes.  <a href="a01964.html#ac8b5af3669253e473ed3512b27cb30bc">More...</a><br /></td></tr>
<tr class="separator:ac8b5af3669253e473ed3512b27cb30bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac346fda778ae1b3375e2cd04c9e3bbd"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aac346fda778ae1b3375e2cd04c9e3bbd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02048.html">PseudoFuture</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01964.html#aac346fda778ae1b3375e2cd04c9e3bbd">ibroadcast</a> (T &amp;&amp;data, int root) const</td></tr>
<tr class="memdesc:aac346fda778ae1b3375e2cd04c9e3bbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distribute an array from the process with rank root to all other processes nonblocking.  <a href="a01964.html#aac346fda778ae1b3375e2cd04c9e3bbd">More...</a><br /></td></tr>
<tr class="separator:aac346fda778ae1b3375e2cd04c9e3bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a292081ff7e8a8472e80a72ee6666e5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8a292081ff7e8a8472e80a72ee6666e5"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01964.html#a8a292081ff7e8a8472e80a72ee6666e5">gather</a> (const T *in, T *out, int len, int root) const</td></tr>
<tr class="memdesc:a8a292081ff7e8a8472e80a72ee6666e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather arrays on root task.  <a href="a01964.html#a8a292081ff7e8a8472e80a72ee6666e5">More...</a><br /></td></tr>
<tr class="separator:a8a292081ff7e8a8472e80a72ee6666e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77af2f58faa237db5c6c63ad4acf57b"><td class="memTemplParams" colspan="2">template&lt;class TIN , class TOUT  = std::vector&lt;TIN&gt;&gt; </td></tr>
<tr class="memitem:ac77af2f58faa237db5c6c63ad4acf57b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02048.html">PseudoFuture</a>&lt; TOUT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01964.html#ac77af2f58faa237db5c6c63ad4acf57b">igather</a> (TIN &amp;&amp;data_in, TOUT &amp;&amp;data_out, int root)</td></tr>
<tr class="memdesc:ac77af2f58faa237db5c6c63ad4acf57b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather arrays on root task nonblocking.  <a href="a01964.html#ac77af2f58faa237db5c6c63ad4acf57b">More...</a><br /></td></tr>
<tr class="separator:ac77af2f58faa237db5c6c63ad4acf57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ff9c27e24e174a1562b68e91b71c72"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a59ff9c27e24e174a1562b68e91b71c72"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01964.html#a59ff9c27e24e174a1562b68e91b71c72">gatherv</a> (const T *in, int sendlen, T *out, int *recvlen, int *displ, int root) const</td></tr>
<tr class="memdesc:a59ff9c27e24e174a1562b68e91b71c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather arrays of variable size on root task.  <a href="a01964.html#a59ff9c27e24e174a1562b68e91b71c72">More...</a><br /></td></tr>
<tr class="separator:a59ff9c27e24e174a1562b68e91b71c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3087b763303676fbdbd255bcb0e5d707"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3087b763303676fbdbd255bcb0e5d707"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01964.html#a3087b763303676fbdbd255bcb0e5d707">scatter</a> (const T *<a class="el" href="a01964.html#a143c0006dd1b9810968fef841cf47ef8">send</a>, T *<a class="el" href="a01964.html#a271d9ce3fa319a1a08e4a2764dd3cc53">recv</a>, int len, int root) const</td></tr>
<tr class="memdesc:a3087b763303676fbdbd255bcb0e5d707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter array from a root to all other task.  <a href="a01964.html#a3087b763303676fbdbd255bcb0e5d707">More...</a><br /></td></tr>
<tr class="separator:a3087b763303676fbdbd255bcb0e5d707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae857e2024fc20bc7f4831600e6ac1108"><td class="memTemplParams" colspan="2">template&lt;class TIN , class TOUT  = TIN&gt; </td></tr>
<tr class="memitem:ae857e2024fc20bc7f4831600e6ac1108"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02048.html">PseudoFuture</a>&lt; TOUT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01964.html#ae857e2024fc20bc7f4831600e6ac1108">iscatter</a> (TIN &amp;&amp;data_in, TOUT &amp;&amp;data_out, int root)</td></tr>
<tr class="memdesc:ae857e2024fc20bc7f4831600e6ac1108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter array from a root to all other task nonblocking.  <a href="a01964.html#ae857e2024fc20bc7f4831600e6ac1108">More...</a><br /></td></tr>
<tr class="separator:ae857e2024fc20bc7f4831600e6ac1108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0660f30eaf5749c0658b5b4afaf3a3c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae0660f30eaf5749c0658b5b4afaf3a3c"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01964.html#ae0660f30eaf5749c0658b5b4afaf3a3c">scatterv</a> (const T *<a class="el" href="a01964.html#a143c0006dd1b9810968fef841cf47ef8">send</a>, int *sendlen, int *displ, T *<a class="el" href="a01964.html#a271d9ce3fa319a1a08e4a2764dd3cc53">recv</a>, int recvlen, int root) const</td></tr>
<tr class="memdesc:ae0660f30eaf5749c0658b5b4afaf3a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatter arrays of variable length from a root to all other tasks.  <a href="a01964.html#ae0660f30eaf5749c0658b5b4afaf3a3c">More...</a><br /></td></tr>
<tr class="separator:ae0660f30eaf5749c0658b5b4afaf3a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803872d4e3cd6f9f53d481e9959f6f47"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a803872d4e3cd6f9f53d481e9959f6f47"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01964.html#a803872d4e3cd6f9f53d481e9959f6f47">allgather</a> (const T *sbuf, int count, T *rbuf) const</td></tr>
<tr class="memdesc:a803872d4e3cd6f9f53d481e9959f6f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers data from all tasks and distribute it to all.  <a href="a01964.html#a803872d4e3cd6f9f53d481e9959f6f47">More...</a><br /></td></tr>
<tr class="separator:a803872d4e3cd6f9f53d481e9959f6f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b8fde6288d79181f3e0f42701a750a"><td class="memTemplParams" colspan="2">template&lt;class TIN , class TOUT  = TIN&gt; </td></tr>
<tr class="memitem:a86b8fde6288d79181f3e0f42701a750a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02048.html">PseudoFuture</a>&lt; TOUT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01964.html#a86b8fde6288d79181f3e0f42701a750a">iallgather</a> (TIN &amp;&amp;data_in, TOUT &amp;&amp;data_out)</td></tr>
<tr class="memdesc:a86b8fde6288d79181f3e0f42701a750a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers data from all tasks and distribute it to all nonblocking.  <a href="a01964.html#a86b8fde6288d79181f3e0f42701a750a">More...</a><br /></td></tr>
<tr class="separator:a86b8fde6288d79181f3e0f42701a750a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448e24c0da2b4a4667968f585b27f714"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a448e24c0da2b4a4667968f585b27f714"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01964.html#a448e24c0da2b4a4667968f585b27f714">allgatherv</a> (const T *in, int sendlen, T *out, int *recvlen, int *displ) const</td></tr>
<tr class="memdesc:a448e24c0da2b4a4667968f585b27f714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers data of variable length from all tasks and distribute it to all.  <a href="a01964.html#a448e24c0da2b4a4667968f585b27f714">More...</a><br /></td></tr>
<tr class="separator:a448e24c0da2b4a4667968f585b27f714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2faf006357f106efdbae188e76f6220d"><td class="memTemplParams" colspan="2">template&lt;typename BinaryFunction , typename Type &gt; </td></tr>
<tr class="memitem:a2faf006357f106efdbae188e76f6220d"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01964.html#a2faf006357f106efdbae188e76f6220d">allreduce</a> (Type *inout, int len) const</td></tr>
<tr class="memdesc:a2faf006357f106efdbae188e76f6220d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute something over all processes for each component of an array and return the result in every process.  <a href="a01964.html#a2faf006357f106efdbae188e76f6220d">More...</a><br /></td></tr>
<tr class="separator:a2faf006357f106efdbae188e76f6220d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679199300f66b5707cae85d251846bcc"><td class="memTemplParams" colspan="2">template&lt;class BinaryFunction , class TIN , class TOUT  = TIN&gt; </td></tr>
<tr class="memitem:a679199300f66b5707cae85d251846bcc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02048.html">PseudoFuture</a>&lt; TOUT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01964.html#a679199300f66b5707cae85d251846bcc">iallreduce</a> (TIN &amp;&amp;data_in, TOUT &amp;&amp;data_out)</td></tr>
<tr class="memdesc:a679199300f66b5707cae85d251846bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute something over all processes nonblocking.  <a href="a01964.html#a679199300f66b5707cae85d251846bcc">More...</a><br /></td></tr>
<tr class="separator:a679199300f66b5707cae85d251846bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9731ba41dc71489c939575ed09f402da"><td class="memTemplParams" colspan="2">template&lt;class BinaryFunction , class T &gt; </td></tr>
<tr class="memitem:a9731ba41dc71489c939575ed09f402da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02048.html">PseudoFuture</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01964.html#a9731ba41dc71489c939575ed09f402da">iallreduce</a> (T &amp;&amp;data)</td></tr>
<tr class="memdesc:a9731ba41dc71489c939575ed09f402da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute something over all processes nonblocking and in-place.  <a href="a01964.html#a9731ba41dc71489c939575ed09f402da">More...</a><br /></td></tr>
<tr class="separator:a9731ba41dc71489c939575ed09f402da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b768750823821a242b20a92ff3a848"><td class="memTemplParams" colspan="2">template&lt;typename BinaryFunction , typename Type &gt; </td></tr>
<tr class="memitem:a15b768750823821a242b20a92ff3a848"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01964.html#a15b768750823821a242b20a92ff3a848">allreduce</a> (const Type *in, Type *out, int len) const</td></tr>
<tr class="memdesc:a15b768750823821a242b20a92ff3a848"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute something over all processes for each component of an array and return the result in every process.  <a href="a01964.html#a15b768750823821a242b20a92ff3a848">More...</a><br /></td></tr>
<tr class="separator:a15b768750823821a242b20a92ff3a848"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Communicator&gt;<br />
class Dune::Communication&lt; Communicator &gt;</h3>

<p>Collective communication interface and sequential default implementation. </p>
<p><a class="el" href="a01964.html" title="Collective communication interface and sequential default implementation.">Communication</a> offers an abstraction to the basic methods of parallel communication, following the message-passing paradigm. It allows one to switch parallel features on and off, without changing the code. Currently only MPI and sequential code are supported.</p>
<p>A <a class="el" href="a01964.html" title="Collective communication interface and sequential default implementation.">Communication</a> object is returned by all grids (also the sequential ones) in order to allow code to be written in a transparent way for sequential and parallel grids.</p>
<p>This class provides a default implementation for sequential grids. The number of processes involved is 1, any sum, maximum, etc. returns just its input argument and so on.</p>
<p>In specializations one can implement the real thing using appropriate communication functions, e.g. there exists an implementation using the Message Passing Interface (MPI), see <a class="el" href="a02140.html" title="Specialization of Communication for MPI.">Dune::Communication&lt;MPI_Comm&gt;</a>.</p>
<p>Moreover, the communication subsystem used by an implementation is not visible in the interface, i.e. <a class="el" href="a00428.html" title="Dune namespace.">Dune</a> grid implementations are not restricted to MPI.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Communicator</td><td>The communicator type used by your message-passing implementation. For MPI this will be MPI_Comm. For sequential codes there is the dummy communicator <a class="el" href="a01960.html">No_Comm</a>. It is assumed that if you want to specialize the <a class="el" href="a01964.html" title="Collective communication interface and sequential default implementation.">Communication</a> class for a message-passing system other than MPI, that message-passing system will have something equivalent to MPI communicators. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af9873f31f9e81114b4edcc50b01b0a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9873f31f9e81114b4edcc50b01b0a3c">&#9670;&nbsp;</a></span>Communication() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Communicator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01964.html">Dune::Communication</a>&lt; Communicator &gt;::<a class="el" href="a01964.html">Communication</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct default object. </p>

</div>
</div>
<a id="a8e0e5bd2a26b9faa9e838f6511251299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e0e5bd2a26b9faa9e838f6511251299">&#9670;&nbsp;</a></span>Communication() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Communicator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01964.html">Dune::Communication</a>&lt; Communicator &gt;::<a class="el" href="a01964.html">Communication</a> </td>
          <td>(</td>
          <td class="paramtype">const Communicator &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor with a given communicator. </p>
<p>As this is implementation for the sequential setting, the communicator is a dummy and simply discarded. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a803872d4e3cd6f9f53d481e9959f6f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a803872d4e3cd6f9f53d481e9959f6f47">&#9670;&nbsp;</a></span>allgather()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Communicator &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="a01964.html">Dune::Communication</a>&lt; Communicator &gt;::allgather </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>sbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>rbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gathers data from all tasks and distribute it to all. </p>
<p>The block of data sent from the jth process is received by every process and placed in the jth block of the buffer recvbuf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sbuf</td><td>The buffer with the data to send. Has to be the same for each task. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of elements to send by any process. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rbuf</td><td>The receive buffer for the data. Has to be of size notasks*count, with notasks being the number of tasks in the communicator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MPI_SUCCESS (==0) if successful, an MPI error code otherwise </dd></dl>

</div>
</div>
<a id="a448e24c0da2b4a4667968f585b27f714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448e24c0da2b4a4667968f585b27f714">&#9670;&nbsp;</a></span>allgatherv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Communicator &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="a01964.html">Dune::Communication</a>&lt; Communicator &gt;::allgatherv </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sendlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>recvlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>displ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gathers data of variable length from all tasks and distribute it to all. </p>
<p>The block of data sent from the jth process is received by every process and placed in the jth block of the buffer out.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>The send buffer with the data to send. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendlen</td><td>The number of elements to send on each task. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>The buffer to store the received data in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">recvlen</td><td>An array with size equal to the number of processes containing the number of elements to receive from process i at position i, i.e. the number that is passed as sendlen argument to this function in process i. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">displ</td><td>An array with size equal to the number of processes. Data received from process i will be written starting at out+displ[i]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MPI_SUCCESS (==0) if successful, an MPI error code otherwise </dd></dl>

</div>
</div>
<a id="a15b768750823821a242b20a92ff3a848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15b768750823821a242b20a92ff3a848">&#9670;&nbsp;</a></span>allreduce() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Communicator &gt; </div>
<div class="memtemplate">
template&lt;typename BinaryFunction , typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="a01964.html">Dune::Communication</a>&lt; Communicator &gt;::allreduce </td>
          <td>(</td>
          <td class="paramtype">const Type *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute something over all processes for each component of an array and return the result in every process. </p>
<p>The template parameter BinaryFunction is the type of the binary function to use for the computation</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The array to compute on. </td></tr>
    <tr><td class="paramname">out</td><td>The array to store the results in. </td></tr>
    <tr><td class="paramname">len</td><td>The number of components in the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MPI_SUCCESS (==0) if successful, an MPI error code otherwise </dd></dl>

</div>
</div>
<a id="a2faf006357f106efdbae188e76f6220d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2faf006357f106efdbae188e76f6220d">&#9670;&nbsp;</a></span>allreduce() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Communicator &gt; </div>
<div class="memtemplate">
template&lt;typename BinaryFunction , typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="a01964.html">Dune::Communication</a>&lt; Communicator &gt;::allreduce </td>
          <td>(</td>
          <td class="paramtype">Type *&#160;</td>
          <td class="paramname"><em>inout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute something over all processes for each component of an array and return the result in every process. </p>
<p>The template parameter BinaryFunction is the type of the binary function to use for the computation</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inout</td><td>The array to compute on. </td></tr>
    <tr><td class="paramname">len</td><td>The number of components in the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MPI_SUCCESS (==0) if successful, an MPI error code otherwise </dd></dl>

</div>
</div>
<a id="ae17ea8bcd9c51be5dfb5e13442eb62fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae17ea8bcd9c51be5dfb5e13442eb62fc">&#9670;&nbsp;</a></span>barrier()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Communicator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="a01964.html">Dune::Communication</a>&lt; Communicator &gt;::barrier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait until all processes have arrived at this point in the program. </p>
<dl class="section return"><dt>Returns</dt><dd>MPI_SUCCESS (==0) if successful, an MPI error code otherwise </dd></dl>

</div>
</div>
<a id="ac8b5af3669253e473ed3512b27cb30bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b5af3669253e473ed3512b27cb30bc">&#9670;&nbsp;</a></span>broadcast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Communicator &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="a01964.html">Dune::Communication</a>&lt; Communicator &gt;::broadcast </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>inout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Distribute an array from the process with rank root to all other processes. </p>
<dl class="section return"><dt>Returns</dt><dd>MPI_SUCCESS (==0) if successful, an MPI error code otherwise </dd></dl>

</div>
</div>
<a id="a8a292081ff7e8a8472e80a72ee6666e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a292081ff7e8a8472e80a72ee6666e5">&#9670;&nbsp;</a></span>gather()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Communicator &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="a01964.html">Dune::Communication</a>&lt; Communicator &gt;::gather </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather arrays on root task. </p>
<p>Each process sends its in array of length len to the root process (including the root itself). In the root process these arrays are stored in rank order in the out array which must have size len * number of processes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>The send buffer with the data to send. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>The buffer to store the received data in. Might have length zero on non-root tasks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The number of elements to send on each task. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">root</td><td>The root task that gathers the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MPI_SUCCESS (==0) if successful, an MPI error code otherwise </dd></dl>

</div>
</div>
<a id="a59ff9c27e24e174a1562b68e91b71c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59ff9c27e24e174a1562b68e91b71c72">&#9670;&nbsp;</a></span>gatherv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Communicator &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="a01964.html">Dune::Communication</a>&lt; Communicator &gt;::gatherv </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sendlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>recvlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>displ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather arrays of variable size on root task. </p>
<p>Each process sends its in array of length sendlen to the root process (including the root itself). In the root process these arrays are stored in rank order in the out array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>The send buffer with the data to be sent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendlen</td><td>The number of elements to send on each task </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>The buffer to store the received data in. May have length zero on non-root tasks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">recvlen</td><td>An array with size equal to the number of processes containing the number of elements to receive from process i at position i, i.e. the number that is passed as sendlen argument to this function in process i. May have length zero on non-root tasks. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">displ</td><td>An array with size equal to the number of processes. Data received from process i will be written starting at out+displ[i] on the root process. May have length zero on non-root tasks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">root</td><td>The root task that gathers the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MPI_SUCCESS (==0) if successful, an MPI error code otherwise </dd></dl>

</div>
</div>
<a id="a86b8fde6288d79181f3e0f42701a750a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b8fde6288d79181f3e0f42701a750a">&#9670;&nbsp;</a></span>iallgather()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Communicator &gt; </div>
<div class="memtemplate">
template&lt;class TIN , class TOUT  = TIN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02048.html">PseudoFuture</a>&lt;TOUT&gt; <a class="el" href="a01964.html">Dune::Communication</a>&lt; Communicator &gt;::iallgather </td>
          <td>(</td>
          <td class="paramtype">TIN &amp;&amp;&#160;</td>
          <td class="paramname"><em>data_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOUT &amp;&amp;&#160;</td>
          <td class="paramname"><em>data_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gathers data from all tasks and distribute it to all nonblocking. </p>
<dl class="section return"><dt>Returns</dt><dd>Future&lt;TOUT, TIN&gt; containing the distributed data </dd></dl>

</div>
</div>
<a id="a9731ba41dc71489c939575ed09f402da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9731ba41dc71489c939575ed09f402da">&#9670;&nbsp;</a></span>iallreduce() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Communicator &gt; </div>
<div class="memtemplate">
template&lt;class BinaryFunction , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02048.html">PseudoFuture</a>&lt;T&gt; <a class="el" href="a01964.html">Dune::Communication</a>&lt; Communicator &gt;::iallreduce </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute something over all processes nonblocking and in-place. </p>
<dl class="section return"><dt>Returns</dt><dd>Future&lt;T&gt; containing the computed something </dd></dl>

</div>
</div>
<a id="a679199300f66b5707cae85d251846bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679199300f66b5707cae85d251846bcc">&#9670;&nbsp;</a></span>iallreduce() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Communicator &gt; </div>
<div class="memtemplate">
template&lt;class BinaryFunction , class TIN , class TOUT  = TIN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02048.html">PseudoFuture</a>&lt;TOUT&gt; <a class="el" href="a01964.html">Dune::Communication</a>&lt; Communicator &gt;::iallreduce </td>
          <td>(</td>
          <td class="paramtype">TIN &amp;&amp;&#160;</td>
          <td class="paramname"><em>data_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOUT &amp;&amp;&#160;</td>
          <td class="paramname"><em>data_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute something over all processes nonblocking. </p>
<dl class="section return"><dt>Returns</dt><dd>Future&lt;TOUT, TIN&gt; containing the computed something </dd></dl>

</div>
</div>
<a id="a101987dc3496ad7eb1b8215ccbdbb9de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a101987dc3496ad7eb1b8215ccbdbb9de">&#9670;&nbsp;</a></span>ibarrier()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Communicator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02048.html">PseudoFuture</a>&lt;void&gt; <a class="el" href="a01964.html">Dune::Communication</a>&lt; Communicator &gt;::ibarrier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nonblocking barrier. </p>
<dl class="section return"><dt>Returns</dt><dd>Future&lt;void&gt; which is complete when all processes have reached the barrier </dd></dl>

</div>
</div>
<a id="aac346fda778ae1b3375e2cd04c9e3bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac346fda778ae1b3375e2cd04c9e3bbd">&#9670;&nbsp;</a></span>ibroadcast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Communicator &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02048.html">PseudoFuture</a>&lt;T&gt; <a class="el" href="a01964.html">Dune::Communication</a>&lt; Communicator &gt;::ibroadcast </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Distribute an array from the process with rank root to all other processes nonblocking. </p>
<dl class="section return"><dt>Returns</dt><dd>Future&lt;T&gt; containing the distributed data </dd></dl>

</div>
</div>
<a id="ac77af2f58faa237db5c6c63ad4acf57b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac77af2f58faa237db5c6c63ad4acf57b">&#9670;&nbsp;</a></span>igather()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Communicator &gt; </div>
<div class="memtemplate">
template&lt;class TIN , class TOUT  = std::vector&lt;TIN&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02048.html">PseudoFuture</a>&lt;TOUT&gt; <a class="el" href="a01964.html">Dune::Communication</a>&lt; Communicator &gt;::igather </td>
          <td>(</td>
          <td class="paramtype">TIN &amp;&amp;&#160;</td>
          <td class="paramname"><em>data_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOUT &amp;&amp;&#160;</td>
          <td class="paramname"><em>data_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather arrays on root task nonblocking. </p>
<dl class="section return"><dt>Returns</dt><dd>Future&lt;TOUT, TIN&gt; containing the gathered data </dd></dl>

</div>
</div>
<a id="a340e9ce6be4464a3044fdf0b3212c567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a340e9ce6be4464a3044fdf0b3212c567">&#9670;&nbsp;</a></span>irecv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Communicator &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02048.html">PseudoFuture</a>&lt;T&gt; <a class="el" href="a01964.html">Dune::Communication</a>&lt; Communicator &gt;::irecv </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receives the data from the source_rank nonblocking. </p>
<dl class="section return"><dt>Returns</dt><dd>Future&lt;T&gt; containing the received data when complete </dd></dl>

</div>
</div>
<a id="ae857e2024fc20bc7f4831600e6ac1108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae857e2024fc20bc7f4831600e6ac1108">&#9670;&nbsp;</a></span>iscatter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Communicator &gt; </div>
<div class="memtemplate">
template&lt;class TIN , class TOUT  = TIN&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02048.html">PseudoFuture</a>&lt;TOUT&gt; <a class="el" href="a01964.html">Dune::Communication</a>&lt; Communicator &gt;::iscatter </td>
          <td>(</td>
          <td class="paramtype">TIN &amp;&amp;&#160;</td>
          <td class="paramname"><em>data_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOUT &amp;&amp;&#160;</td>
          <td class="paramname"><em>data_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter array from a root to all other task nonblocking. </p>
<dl class="section return"><dt>Returns</dt><dd>Future&lt;TOUT, TIN&gt; containing scattered data; </dd></dl>

</div>
</div>
<a id="a5fbd9bef0b34627831203f5b4a7c210e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fbd9bef0b34627831203f5b4a7c210e">&#9670;&nbsp;</a></span>isend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Communicator &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a02048.html">PseudoFuture</a>&lt;T&gt; <a class="el" href="a01964.html">Dune::Communication</a>&lt; Communicator &gt;::isend </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dest_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends the data to the dest_rank nonblocking. </p>
<dl class="section return"><dt>Returns</dt><dd>Future&lt;T&gt; containing the send buffer, completes when data is send </dd></dl>

</div>
</div>
<a id="a173db854792edfe07f776458740857d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173db854792edfe07f776458740857d2">&#9670;&nbsp;</a></span>max() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Communicator &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="a01964.html">Dune::Communication</a>&lt; Communicator &gt;::max </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the maximum of the argument over all processes and return the result in every process. Assumes that T has an operator&lt;. </p>

</div>
</div>
<a id="a91f237a3d7c5b370b8edc11c602a22e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f237a3d7c5b370b8edc11c602a22e7">&#9670;&nbsp;</a></span>max() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Communicator &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="a01964.html">Dune::Communication</a>&lt; Communicator &gt;::max </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>inout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the maximum over all processes for each component of an array and return the result in every process. Assumes that T has an operator&lt;. </p>
<dl class="section return"><dt>Returns</dt><dd>MPI_SUCCESS (==0) if successful, an MPI error code otherwise </dd></dl>

</div>
</div>
<a id="a69c5b8222c61c324476264ebd441232e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c5b8222c61c324476264ebd441232e">&#9670;&nbsp;</a></span>min() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Communicator &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="a01964.html">Dune::Communication</a>&lt; Communicator &gt;::min </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the minimum of the argument over all processes and return the result in every process. Assumes that T has an operator&lt;. </p>

</div>
</div>
<a id="adc6effcdaaf4be799480e88294bdacac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc6effcdaaf4be799480e88294bdacac">&#9670;&nbsp;</a></span>min() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Communicator &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="a01964.html">Dune::Communication</a>&lt; Communicator &gt;::min </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>inout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the minimum over all processes for each component of an array and return the result in every process. Assumes that T has an operator&lt;. </p>
<dl class="section return"><dt>Returns</dt><dd>MPI_SUCCESS (==0) if successful, an MPI error code otherwise </dd></dl>

</div>
</div>
<a id="aa4689220c1adca5ccb16ee21266fdf71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4689220c1adca5ccb16ee21266fdf71">&#9670;&nbsp;</a></span>prod() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Communicator &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="a01964.html">Dune::Communication</a>&lt; Communicator &gt;::prod </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the product of the argument over all processes and return the result in every process. Assumes that T has an operator*. </p>

</div>
</div>
<a id="a26749d8448ff4842677e4d6c27f5161b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26749d8448ff4842677e4d6c27f5161b">&#9670;&nbsp;</a></span>prod() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Communicator &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="a01964.html">Dune::Communication</a>&lt; Communicator &gt;::prod </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>inout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the product over all processes for each component of an array and return the result in every process. Assumes that T has an operator*. </p>
<dl class="section return"><dt>Returns</dt><dd>MPI_SUCCESS (==0) if successful, an MPI error code otherwise </dd></dl>

</div>
</div>
<a id="a1ef747573e83679ea7e2051d7f774a24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef747573e83679ea7e2051d7f774a24">&#9670;&nbsp;</a></span>rank()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Communicator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="a01964.html">Dune::Communication</a>&lt; Communicator &gt;::rank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return rank, is between 0 and <a class="el" href="a01964.html#a52ca21c831f476ec12f4735d3e79a00a" title="Number of processes in set, is greater than 0.">size()</a>-1. </p>

</div>
</div>
<a id="a271d9ce3fa319a1a08e4a2764dd3cc53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a271d9ce3fa319a1a08e4a2764dd3cc53">&#9670;&nbsp;</a></span>recv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Communicator &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="a01964.html">Dune::Communication</a>&lt; Communicator &gt;::recv </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>status</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receives the data from the source_rank. </p>
<dl class="section return"><dt>Returns</dt><dd>MPI_SUCCESS (==0) if successful, an MPI error code otherwise </dd></dl>

</div>
</div>
<a id="ad589246156b329251657975f23990f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad589246156b329251657975f23990f6c">&#9670;&nbsp;</a></span>rrecv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Communicator &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="a01964.html">Dune::Communication</a>&lt; Communicator &gt;::rrecv </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>status</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3087b763303676fbdbd255bcb0e5d707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3087b763303676fbdbd255bcb0e5d707">&#9670;&nbsp;</a></span>scatter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Communicator &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="a01964.html">Dune::Communication</a>&lt; Communicator &gt;::scatter </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter array from a root to all other task. </p>
<p>The root process sends the elements with index from k*len to (k+1)*len-1 in its array to task k, which stores it at index 0 to len-1. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">send</td><td>The array to scatter. Might have length zero on non-root tasks. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recv</td><td>The buffer to store the received data in. Upon completion of the method each task will have same data stored there as the one in send buffer of the root task before. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The number of elements in the recv buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">root</td><td>The root task that gathers the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MPI_SUCCESS (==0) if successful, an MPI error code otherwise </dd></dl>

</div>
</div>
<a id="ae0660f30eaf5749c0658b5b4afaf3a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0660f30eaf5749c0658b5b4afaf3a3c">&#9670;&nbsp;</a></span>scatterv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Communicator &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="a01964.html">Dune::Communication</a>&lt; Communicator &gt;::scatterv </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>send</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sendlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>displ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>recvlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scatter arrays of variable length from a root to all other tasks. </p>
<p>The root process sends the elements with index from send+displ[k] to send+displ[k]-1 in its array to task k, which stores it at index 0 to recvlen-1. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">send</td><td>The array to scatter. May have length zero on non-root tasks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendlen</td><td>An array with size equal to the number of processes containing the number of elements to scatter to process i at position i, i.e. the number that is passed as recvlen argument to this function in process i. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">displ</td><td>An array with size equal to the number of processes. Data scattered to process i will be read starting at send+displ[i] on root the process. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recv</td><td>The buffer to store the received data in. Upon completion of the method each task will have the same data stored there as the one in send buffer of the root task before. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">recvlen</td><td>The number of elements in the recv buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">root</td><td>The root task that gathers the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MPI_SUCCESS (==0) if successful, an MPI error code otherwise </dd></dl>

</div>
</div>
<a id="a143c0006dd1b9810968fef841cf47ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a143c0006dd1b9810968fef841cf47ef8">&#9670;&nbsp;</a></span>send()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Communicator &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="a01964.html">Dune::Communication</a>&lt; Communicator &gt;::send </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dest_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends the data to the dest_rank. </p>
<dl class="section return"><dt>Returns</dt><dd>MPI_SUCCESS (==0) if successful, an MPI error code otherwise </dd></dl>

</div>
</div>
<a id="a52ca21c831f476ec12f4735d3e79a00a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52ca21c831f476ec12f4735d3e79a00a">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Communicator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="a01964.html">Dune::Communication</a>&lt; Communicator &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of processes in set, is greater than 0. </p>

</div>
</div>
<a id="a1fc87be60f9760a9480c9dc152930440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fc87be60f9760a9480c9dc152930440">&#9670;&nbsp;</a></span>sum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Communicator &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="a01964.html">Dune::Communication</a>&lt; Communicator &gt;::sum </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the sum of the argument over all processes and return the result in every process. Assumes that T has an operator+. </p>

</div>
</div>
<a id="a643e8f723bd2f0a4e2f1d6ca4c265500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a643e8f723bd2f0a4e2f1d6ca4c265500">&#9670;&nbsp;</a></span>sum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Communicator &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="a01964.html">Dune::Communication</a>&lt; Communicator &gt;::sum </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>inout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the sum over all processes for each component of an array and return the result in every process. Assumes that T has an operator+. </p>
<dl class="section return"><dt>Returns</dt><dd>MPI_SUCCESS (==0) if successful, an MPI error code otherwise </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="a00179_source.html">communication.hh</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
