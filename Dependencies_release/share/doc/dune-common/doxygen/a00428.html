<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>dune-common: Dune Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">dune-common
   &#160;<span id="projectnumber">2.8.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Dune Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="a00428.html" title="Dune namespace.">Dune</a> namespace.  
<a href="a00428.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:a00431"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00431.html">AlignedNumberImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00430"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00430.html">Concept</a></td></tr>
<tr class="memdesc:a00430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for concepts. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00435"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00435.html">DenseMatrixHelp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00437"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00437.html">DynamicMatrixHelp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00438"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00438.html">FloatCmp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00440"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00440.html">FMatrixHelp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00436"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00436.html">fvmeta</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00443"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00443.html">Hybrid</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00449"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00449.html">impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00445"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00445.html">Indices</a></td></tr>
<tr class="memdesc:a00445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace with predefined compile time indices for the range [0,19]. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00447"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00447.html">MathImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00442"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00442.html">MathOverloads</a></td></tr>
<tr class="memdesc:a00442"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for customization of math functions with Dune-Semantics <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00432"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00432.html">Simd</a></td></tr>
<tr class="memdesc:a00432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for vectorization interface functions used by library developers. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00451"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00451.html">SimdImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00454"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00454.html">Std</a></td></tr>
<tr class="memdesc:a00454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for features backported from new C++ standards. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01273.html">AlignedAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocators which guarantee alignment of the memory.  <a href="a01273.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01281.html">ArrayListIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random access iterator for the <a class="el" href="a01289.html" title="A dynamically growing random access list.">Dune::ArrayList</a> class.  <a href="a01281.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01285.html">ConstArrayListIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant random access iterator for the <a class="el" href="a01289.html" title="A dynamically growing random access list.">Dune::ArrayList</a> class.  <a href="a01285.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01289.html">ArrayList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamically growing random access list.  <a href="a01289.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01293.html">MPITraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A traits class describing the mapping of types onto MPI_Datatypes.  <a href="a01293.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01301.html">bigunsignedint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Portable very large unsigned integers.  <a href="a01301.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01309.html">Min</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01313.html">Max</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01317.html">BitSetVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamic array of blocks of booleans.  <a href="a01317.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01321.html">BitSetVectorReference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A proxy class that acts as a mutable reference to a single bitset in a <a class="el" href="a01317.html" title="A dynamic array of blocks of booleans.">BitSetVector</a>.  <a href="a01321.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01325.html">BitSetVectorConstReference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A proxy class that acts as a const reference to a single bitset in a <a class="el" href="a01317.html" title="A dynamic array of blocks of booleans.">BitSetVector</a>.  <a href="a01325.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01329.html">const_reference&lt; BitSetVectorReference&lt; block_size, Alloc &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01333.html">const_reference&lt; BitSetVectorConstReference&lt; block_size, Alloc &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01337.html">mutable_reference&lt; BitSetVectorReference&lt; block_size, Alloc &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01341.html">mutable_reference&lt; BitSetVectorConstReference&lt; block_size, Alloc &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01349.html">AlignedBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRTP base mixin class to check alignment.  <a href="a01349.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01369.html">greater_or_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater or equal template test.  <a href="a01369.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01373.html">common_bits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">activate if current and mask have common bits switched on.  <a href="a01373.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01377.html">DebugStreamError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">standard exception for the debugstream  <a href="a01377.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01381.html">StreamWrap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01385.html">DebugStreamState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intermediate class to implement tie-operation of <a class="el" href="a01389.html" title="Generic class to implement debug output streams.">DebugStream</a>.  <a href="a01385.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01389.html">DebugStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic class to implement debug output streams.  <a href="a01389.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01393.html">DenseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dense n x m matrix.  <a href="a01393.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01397.html">FieldTraits&lt; DenseMatrix&lt; M &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01401.html">FieldMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dense n x m matrix.  <a href="a01401.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01405.html">FieldVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector space out of a tensor product of fields.  <a href="a01405.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01417.html">DenseMatrixAssigner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">you have to specialize this structure for any type that should be assignable to a <a class="el" href="a01393.html" title="A dense n x m matrix.">DenseMatrix</a>  <a href="a01417.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01421.html">FMatrixError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error thrown if operations of a <a class="el" href="a01401.html" title="A dense n x m matrix.">FieldMatrix</a> fail.  <a href="a01421.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01425.html">DenseVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a02121.html" title="Communication interface between remote and local indices.">Interface</a> for a class of dense vectors over a given field.  <a href="a01425.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01429.html">FieldTraits&lt; DenseVector&lt; V &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01441.html">DenseIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic iterator class for dense vector and matrix implementations.  <a href="a01441.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01445.html">DiagonalRowVectorConst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01449.html">DiagonalRowVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01453.html">DiagonalMatrixWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01457.html">ContainerWrapperIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator class for sparse vector-like containers.  <a href="a01457.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01461.html">DiagonalMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A diagonal matrix of static size.  <a href="a01461.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01465.html">FieldTraits&lt; DiagonalMatrix&lt; K, n &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01469.html">const_reference&lt; DiagonalRowVector&lt; K, n &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01473.html">const_reference&lt; DiagonalRowVectorConst&lt; K, n &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01477.html">mutable_reference&lt; DiagonalRowVector&lt; K, n &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01481.html">mutable_reference&lt; DiagonalRowVectorConst&lt; K, n &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01485.html">DenseMatrixAssigner&lt; DenseMatrix, DiagonalMatrix&lt; field, N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01489.html">ImplementationDefined</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy struct used for documentation purposes.  <a href="a01489.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01493.html">IsVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01497.html">IsVector&lt; T, std::void_t&lt; typename T::field_type &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01501.html">DynamicMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a matrix with a dynamic size.  <a href="a01501.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01505.html">DenseMatVecTraits&lt; DynamicMatrix&lt; K &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01509.html">FieldTraits&lt; DynamicMatrix&lt; K &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01513.html">DynamicVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a vector with a dynamic size.  <a href="a01513.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01517.html">DenseMatVecTraits&lt; DynamicVector&lt; K, Allocator &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01521.html">FieldTraits&lt; DynamicVector&lt; K, Allocator &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01525.html">EmptySet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An empty set.  <a href="a01525.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01529.html">AllSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set containing everything.  <a href="a01529.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01533.html">EnumItem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set consisting only of one item.  <a href="a01533.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01537.html">EnumRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set representing a range including the borders.  <a href="a01537.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01541.html">NegateSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The negation of a set. An item is contained in the set if and only if it is not contained in the negated set.  <a href="a01541.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01545.html">Combine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set combining two other sets.  <a href="a01545.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01549.html">Exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for Dune-Exceptions.  <a href="a01549.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01553.html">ExceptionHook</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class to add a hook to the <a class="el" href="a01549.html" title="Base class for Dune-Exceptions.">Dune::Exception</a>.  <a href="a01553.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01557.html">IOError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default exception class for I/O errors.  <a href="a01557.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01561.html">MathError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default exception class for mathematical errors.  <a href="a01561.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01565.html">RangeError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default exception class for range errors.  <a href="a01565.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01569.html">NotImplemented</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default exception for dummy implementations.  <a href="a01569.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01573.html">SystemError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default exception class for OS errors.  <a href="a01573.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01577.html">OutOfMemoryError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default exception if memory allocation fails.  <a href="a01577.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01581.html">InvalidStateException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default exception if a function was called while the object is not in a valid state for that function.  <a href="a01581.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01585.html">ParallelError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default exception if an error in the parallel communication of the program occurred.  <a href="a01585.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01721.html">FloatCmpOps</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class encapsulating a default epsilon.  <a href="a01721.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01725.html">DenseMatVecTraits&lt; FieldMatrix&lt; K, ROWS, COLS &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01729.html">FieldTraits&lt; FieldMatrix&lt; K, ROWS, COLS &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01733.html">FieldTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01737.html">FieldTraits&lt; const T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01741.html">FieldTraits&lt; std::complex&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01745.html">FieldTraits&lt; T[N] &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01749.html">FieldTraits&lt; std::vector&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01753.html">Function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class template for function classes.  <a href="a01753.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01761.html">VirtualFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual base class template for function classes.  <a href="a01761.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01769.html">DenseMatVecTraits&lt; FieldVector&lt; K, SIZE &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01773.html">FieldTraits&lt; FieldVector&lt; K, SIZE &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01777.html">IsFieldVectorSizeCorrect</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">TMP to check the size of a DenseVectors statically, if possible.  <a href="a01777.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01781.html">IsFieldVectorSizeCorrect&lt; FieldVector&lt; T, SIZE &gt;, SIZE &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01785.html">IsFieldVectorSizeCorrect&lt; FieldVector&lt; T, SIZE1 &gt;, SIZE &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01789.html">Gcd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculator of the greatest common divisor.  <a href="a01789.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01793.html">const_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the 'const' version of a reference to a mutable object.  <a href="a01793.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01797.html">const_reference&lt; const R &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01801.html">const_reference&lt; R &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01805.html">const_reference&lt; const R &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01809.html">mutable_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the 'mutable' version of a reference to a const object  <a href="a01809.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01813.html">mutable_reference&lt; const R &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01817.html">mutable_reference&lt; R &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01821.html">mutable_reference&lt; const R &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01825.html">GenericIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic class for stl-conforming iterators for container classes with operator[].  <a href="a01825.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01829.html">GMPField</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number class for high precision floating point number using the GMP library mpf_class implementation.  <a href="a01829.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01833.html">IsNumber&lt; GMPField&lt; precision &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01837.html">PromotionTraits&lt; GMPField&lt; precision1 &gt;, GMPField&lt; precision2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01841.html">PromotionTraits&lt; GMPField&lt; precision &gt;, GMPField&lt; precision &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01845.html">PromotionTraits&lt; GMPField&lt; precision &gt;, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01849.html">PromotionTraits&lt; T, GMPField&lt; precision &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01853.html">hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor for hashing objects of type T.  <a href="a01853.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01861.html">Indent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for handling nested indentation in output.  <a href="a01861.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01865.html">Cloneable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface class for cloneable objects.  <a href="a01865.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01869.html">ios_base_all_saver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for storing and resetting stream attributes.  <a href="a01869.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01873.html">ForwardIteratorFacade</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for stl conformant forward iterators.  <a href="a01873.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01877.html">BidirectionalIteratorFacade</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Facade class for stl conformant bidirectional iterators.  <a href="a01877.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01881.html">RandomAccessIteratorFacade</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for stl conformant forward iterators.  <a href="a01881.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01885.html">IteratorRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple range between a begin and an end iterator.  <a href="a01885.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01889.html">Lcm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the least common multiple of two numbers.  <a href="a01889.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01897.html">lru</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">LRU Cache Container.  <a href="a01897.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01901.html">MallocAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocators implementation which simply calls malloc/free.  <a href="a01901.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01909.html">StandardMathematicalConstants</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard implementation of <a class="el" href="a01913.html" title="Provides commonly used mathematical constants.">MathematicalConstants</a>.  <a href="a01909.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01913.html">MathematicalConstants</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides commonly used mathematical constants.  <a href="a01913.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01917.html">Factorial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the factorial of m at compile time.  <a href="a01917.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01921.html">Factorial&lt; 0 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">end of recursion of factorial via specialization  <a href="a01921.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01941.html">DenseMatVecTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01957.html">No_Comm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01961.html">Communication</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collective communication interface and sequential default implementation.  <a href="a01961.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01965.html">SizeOne</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for marking indexed data structures where data at each index is of the same size.  <a href="a01965.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01969.html">VariableSize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for marking indexed data structures where the data at each index may be a variable multiple of another type.  <a href="a01969.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01973.html">CommPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default policy used for communicating an indexed type.  <a href="a01973.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01997.html">BufferedCommunicator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A communicator that uses buffers to gather and scatter the data to be send or received.  <a href="a01997.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02041.html">InvalidFutureException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This exception is thrown when <code>ready()</code>, <code>wait()</code> or <code><a class="el" href="a00428.html#a422c8e50ed4f40b534187b8fb83fbf3d">get()</a></code> is called on an invalid future. A future is valid until <code><a class="el" href="a00428.html#a422c8e50ed4f40b534187b8fb83fbf3d">get()</a></code> is called and if it is not default-constructed and it was not moved from.  <a href="a02041.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02045.html">PseudoFuture</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper-class for a object which is ready immediately.  <a href="a02045.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02049.html">Future</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-erasure for future-like objects. A future-like object is a object satisfying the interface of FutureBase.  <a href="a02049.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02061.html">PseudoFuture&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02065.html">IndexPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pair consisting of a global and local index.  <a href="a02065.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02069.html">InvalidIndexSetState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a01549.html" title="Base class for Dune-Exceptions.">Exception</a> indicating that the index set is not in the expected state.  <a href="a02069.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02073.html">GlobalLookupIndexSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decorates an index set with the possibility to find a global index that is mapped to a specific local.  <a href="a02073.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02077.html">ParallelIndexSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manager class for the mapping between local indices and globally unique indices.  <a href="a02077.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02085.html">LocalIndexComparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02089.html">IndexSetSortFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02093.html">IndicesSyncer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for recomputing missing indices of a distributed index set.  <a href="a02093.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02109.html">InterfaceBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class of all classes representing a communication interface.  <a href="a02109.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02117.html">InterfaceInformation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information describing an interface.  <a href="a02117.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02121.html">Interface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a01961.html" title="Collective communication interface and sequential default implementation.">Communication</a> interface between remote and local indices.  <a href="a02121.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02129.html">LocalIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An index present on the local process.  <a href="a02129.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02133.html">Generic_MPI_Op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02137.html">Communication&lt; MPI_Comm &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="a01961.html" title="Collective communication interface and sequential default implementation.">Communication</a> for MPI.  <a href="a02137.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02141.html">MPIData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02145.html">MPIData&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02149.html">MPIData&lt; T, std::void_t&lt; std::tuple&lt; decltype(std::declval&lt; T &gt;().data()), decltype(std::declval&lt; T &gt;().size()), typename std::decay_t&lt; T &gt;::value_type &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02165.html">MPIFuture</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a future-like object for MPI communication. It contains the object that will be received and might contain also a sending object, which must be hold (keep alive) until the communication has been completed.  <a href="a02165.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02169.html">MPIGuardError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This exception is thrown if the <a class="el" href="a02173.html" title="detects a thrown exception and communicates to all other processes">MPIGuard</a> detects an error on a remote process.  <a href="a02169.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02173.html">MPIGuard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">detects a thrown exception and communicates to all other processes  <a href="a02173.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02177.html">FakeMPIHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fake mpi helper.  <a href="a02177.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02181.html">MPIHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A real mpi helper.  <a href="a02181.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02185.html">MPIPack</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02189.html">MPIData&lt; P, std::enable_if_t&lt; std::is_same&lt; std::remove_const_t&lt; P &gt;, MPIPack &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02193.html">ParallelLocalIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An index present on the local process with an additional attribute flag.  <a href="a02193.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02197.html">LocalIndexComparator&lt; ParallelLocalIndex&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02201.html">MPITraits&lt; ParallelLocalIndex&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02205.html">MPITraits&lt; IndexPair&lt; TG, ParallelLocalIndex&lt; TA &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02209.html">RemoteIndices</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The indices present on remote processes.  <a href="a02209.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02213.html">RemoteIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about an index residing on another processor.  <a href="a02213.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02217.html">RemoteIndexListModifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifier for adding and/or deleting remote indices from the remote index list.  <a href="a02217.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02221.html">CollectiveIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A collective iterator for moving over the remote indices for all processes collectively.  <a href="a02221.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02225.html">OwnerOverlapCopyCommunication</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02237.html">SelectionIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const iterator over an uncached selection.  <a href="a02237.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02241.html">UncachedSelection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An uncached selection of indices.  <a href="a02241.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02245.html">Selection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cached selection of indices.  <a href="a02245.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02261.html">VariableSizeCommunicator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A buffered communicator where the amount of data sent does not have to be known a priori.  <a href="a02261.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02301.html">ParameterizedObjectFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A factory class for parameterized objects.  <a href="a02301.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02305.html">ParameterizedObjectFactory&lt; TypeT(Args...), KeyT &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02317.html">ParameterTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hierarchical structure of string parameters.  <a href="a02317.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02353.html">ParameterTreeParserError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">report parser error while reading <a class="el" href="a02317.html" title="Hierarchical structure of string parameters.">ParameterTree</a>  <a href="a02353.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02357.html">HelpRequest</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">exception thrown if the user wants to see help string  <a href="a02357.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02361.html">ParameterTreeParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parsers to set up a <a class="el" href="a02317.html" title="Hierarchical structure of string parameters.">ParameterTree</a> from various input sources.  <a href="a02361.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02365.html">Pool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A memory pool of objects.  <a href="a02365.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02369.html">PoolAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An allocator managing a pool of objects for reuse.  <a href="a02369.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02385.html">PoolAllocator&lt; void, s &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02393.html">StaticPower</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates m^p at compile time.  <a href="a02393.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02397.html">Power</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute power for a run-time mantissa and a compile-time integer exponent.  <a href="a02397.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02401.html">FMatrixPrecision</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Precisions for calculations with <a class="el" href="a01401.html" title="A dense n x m matrix.">FieldMatrix</a> and <a class="el" href="a01405.html" title="vector space out of a tensor product of fields.">FieldVector</a>.  <a href="a02401.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02405.html">PromotionTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute type of the result of an arithmetic operation involving two different number types.  <a href="a02405.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02409.html">PromotionTraits&lt; T1, T1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02413.html">PropertyMapTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02417.html">ReadablePropertyMapTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag for the category of readable property maps.  <a href="a02417.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02421.html">WritablePropertyMapTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag for the category of writable property maps.  <a href="a02421.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02425.html">ReadWritePropertyMapTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag for the category of readable and writable property maps.  <a href="a02425.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02429.html">LvaluePropertyMapTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag for the category of lvalue property maps.  <a href="a02429.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02433.html">PropertyMapTraits&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02437.html">PropertyMapTraits&lt; const T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02441.html">RAPropertyMapHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02445.html">IteratorPropertyMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapter to turn a random access iterator into a property map.  <a href="a02445.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02449.html">AssociativePropertyMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An adapter to turn an unique associative container into a property map.  <a href="a02449.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02453.html">ConstAssociativePropertyMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An adaptor to turn an unique associative container into a property map.  <a href="a02453.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02457.html">IdentityMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A property map that applies the identity function to integers.  <a href="a02457.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02461.html">PropertyMapTypeSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selector for the property map type.  <a href="a02461.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02473.html">IntegralRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">dynamic integer range for use in range-based for loops  <a href="a02473.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02477.html">StaticIntegralRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">static integer range for use in range-based for loops  <a href="a02477.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02481.html">ValueTransformationTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag to enable value based transformations in <a class="el" href="a02509.html" title="A range transforming the values of another range on-the-fly.">TransformedRangeView</a>.  <a href="a02481.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02485.html">IteratorTransformationTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag to enable iterator based transformations in <a class="el" href="a02509.html" title="A range transforming the values of another range on-the-fly.">TransformedRangeView</a>.  <a href="a02485.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02509.html">TransformedRangeView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A range transforming the values of another range on-the-fly.  <a href="a02509.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02513.html">ReservedVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Vector class with statically reserved memory.  <a href="a02513.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>FieldTraits&lt; Impl::ScalarMatrixView&lt; K &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>DenseMatVecTraits&lt; Impl::ScalarMatrixView&lt; K &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>AutonomousValueType&lt; Impl::ScalarMatrixView&lt; K &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>DenseMatVecTraits&lt; Impl::ScalarVectorView&lt; K &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>FieldTraits&lt; Impl::ScalarVectorView&lt; K &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>AutonomousValueType&lt; Impl::ScalarVectorView&lt; K &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02549.html">null_deleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">implements the Deleter concept of shared_ptr without deleting anything  <a href="a02549.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02581.html">LoopSIMD</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02597.html">IsNumber&lt; LoopSIMD&lt; T, S, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02785.html">IsNumber&lt; Vc::SimdArray&lt; T, N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02789.html">IsNumber&lt; Vc::Vector&lt; T, Abi &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02793.html">AutonomousValueType&lt; Simd::VcImpl::Proxy&lt; V &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of AutonomousValue for Vc proxies.  <a href="a02793.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02797.html">SimdScalarTypeTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02801.html">SimdScalarTypeTraits&lt; AlignedNumber&lt; T, align &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">deduce the underlying scalar data type of an AlignedNumber  <a href="a02801.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02805.html">SimdIndexTypeTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02809.html">SimdMaskTypeTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02813.html">Singleton</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An adapter to turn a class into a singleton.  <a href="a02813.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02817.html">SLListIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutable iterator for the <a class="el" href="a02829.html" title="A single linked list.">SLList</a>.  <a href="a02817.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02821.html">SLListConstIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant iterator for the <a class="el" href="a02829.html" title="A single linked list.">SLList</a>.  <a href="a02821.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02825.html">SLListModifyIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutable iterator for the <a class="el" href="a02829.html" title="A single linked list.">SLList</a>.  <a href="a02825.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02829.html">SLList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single linked list.  <a href="a02829.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02881.html">Timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple stop watch.  <a href="a02881.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02889.html">TupleAccessTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02893.html">TupleAccessTraits&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02897.html">TupleAccessTraits&lt; T &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02901.html">NullPointerInitialiser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper template that initializes a std::tuple consisting of pointers to nullptr.  <a href="a02901.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02905.html">NullPointerInitialiser&lt; std::tuple&lt; Args... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02909.html">ForEachType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template to clone the type definition of a std::tuple with the storage types replaced by a user-defined rule.  <a href="a02909.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02913.html">ForEachType&lt; TE, std::tuple&lt; Args... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02917.html">TransformTupleFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02925.html">AddRefTypeEvaluator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>TypeEvaluator</code> to turn a type <code>T</code> into a reference to <code>T</code>  <a href="a02925.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02929.html">AddPtrTypeEvaluator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>TypeEvaluator</code> to turn a type <code>T</code> into a pointer to <code>T</code>  <a href="a02929.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02933.html">AddPtrTypeEvaluator&lt; T &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02937.html">AtType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for reverse element access.  <a href="a02937.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02941.html">At</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse element access.  <a href="a02941.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02945.html">PointerPairDeletor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all objects pointed to in a std::tuple of pointers.  <a href="a02945.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02949.html">FirstPredicateIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finding the index of a certain type in a std::tuple.  <a href="a02949.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02953.html">IsType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generator for predicates accepting one particular type.  <a href="a02953.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02961.html">FirstTypeIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first occurrence of a type in a std::tuple.  <a href="a02961.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02965.html">PushBackTuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template to append a type to a std::tuple.  <a href="a02965.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02969.html">PushBackTuple&lt; typename std::tuple&lt; Args... &gt;, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02973.html">PushFrontTuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template to prepend a type to a std::tuple.  <a href="a02973.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02977.html">PushFrontTuple&lt; typename std::tuple&lt; Args... &gt;, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02981.html">ReduceTuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply reduce with meta binary function to template.  <a href="a02981.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02985.html">ReduceTuple&lt; F, Tuple, Seed, 0 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply reduce with meta binary function to template.  <a href="a02985.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02989.html">JoinTuples</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join two std::tuple's.  <a href="a02989.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02993.html">FlattenTuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flatten a std::tuple of std::tuple's.  <a href="a02993.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a02997.html">TupleVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class augmenting std::tuple by element access via operator[].  <a href="a02997.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03001.html">MetaType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type that refers to another type.  <a href="a03001.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03005.html">IsTypeList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if given type is a TypeList.  <a href="a03005.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03009.html">IsTypeList&lt; TypeList&lt; T... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if given type is a TypeList.  <a href="a03009.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03013.html">IsEmptyTypeList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if given type is an empty TypeList.  <a href="a03013.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03017.html">TypeListSize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03021.html">TypeListSize&lt; TypeList&lt; T... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get size of TypeList.  <a href="a03021.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03025.html">TypeListElement</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03029.html">TypeListElement&lt; i, TypeList&lt; T... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get element of TypeList.  <a href="a03029.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03057.html">Empty</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just an empty class.  <a href="a03057.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03061.html">IsInteroperable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether two types are interoperable.  <a href="a03061.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03065.html">EnableIfInterOperable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable typedef if two types are interoperable.  <a href="a03065.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03069.html">AlwaysFalse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">template which always yields a false value  <a href="a03069.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03073.html">AlwaysTrue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">template which always yields a true value  <a href="a03073.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03077.html">IsCallable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is callable with ()-operator and given arguments.  <a href="a03077.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03081.html">IsCallable&lt; F(Args...), R &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is callable with ()-operator and given arguments.  <a href="a03081.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03085.html">IsNumber</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this type acts as a scalar in the context of (hierarchically blocked) containers.  <a href="a03085.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03089.html">HasNaN</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this type has a value of NaN.  <a href="a03089.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03093.html">IsIndexable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine whether an instance of T has an operator[](I), i.e. whether it can be indexed with an index of type I.  <a href="a03093.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03097.html">IsIterable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">typetrait to check that a class has begin() and end() members  <a href="a03097.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03101.html">IsTuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if T is a std::tuple&lt;...&gt;  <a href="a03101.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03105.html">IsTupleOrDerived</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if T derived from a std::tuple&lt;...&gt;  <a href="a03105.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03109.html">IsIntegralConstant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if T is an std::integral_constant&lt;I, i&gt;  <a href="a03109.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03113.html">SizeOf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute size of variadic type list.  <a href="a03113.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03117.html">IntegerSequenceEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get entry of std::integer_sequence.  <a href="a03117.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03121.html">AutonomousValueType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type free of internal references that <code>T</code> can be converted to.  <a href="a03121.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03125.html">AutonomousValueType&lt; T &amp; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization to remove lvalue references.  <a href="a03125.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03129.html">AutonomousValueType&lt; T &amp;&amp; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization to remove rvalue references.  <a href="a03129.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03133.html">AutonomousValueType&lt; const T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization to remove const qualifiers.  <a href="a03133.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03137.html">AutonomousValueType&lt; volatile T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization to remove volatile qualifiers.  <a href="a03137.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03141.html">AutonomousValueType&lt; std::vector&lt; bool &gt;::reference &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the proxies of <code>vector&lt;bool&gt;</code>  <a href="a03141.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03145.html">AutonomousValueType&lt; volatile const T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization to remove both const and volatile qualifiers.  <a href="a03145.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03157.html">PriorityTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for tagging priorities.  <a href="a03157.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03161.html">PriorityTag&lt; 0 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for tagging priorities.  <a href="a03161.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aeeddbd17746ee9ac74ce286741916e4c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#aeeddbd17746ee9ac74ce286741916e4c">ViolatedAlignmentHandler</a> = std::function&lt; void(const char *, std::size_t, const void *)&gt;</td></tr>
<tr class="memdesc:aeeddbd17746ee9ac74ce286741916e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of the handler called by <code><a class="el" href="a00428.html#a0e6c32c539889f324d46417dca3dfebe" title="called when an alignment violation is detected">violatedAlignment()</a></code>  <a href="a00428.html#aeeddbd17746ee9ac74ce286741916e4c">More...</a><br /></td></tr>
<tr class="separator:aeeddbd17746ee9ac74ce286741916e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b78ef57d1b77933ab277ebe66c79d94"><td class="memItemLeft" align="right" valign="top">typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00413.html#ga7b78ef57d1b77933ab277ebe66c79d94">DebugLevel</a></td></tr>
<tr class="memdesc:ga7b78ef57d1b77933ab277ebe66c79d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for debug levels.  <a href="a00413.html#ga7b78ef57d1b77933ab277ebe66c79d94">More...</a><br /></td></tr>
<tr class="separator:ga7b78ef57d1b77933ab277ebe66c79d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf764509e6dae37477f5ad09b5ca3467"><td class="memTemplParams" colspan="2">template&lt;std::size_t i&gt; </td></tr>
<tr class="memitem:gacf764509e6dae37477f5ad09b5ca3467"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00400.html#gacf764509e6dae37477f5ad09b5ca3467">index_constant</a> = std::integral_constant&lt; std::size_t, i &gt;</td></tr>
<tr class="memdesc:gacf764509e6dae37477f5ad09b5ca3467"><td class="mdescLeft">&#160;</td><td class="mdescRight">An index constant with value i.  <a href="a00400.html#gacf764509e6dae37477f5ad09b5ca3467">More...</a><br /></td></tr>
<tr class="separator:gacf764509e6dae37477f5ad09b5ca3467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c6057d41509cc616fb60f483d7d6dd"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a51c6057d41509cc616fb60f483d7d6dd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#a51c6057d41509cc616fb60f483d7d6dd">CollectiveCommunication</a> = <a class="el" href="a01961.html">Communication</a>&lt; T &gt;</td></tr>
<tr class="separator:a51c6057d41509cc616fb60f483d7d6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cab87dc8a3eff4191a99a1084d7b28e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7cab87dc8a3eff4191a99a1084d7b28e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#a7cab87dc8a3eff4191a99a1084d7b28e">SimdScalar</a> = typename <a class="el" href="a02797.html">SimdScalarTypeTraits</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a7cab87dc8a3eff4191a99a1084d7b28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c668a396cf5cd88bb7da3225787959a"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a3c668a396cf5cd88bb7da3225787959a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#a3c668a396cf5cd88bb7da3225787959a">SimdIndex</a> = typename <a class="el" href="a02805.html">SimdIndexTypeTraits</a>&lt; V &gt;::type</td></tr>
<tr class="memdesc:a3c668a396cf5cd88bb7da3225787959a"><td class="mdescLeft">&#160;</td><td class="mdescRight">An simd vector of indices corresponding to a simd vector V.  <a href="a00428.html#a3c668a396cf5cd88bb7da3225787959a">More...</a><br /></td></tr>
<tr class="separator:a3c668a396cf5cd88bb7da3225787959a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a846fa7e0d4cf9e70b148592224eb360f"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a846fa7e0d4cf9e70b148592224eb360f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#a846fa7e0d4cf9e70b148592224eb360f">SimdMask</a> = typename <a class="el" href="a02809.html">SimdMaskTypeTraits</a>&lt; V &gt;::type</td></tr>
<tr class="memdesc:a846fa7e0d4cf9e70b148592224eb360f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simd vector of truth values corresponding to a simd vector V.  <a href="a00428.html#a846fa7e0d4cf9e70b148592224eb360f">More...</a><br /></td></tr>
<tr class="separator:a846fa7e0d4cf9e70b148592224eb360f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08d48df3a7a0e3bd9c0425aba8004488"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a01389.html">DebugStream</a>&lt; <a class="el" href="a00426.html#ga490cf91178ed464c3eff5871b4b03c8f">VERY_VERBOSE_DEBUG_LEVEL</a>, <a class="el" href="a00426.html#ga2c074d4df6d5fa8fbe8b4e9d44b35df0">MINIMAL_DEBUG_LEVEL</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00426.html#ga08d48df3a7a0e3bd9c0425aba8004488">DVVerbType</a></td></tr>
<tr class="memdesc:ga08d48df3a7a0e3bd9c0425aba8004488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of very verbose debug stream.  <a href="a00426.html#ga08d48df3a7a0e3bd9c0425aba8004488">More...</a><br /></td></tr>
<tr class="separator:ga08d48df3a7a0e3bd9c0425aba8004488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65d14f278ea400db87ffb6a4bc7ed7b2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a01389.html">DebugStream</a>&lt; <a class="el" href="a00426.html#gabdcf3b4c1aefae00afd3ecaf84f755bb">VERBOSE_DEBUG_LEVEL</a>, <a class="el" href="a00426.html#ga2c074d4df6d5fa8fbe8b4e9d44b35df0">MINIMAL_DEBUG_LEVEL</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00426.html#ga65d14f278ea400db87ffb6a4bc7ed7b2">DVerbType</a></td></tr>
<tr class="memdesc:ga65d14f278ea400db87ffb6a4bc7ed7b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of more verbose debug stream.  <a href="a00426.html#ga65d14f278ea400db87ffb6a4bc7ed7b2">More...</a><br /></td></tr>
<tr class="separator:ga65d14f278ea400db87ffb6a4bc7ed7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab41f4590c73d6408c89475e28bf18a8e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a01389.html">DebugStream</a>&lt; <a class="el" href="a00426.html#gaabd88387e7eb826323b9f7d3a53a283e">INFO_DEBUG_LEVEL</a>, <a class="el" href="a00426.html#ga2c074d4df6d5fa8fbe8b4e9d44b35df0">MINIMAL_DEBUG_LEVEL</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00426.html#gab41f4590c73d6408c89475e28bf18a8e">DInfoType</a></td></tr>
<tr class="memdesc:gab41f4590c73d6408c89475e28bf18a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of debug stream with info level.  <a href="a00426.html#gab41f4590c73d6408c89475e28bf18a8e">More...</a><br /></td></tr>
<tr class="separator:gab41f4590c73d6408c89475e28bf18a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20379ab9c4472509d420e98659683fe6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a01389.html">DebugStream</a>&lt; <a class="el" href="a00426.html#gaed2aba7a7e55b026716d5027406566a0">WARN_DEBUG_LEVEL</a>, <a class="el" href="a00426.html#ga2c074d4df6d5fa8fbe8b4e9d44b35df0">MINIMAL_DEBUG_LEVEL</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00426.html#ga20379ab9c4472509d420e98659683fe6">DWarnType</a></td></tr>
<tr class="memdesc:ga20379ab9c4472509d420e98659683fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of debug stream with warn level.  <a href="a00426.html#ga20379ab9c4472509d420e98659683fe6">More...</a><br /></td></tr>
<tr class="separator:ga20379ab9c4472509d420e98659683fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70e0eedd6c7f613d6e9608fabb4d240d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a01389.html">DebugStream</a>&lt; <a class="el" href="a00426.html#ga4fc828eb9bb6c6b6143034b9211d2b72">GRAVE_DEBUG_LEVEL</a>, <a class="el" href="a00426.html#ga2c074d4df6d5fa8fbe8b4e9d44b35df0">MINIMAL_DEBUG_LEVEL</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00426.html#ga70e0eedd6c7f613d6e9608fabb4d240d">DGraveType</a></td></tr>
<tr class="memdesc:ga70e0eedd6c7f613d6e9608fabb4d240d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of debug stream for fatal errors.  <a href="a00426.html#ga70e0eedd6c7f613d6e9608fabb4d240d">More...</a><br /></td></tr>
<tr class="separator:ga70e0eedd6c7f613d6e9608fabb4d240d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga768c0b513889d713fd0017ef7ae35056"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a01389.html">DebugStream</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00426.html#ga768c0b513889d713fd0017ef7ae35056">DErrType</a></td></tr>
<tr class="memdesc:ga768c0b513889d713fd0017ef7ae35056"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the stream used for error messages.  <a href="a00426.html#ga768c0b513889d713fd0017ef7ae35056">More...</a><br /></td></tr>
<tr class="separator:ga768c0b513889d713fd0017ef7ae35056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bbde85cc655ad122680398fef8fa5cd"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9bbde85cc655ad122680398fef8fa5cd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#a9bbde85cc655ad122680398fef8fa5cd">ToUniquePtr</a> = std::unique_ptr&lt; T &gt;</td></tr>
<tr class="memdesc:a9bbde85cc655ad122680398fef8fa5cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>std::unique_ptr</code> introduced as transition wrapper.  <a href="a00428.html#a9bbde85cc655ad122680398fef8fa5cd">More...</a><br /></td></tr>
<tr class="separator:a9bbde85cc655ad122680398fef8fa5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e18d05cb5d1e95f0e7c7409ffe9689f"><td class="memTemplParams" colspan="2">template&lt;class... T&gt; </td></tr>
<tr class="memitem:ga7e18d05cb5d1e95f0e7c7409ffe9689f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00407.html#ga7e18d05cb5d1e95f0e7c7409ffe9689f">TypeList</a> = std::tuple&lt; <a class="el" href="a03001.html">MetaType</a>&lt; T &gt;... &gt;</td></tr>
<tr class="memdesc:ga7e18d05cb5d1e95f0e7c7409ffe9689f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple type list.  <a href="a00407.html#ga7e18d05cb5d1e95f0e7c7409ffe9689f">More...</a><br /></td></tr>
<tr class="separator:ga7e18d05cb5d1e95f0e7c7409ffe9689f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06816da928c17285e09ccb74357648b"><td class="memTemplParams" colspan="2">template&lt;std::size_t i, class T &gt; </td></tr>
<tr class="memitem:ae06816da928c17285e09ccb74357648b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#ae06816da928c17285e09ccb74357648b">TypeListEntry_t</a> = typename <a class="el" href="a03025.html">TypeListElement</a>&lt; i, T &gt;::type</td></tr>
<tr class="memdesc:ae06816da928c17285e09ccb74357648b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut for TypeListElement&lt;i, T&gt;::type;.  <a href="a00428.html#ae06816da928c17285e09ccb74357648b">More...</a><br /></td></tr>
<tr class="separator:ae06816da928c17285e09ccb74357648b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05190548d101a946d1cab292cff5fdb9"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class Target, class TL &gt; </td></tr>
<tr class="memitem:a05190548d101a946d1cab292cff5fdb9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#a05190548d101a946d1cab292cff5fdb9">UnpackTypeList_t</a> = typename Impl::UnpackTypeList&lt; Target, TL &gt;::type</td></tr>
<tr class="memdesc:a05190548d101a946d1cab292cff5fdb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack <a class="el" href="a00407.html#ga7e18d05cb5d1e95f0e7c7409ffe9689f" title="A simple type list.">Dune::TypeList</a>.  <a href="a00428.html#a05190548d101a946d1cab292cff5fdb9">More...</a><br /></td></tr>
<tr class="separator:a05190548d101a946d1cab292cff5fdb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f31a234ebc9fa02660570324eabde1a"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class Target, class... T&gt; </td></tr>
<tr class="memitem:a7f31a234ebc9fa02660570324eabde1a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#a7f31a234ebc9fa02660570324eabde1a">UniqueTypes_t</a> = typename Impl::UniqueTypesHelper&lt; Target, <a class="el" href="a00407.html#ga7e18d05cb5d1e95f0e7c7409ffe9689f">TypeList</a>&lt; T... &gt; &gt;::type</td></tr>
<tr class="memdesc:a7f31a234ebc9fa02660570324eabde1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove duplicates from a list of types.  <a href="a00428.html#a7f31a234ebc9fa02660570324eabde1a">More...</a><br /></td></tr>
<tr class="separator:a7f31a234ebc9fa02660570324eabde1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e5f27ee5ff462d88e7eb109f143263"><td class="memTemplParams" colspan="2">template&lt;class NonUniqueTypeList &gt; </td></tr>
<tr class="memitem:ab8e5f27ee5ff462d88e7eb109f143263"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#ab8e5f27ee5ff462d88e7eb109f143263">UniqueTypeList_t</a> = typename Impl::UniqueTypesHelper&lt; <a class="el" href="a00407.html#ga7e18d05cb5d1e95f0e7c7409ffe9689f">TypeList</a>, NonUniqueTypeList &gt;::type</td></tr>
<tr class="memdesc:ab8e5f27ee5ff462d88e7eb109f143263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove duplicates from a <a class="el" href="a00407.html#ga7e18d05cb5d1e95f0e7c7409ffe9689f" title="A simple type list.">Dune::TypeList</a>.  <a href="a00428.html#ab8e5f27ee5ff462d88e7eb109f143263">More...</a><br /></td></tr>
<tr class="separator:ab8e5f27ee5ff462d88e7eb109f143263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a3de1d2dbd47536c4b007d3a3b108a2"><td class="memTemplParams" colspan="2">template&lt;class... Types&gt; </td></tr>
<tr class="memitem:ga6a3de1d2dbd47536c4b007d3a3b108a2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00409.html#ga6a3de1d2dbd47536c4b007d3a3b108a2">void_t</a> = typename Impl::voider&lt; Types... &gt;::type</td></tr>
<tr class="memdesc:ga6a3de1d2dbd47536c4b007d3a3b108a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is void for all valid input types. The workhorse for C++11 SFINAE-techniques.  <a href="a00409.html#ga6a3de1d2dbd47536c4b007d3a3b108a2">More...</a><br /></td></tr>
<tr class="separator:ga6a3de1d2dbd47536c4b007d3a3b108a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadd3a3e69d0220b41bb40ebc442d79ae"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:gaadd3a3e69d0220b41bb40ebc442d79ae"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00409.html#gaadd3a3e69d0220b41bb40ebc442d79ae">field_t</a> = typename <a class="el" href="a01733.html">FieldTraits</a>&lt; Type &gt;::field_type</td></tr>
<tr class="memdesc:gaadd3a3e69d0220b41bb40ebc442d79ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient access to <a class="el" href="a01733.html#aaaf5412c6ed2f4ac627eec87a2d1de1b" title="export the type representing the field">FieldTraits&lt;Type&gt;::field_type</a>.  <a href="a00409.html#gaadd3a3e69d0220b41bb40ebc442d79ae">More...</a><br /></td></tr>
<tr class="separator:gaadd3a3e69d0220b41bb40ebc442d79ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48aa0bb0268c390d251495eabdac4ae6"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:ga48aa0bb0268c390d251495eabdac4ae6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00409.html#ga48aa0bb0268c390d251495eabdac4ae6">real_t</a> = typename <a class="el" href="a01733.html">FieldTraits</a>&lt; Type &gt;::real_type</td></tr>
<tr class="memdesc:ga48aa0bb0268c390d251495eabdac4ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient access to <a class="el" href="a01733.html#ab1c1583160e1c47c4909273c82ae7a63" title="export the type representing the real type of the field">FieldTraits&lt;Type&gt;::real_type</a>.  <a href="a00409.html#ga48aa0bb0268c390d251495eabdac4ae6">More...</a><br /></td></tr>
<tr class="separator:ga48aa0bb0268c390d251495eabdac4ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64c2d9377550162293c4fabd163f457b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga64c2d9377550162293c4fabd163f457b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00409.html#ga64c2d9377550162293c4fabd163f457b">AutonomousValue</a> = typename <a class="el" href="a03121.html">AutonomousValueType</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:ga64c2d9377550162293c4fabd163f457b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type free of internal references that <code>T</code> can be converted to.  <a href="a00409.html#ga64c2d9377550162293c4fabd163f457b">More...</a><br /></td></tr>
<tr class="separator:ga64c2d9377550162293c4fabd163f457b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cf0dfc6fe8998b21503cd81c6681afc"><td class="memTemplParams" colspan="2">template&lt;class This , class... T&gt; </td></tr>
<tr class="memitem:ga5cf0dfc6fe8998b21503cd81c6681afc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00407.html#ga5cf0dfc6fe8998b21503cd81c6681afc">disableCopyMove</a> = std::enable_if_t&lt; not Impl::disableCopyMoveHelper&lt; This, T... &gt;::value, int &gt;</td></tr>
<tr class="memdesc:ga5cf0dfc6fe8998b21503cd81c6681afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to disable constructor as copy and move constructor.  <a href="a00407.html#ga5cf0dfc6fe8998b21503cd81c6681afc">More...</a><br /></td></tr>
<tr class="separator:ga5cf0dfc6fe8998b21503cd81c6681afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a587081ae4568cb94ed43b5dbaba7870e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="a00400.html#ga587081ae4568cb94ed43b5dbaba7870ea7de84f476fd1d9f55ac5e2c25f252c3b">implementationDefined</a>
 }</td></tr>
<tr class="separator:a587081ae4568cb94ed43b5dbaba7870e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b1dd66b80964351e68f44bddb32593e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00419.html#ga1b1dd66b80964351e68f44bddb32593e">ParallelIndexSetState</a> { <a class="el" href="a00419.html#gga1b1dd66b80964351e68f44bddb32593ea30f779eddf23499c322b692257ae7116">GROUND</a>
, <a class="el" href="a00419.html#gga1b1dd66b80964351e68f44bddb32593ea2fbc0ce9b92442e69a405a452f2ef416">RESIZE</a>
 }</td></tr>
<tr class="memdesc:ga1b1dd66b80964351e68f44bddb32593e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The states the index set can be in.  <a href="a00419.html#ga1b1dd66b80964351e68f44bddb32593e">More...</a><br /></td></tr>
<tr class="separator:ga1b1dd66b80964351e68f44bddb32593e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f24bf6f596bf963429e084ecf3a0835"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00419.html#ga4f24bf6f596bf963429e084ecf3a0835">LocalIndexState</a> { <a class="el" href="a00419.html#gga4f24bf6f596bf963429e084ecf3a0835a10e7469c306a6a1cc9c8c89ce65b09f5">VALID</a>
, <a class="el" href="a00419.html#gga4f24bf6f596bf963429e084ecf3a0835ab8c498280a429843d8eaa93ddfb8fb02">DELETED</a>
 }</td></tr>
<tr class="memdesc:ga4f24bf6f596bf963429e084ecf3a0835"><td class="mdescLeft">&#160;</td><td class="mdescRight">The states avaiable for the local indices.  <a href="a00419.html#ga4f24bf6f596bf963429e084ecf3a0835">More...</a><br /></td></tr>
<tr class="separator:ga4f24bf6f596bf963429e084ecf3a0835"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga354fc36a88498193df8a295e678de95a"><td class="memTemplParams" colspan="2">template&lt;int k&gt; </td></tr>
<tr class="memitem:ga354fc36a88498193df8a295e678de95a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00411.html#ga354fc36a88498193df8a295e678de95a">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="a01301.html">bigunsignedint</a>&lt; k &gt; &amp;x)</td></tr>
<tr class="separator:ga354fc36a88498193df8a295e678de95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4733af4e0faa3a06ea6cd1e030cadfe0"><td class="memTemplParams" colspan="2">template&lt;int k&gt; </td></tr>
<tr class="memitem:ga4733af4e0faa3a06ea6cd1e030cadfe0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01301.html">bigunsignedint</a>&lt; k &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00411.html#ga4733af4e0faa3a06ea6cd1e030cadfe0">operator+</a> (const <a class="el" href="a01301.html">bigunsignedint</a>&lt; k &gt; &amp;x, std::uintmax_t y)</td></tr>
<tr class="separator:ga4733af4e0faa3a06ea6cd1e030cadfe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1e188eaa5ea83115d8b7137ce9252a5"><td class="memTemplParams" colspan="2">template&lt;int k&gt; </td></tr>
<tr class="memitem:gaf1e188eaa5ea83115d8b7137ce9252a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01301.html">bigunsignedint</a>&lt; k &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00411.html#gaf1e188eaa5ea83115d8b7137ce9252a5">operator-</a> (const <a class="el" href="a01301.html">bigunsignedint</a>&lt; k &gt; &amp;x, std::uintmax_t y)</td></tr>
<tr class="separator:gaf1e188eaa5ea83115d8b7137ce9252a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e7bfd8374b58f7895cb9f7d67fd0ead"><td class="memTemplParams" colspan="2">template&lt;int k&gt; </td></tr>
<tr class="memitem:ga6e7bfd8374b58f7895cb9f7d67fd0ead"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01301.html">bigunsignedint</a>&lt; k &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00411.html#ga6e7bfd8374b58f7895cb9f7d67fd0ead">operator*</a> (const <a class="el" href="a01301.html">bigunsignedint</a>&lt; k &gt; &amp;x, std::uintmax_t y)</td></tr>
<tr class="separator:ga6e7bfd8374b58f7895cb9f7d67fd0ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf235b6dd71516eafdd566d673d076339"><td class="memTemplParams" colspan="2">template&lt;int k&gt; </td></tr>
<tr class="memitem:gaf235b6dd71516eafdd566d673d076339"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01301.html">bigunsignedint</a>&lt; k &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00411.html#gaf235b6dd71516eafdd566d673d076339">operator/</a> (const <a class="el" href="a01301.html">bigunsignedint</a>&lt; k &gt; &amp;x, std::uintmax_t y)</td></tr>
<tr class="separator:gaf235b6dd71516eafdd566d673d076339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e48a8a50b777236555abd9ca13528c3"><td class="memTemplParams" colspan="2">template&lt;int k&gt; </td></tr>
<tr class="memitem:ga8e48a8a50b777236555abd9ca13528c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01301.html">bigunsignedint</a>&lt; k &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00411.html#ga8e48a8a50b777236555abd9ca13528c3">operator%</a> (const <a class="el" href="a01301.html">bigunsignedint</a>&lt; k &gt; &amp;x, std::uintmax_t y)</td></tr>
<tr class="separator:ga8e48a8a50b777236555abd9ca13528c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga621131a6364d2636e0c66707f8b3d8df"><td class="memTemplParams" colspan="2">template&lt;int k&gt; </td></tr>
<tr class="memitem:ga621131a6364d2636e0c66707f8b3d8df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01301.html">bigunsignedint</a>&lt; k &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00411.html#ga621131a6364d2636e0c66707f8b3d8df">operator+</a> (std::uintmax_t x, const <a class="el" href="a01301.html">bigunsignedint</a>&lt; k &gt; &amp;y)</td></tr>
<tr class="separator:ga621131a6364d2636e0c66707f8b3d8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf42863ce01d98553d1ceb962b447cec0"><td class="memTemplParams" colspan="2">template&lt;int k&gt; </td></tr>
<tr class="memitem:gaf42863ce01d98553d1ceb962b447cec0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01301.html">bigunsignedint</a>&lt; k &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00411.html#gaf42863ce01d98553d1ceb962b447cec0">operator-</a> (std::uintmax_t x, const <a class="el" href="a01301.html">bigunsignedint</a>&lt; k &gt; &amp;y)</td></tr>
<tr class="separator:gaf42863ce01d98553d1ceb962b447cec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae09acd40217cc791030af3a38f18a66a"><td class="memTemplParams" colspan="2">template&lt;int k&gt; </td></tr>
<tr class="memitem:gae09acd40217cc791030af3a38f18a66a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01301.html">bigunsignedint</a>&lt; k &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00411.html#gae09acd40217cc791030af3a38f18a66a">operator*</a> (std::uintmax_t x, const <a class="el" href="a01301.html">bigunsignedint</a>&lt; k &gt; &amp;y)</td></tr>
<tr class="separator:gae09acd40217cc791030af3a38f18a66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d5daa1e3e2d36c2b186ead3b1152d0a"><td class="memTemplParams" colspan="2">template&lt;int k&gt; </td></tr>
<tr class="memitem:ga0d5daa1e3e2d36c2b186ead3b1152d0a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01301.html">bigunsignedint</a>&lt; k &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00411.html#ga0d5daa1e3e2d36c2b186ead3b1152d0a">operator/</a> (std::uintmax_t x, const <a class="el" href="a01301.html">bigunsignedint</a>&lt; k &gt; &amp;y)</td></tr>
<tr class="separator:ga0d5daa1e3e2d36c2b186ead3b1152d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf2313e3cdc41ab5d6051818637b6e3a"><td class="memTemplParams" colspan="2">template&lt;int k&gt; </td></tr>
<tr class="memitem:gadf2313e3cdc41ab5d6051818637b6e3a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01301.html">bigunsignedint</a>&lt; k &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00411.html#gadf2313e3cdc41ab5d6051818637b6e3a">operator%</a> (std::uintmax_t x, const <a class="el" href="a01301.html">bigunsignedint</a>&lt; k &gt; &amp;y)</td></tr>
<tr class="separator:gadf2313e3cdc41ab5d6051818637b6e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ac30656648b528235c913852c28ac7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a33ac30656648b528235c913852c28ac7"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#a33ac30656648b528235c913852c28ac7">className</a> ()</td></tr>
<tr class="memdesc:a33ac30656648b528235c913852c28ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide the demangled class name of a type T as a string.  <a href="a00428.html#a33ac30656648b528235c913852c28ac7">More...</a><br /></td></tr>
<tr class="separator:a33ac30656648b528235c913852c28ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7665500285ebc74f89523cb8cf4fae"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1d7665500285ebc74f89523cb8cf4fae"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#a1d7665500285ebc74f89523cb8cf4fae">className</a> (T &amp;&amp;v)</td></tr>
<tr class="memdesc:a1d7665500285ebc74f89523cb8cf4fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide the demangled class name of a given object as a string.  <a href="a00428.html#a1d7665500285ebc74f89523cb8cf4fae">More...</a><br /></td></tr>
<tr class="separator:a1d7665500285ebc74f89523cb8cf4fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91a4108f1ea3f3644e343659a4e25904"><td class="memTemplParams" colspan="2">template&lt;class C , class... T&gt; </td></tr>
<tr class="memitem:ga91a4108f1ea3f3644e343659a4e25904"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00410.html#ga91a4108f1ea3f3644e343659a4e25904">models</a> ()</td></tr>
<tr class="memdesc:ga91a4108f1ea3f3644e343659a4e25904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if concept is modeled by given types.  <a href="a00410.html#ga91a4108f1ea3f3644e343659a4e25904">More...</a><br /></td></tr>
<tr class="separator:ga91a4108f1ea3f3644e343659a4e25904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7df1a64bf1697e91502bce842535577"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:aa7df1a64bf1697e91502bce842535577"><td class="memTemplItemLeft" align="right" valign="top">const T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#aa7df1a64bf1697e91502bce842535577">cond</a> (bool b, const T1 &amp;v1, const T2 &amp;v2)</td></tr>
<tr class="memdesc:aa7df1a64bf1697e91502bce842535577"><td class="mdescLeft">&#160;</td><td class="mdescRight">conditional evaluate  <a href="a00428.html#aa7df1a64bf1697e91502bce842535577">More...</a><br /></td></tr>
<tr class="separator:aa7df1a64bf1697e91502bce842535577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0c3f5a28263a8dd6cb81d9cfd8c929"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a9f0c3f5a28263a8dd6cb81d9cfd8c929">defaultViolatedAlignment</a> (const char *<a class="el" href="a00428.html#a33ac30656648b528235c913852c28ac7">className</a>, std::size_t expectedAlignment, const void *address)</td></tr>
<tr class="memdesc:a9f0c3f5a28263a8dd6cb81d9cfd8c929"><td class="mdescLeft">&#160;</td><td class="mdescRight">default alignment violation handler  <a href="a00428.html#a9f0c3f5a28263a8dd6cb81d9cfd8c929">More...</a><br /></td></tr>
<tr class="separator:a9f0c3f5a28263a8dd6cb81d9cfd8c929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb716c21bff1ff9559bb62074d90e86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00428.html#aeeddbd17746ee9ac74ce286741916e4c">ViolatedAlignmentHandler</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#abeb716c21bff1ff9559bb62074d90e86">violatedAlignmentHandler</a> ()</td></tr>
<tr class="memdesc:abeb716c21bff1ff9559bb62074d90e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">access the handler called by <code><a class="el" href="a00428.html#a0e6c32c539889f324d46417dca3dfebe" title="called when an alignment violation is detected">violatedAlignment()</a></code>  <a href="a00428.html#abeb716c21bff1ff9559bb62074d90e86">More...</a><br /></td></tr>
<tr class="separator:abeb716c21bff1ff9559bb62074d90e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6c32c539889f324d46417dca3dfebe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a0e6c32c539889f324d46417dca3dfebe">violatedAlignment</a> (const char *<a class="el" href="a00428.html#a33ac30656648b528235c913852c28ac7">className</a>, std::size_t expectedAlignment, const void *address)</td></tr>
<tr class="memdesc:a0e6c32c539889f324d46417dca3dfebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">called when an alignment violation is detected  <a href="a00428.html#a0e6c32c539889f324d46417dca3dfebe">More...</a><br /></td></tr>
<tr class="separator:a0e6c32c539889f324d46417dca3dfebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9e4364af213c448afdf072eea1b913"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#abf9e4364af213c448afdf072eea1b913">isAligned</a> (const void *p, std::size_t align)</td></tr>
<tr class="memdesc:abf9e4364af213c448afdf072eea1b913"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether an address conforms to the given alignment  <a href="a00428.html#abf9e4364af213c448afdf072eea1b913">More...</a><br /></td></tr>
<tr class="separator:abf9e4364af213c448afdf072eea1b913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154ffbe53dd8b81b0937ec08481e6b09"><td class="memTemplParams" colspan="2">template&lt;std::size_t align = debugAlignment, class T &gt; </td></tr>
<tr class="memitem:a154ffbe53dd8b81b0937ec08481e6b09"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01353.html">AlignedNumber</a>&lt; T, align &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#a154ffbe53dd8b81b0937ec08481e6b09">aligned</a> (T value)</td></tr>
<tr class="memdesc:a154ffbe53dd8b81b0937ec08481e6b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">align a value to a certain alignment  <a href="a00428.html#a154ffbe53dd8b81b0937ec08481e6b09">More...</a><br /></td></tr>
<tr class="separator:a154ffbe53dd8b81b0937ec08481e6b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7b894879f459e9da9bfa1d8af0663a"><td class="memTemplParams" colspan="2">template&lt;class T , std::size_t align&gt; </td></tr>
<tr class="memitem:a7e7b894879f459e9da9bfa1d8af0663a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01353.html">AlignedNumber</a>&lt; T, align &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#a7e7b894879f459e9da9bfa1d8af0663a">cond</a> (const <a class="el" href="a01353.html">AlignedNumber</a>&lt; bool, align &gt; &amp;b, const <a class="el" href="a01353.html">AlignedNumber</a>&lt; T, align &gt; &amp;v1, const <a class="el" href="a01353.html">AlignedNumber</a>&lt; T, align &gt; &amp;v2)</td></tr>
<tr class="separator:a7e7b894879f459e9da9bfa1d8af0663a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23cfd2094b38ad5889b56de92d1f019"><td class="memTemplParams" colspan="2">template&lt;class T , std::size_t align&gt; </td></tr>
<tr class="memitem:ae23cfd2094b38ad5889b56de92d1f019"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#ae23cfd2094b38ad5889b56de92d1f019">max_value</a> (const <a class="el" href="a01353.html">AlignedNumber</a>&lt; T, align &gt; &amp;val)</td></tr>
<tr class="separator:ae23cfd2094b38ad5889b56de92d1f019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97af7156507b5bbb3433e3f7e5a15a7"><td class="memTemplParams" colspan="2">template&lt;class T , std::size_t align&gt; </td></tr>
<tr class="memitem:af97af7156507b5bbb3433e3f7e5a15a7"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#af97af7156507b5bbb3433e3f7e5a15a7">min_value</a> (const <a class="el" href="a01353.html">AlignedNumber</a>&lt; T, align &gt; &amp;val)</td></tr>
<tr class="separator:af97af7156507b5bbb3433e3f7e5a15a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed24891986fbb8fea5cfee4c23a7173"><td class="memTemplParams" colspan="2">template&lt;std::size_t align&gt; </td></tr>
<tr class="memitem:a1ed24891986fbb8fea5cfee4c23a7173"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#a1ed24891986fbb8fea5cfee4c23a7173">any_true</a> (const <a class="el" href="a01353.html">AlignedNumber</a>&lt; bool, align &gt; &amp;val)</td></tr>
<tr class="separator:a1ed24891986fbb8fea5cfee4c23a7173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231fdc968bf4b24f6c52031edd1fca96"><td class="memTemplParams" colspan="2">template&lt;std::size_t align&gt; </td></tr>
<tr class="memitem:a231fdc968bf4b24f6c52031edd1fca96"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#a231fdc968bf4b24f6c52031edd1fca96">all_true</a> (const <a class="el" href="a01353.html">AlignedNumber</a>&lt; bool, align &gt; &amp;val)</td></tr>
<tr class="separator:a231fdc968bf4b24f6c52031edd1fca96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46978987490dbf404514b63b984be43d"><td class="memTemplParams" colspan="2">template&lt;typename MAT &gt; </td></tr>
<tr class="memitem:ga46978987490dbf404514b63b984be43d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00414.html#ga46978987490dbf404514b63b984be43d">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="a01393.html">DenseMatrix</a>&lt; MAT &gt; &amp;a)</td></tr>
<tr class="memdesc:ga46978987490dbf404514b63b984be43d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the matrix to an output stream.  <a href="a00414.html#ga46978987490dbf404514b63b984be43d">More...</a><br /></td></tr>
<tr class="separator:ga46978987490dbf404514b63b984be43d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06a55ef13638a2a56a42473b812498dd"><td class="memTemplParams" colspan="2">template&lt;class A , class B &gt; </td></tr>
<tr class="memitem:ga06a55ef13638a2a56a42473b812498dd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00400.html#ga06a55ef13638a2a56a42473b812498dd">dot</a> (const A &amp;a, const B &amp;b) -&gt; typename std::enable_if&lt;!<a class="el" href="a01493.html">IsVector</a>&lt; A &gt;::value &amp;&amp;!std::is_same&lt; typename <a class="el" href="a01733.html">FieldTraits</a>&lt; A &gt;::field_type, typename <a class="el" href="a01733.html">FieldTraits</a>&lt; A &gt;::real_type &gt; ::value, decltype(conj(a) *b)&gt;::type</td></tr>
<tr class="memdesc:ga06a55ef13638a2a56a42473b812498dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the dot product for fundamental data types according to Petsc's VectDot function: dot(a,b) := std::conj(a)*b  <a href="a00400.html#ga06a55ef13638a2a56a42473b812498dd">More...</a><br /></td></tr>
<tr class="separator:ga06a55ef13638a2a56a42473b812498dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d28f67ec2d74f14ec3ce3f9c27c221"><td class="memTemplParams" colspan="2">template&lt;class A , class B &gt; </td></tr>
<tr class="memitem:aa2d28f67ec2d74f14ec3ce3f9c27c221"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#aa2d28f67ec2d74f14ec3ce3f9c27c221">dotT</a> (const A &amp;a, const B &amp;b) -&gt; decltype(a *b)</td></tr>
<tr class="memdesc:aa2d28f67ec2d74f14ec3ce3f9c27c221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an indefinite vector dot product for fundamental data types according to Petsc's VectTDot function: dotT(a,b) := a*b.  <a href="a00428.html#aa2d28f67ec2d74f14ec3ce3f9c27c221">More...</a><br /></td></tr>
<tr class="separator:aa2d28f67ec2d74f14ec3ce3f9c27c221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga853a8a6088e8bc36612e0d1a14f1d0b4"><td class="memTemplParams" colspan="2">template&lt;typename TA , int i&gt; </td></tr>
<tr class="memitem:ga853a8a6088e8bc36612e0d1a14f1d0b4"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00400.html#ga853a8a6088e8bc36612e0d1a14f1d0b4">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="a01533.html">EnumItem</a>&lt; TA, i &gt; &amp;)</td></tr>
<tr class="separator:ga853a8a6088e8bc36612e0d1a14f1d0b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e9ea5bea2c22bdd2808a54ec71458a1"><td class="memTemplParams" colspan="2">template&lt;typename TA , int from, int to&gt; </td></tr>
<tr class="memitem:ga1e9ea5bea2c22bdd2808a54ec71458a1"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00400.html#ga1e9ea5bea2c22bdd2808a54ec71458a1">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="a01537.html">EnumRange</a>&lt; TA, from, to &gt; &amp;)</td></tr>
<tr class="separator:ga1e9ea5bea2c22bdd2808a54ec71458a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga698bedb0f72197e6d28d9c77068d7e05"><td class="memTemplParams" colspan="2">template&lt;class TI1 , class TI2 &gt; </td></tr>
<tr class="memitem:ga698bedb0f72197e6d28d9c77068d7e05"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01545.html">Combine</a>&lt; TI1, TI2, typename TI1::Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00400.html#ga698bedb0f72197e6d28d9c77068d7e05">combine</a> ([[maybe_unused]] const TI1 &amp;set1, [[maybe_unused]] const TI2 &amp;set2)</td></tr>
<tr class="separator:ga698bedb0f72197e6d28d9c77068d7e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63adbddbe290df558538dc462fd43711"><td class="memTemplParams" colspan="2">template&lt;class TI1 , class TI2 , class T &gt; </td></tr>
<tr class="memitem:ga63adbddbe290df558538dc462fd43711"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00400.html#ga63adbddbe290df558538dc462fd43711">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="a01545.html">Combine</a>&lt; TI1, TI2, T &gt; &amp;)</td></tr>
<tr class="separator:ga63adbddbe290df558538dc462fd43711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae09dcfbbe07912030b1413ad5ee706c6"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00415.html#gae09dcfbbe07912030b1413ad5ee706c6">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="a01549.html">Exception</a> &amp;e)</td></tr>
<tr class="separator:gae09dcfbbe07912030b1413ad5ee706c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3b0a934939d7a49b8ec4e3e28c21bc5"><td class="memTemplParams" colspan="2">template&lt;std::size_t n, class T &gt; </td></tr>
<tr class="memitem:gaf3b0a934939d7a49b8ec4e3e28c21bc5"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::array&lt; T, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00400.html#gaf3b0a934939d7a49b8ec4e3e28c21bc5">filledArray</a> (const T &amp;t)</td></tr>
<tr class="memdesc:gaf3b0a934939d7a49b8ec4e3e28c21bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an array filled with the provided value.  <a href="a00400.html#gaf3b0a934939d7a49b8ec4e3e28c21bc5">More...</a><br /></td></tr>
<tr class="separator:gaf3b0a934939d7a49b8ec4e3e28c21bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d326289f3fb37ecc5f30dd0cab45bb6"><td class="memTemplParams" colspan="2">template&lt;typename Domain , typename Range , typename F &gt; </td></tr>
<tr class="memitem:ga8d326289f3fb37ecc5f30dd0cab45bb6"><td class="memTemplItemLeft" align="right" valign="top">Impl::LambdaVirtualFunction&lt; Domain, Range, std::decay_t&lt; F &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00400.html#ga8d326289f3fb37ecc5f30dd0cab45bb6">makeVirtualFunction</a> (F &amp;&amp;f)</td></tr>
<tr class="memdesc:ga8d326289f3fb37ecc5f30dd0cab45bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">make <code><a class="el" href="a01761.html" title="Virtual base class template for function classes.">VirtualFunction</a></code> out of a function object  <a href="a00400.html#ga8d326289f3fb37ecc5f30dd0cab45bb6">More...</a><br /></td></tr>
<tr class="separator:ga8d326289f3fb37ecc5f30dd0cab45bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f0199c109bde1698fb5279a414d01a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa4f0199c109bde1698fb5279a414d01a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#aa4f0199c109bde1698fb5279a414d01a">hash_combine</a> (std::size_t &amp;seed, const T &amp;arg)</td></tr>
<tr class="memdesc:aa4f0199c109bde1698fb5279a414d01a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the hash value of arg and combines it in-place with seed.  <a href="a00428.html#aa4f0199c109bde1698fb5279a414d01a">More...</a><br /></td></tr>
<tr class="separator:aa4f0199c109bde1698fb5279a414d01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e45658b7c63f546c3c0897608d9d23d"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:a6e45658b7c63f546c3c0897608d9d23d"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#a6e45658b7c63f546c3c0897608d9d23d">hash_range</a> (It first, It last)</td></tr>
<tr class="memdesc:a6e45658b7c63f546c3c0897608d9d23d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes all elements in the range [first,last) and returns the combined hash.  <a href="a00428.html#a6e45658b7c63f546c3c0897608d9d23d">More...</a><br /></td></tr>
<tr class="separator:a6e45658b7c63f546c3c0897608d9d23d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09a051cb1381c71f6c91032cd2ba754"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:ab09a051cb1381c71f6c91032cd2ba754"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#ab09a051cb1381c71f6c91032cd2ba754">hash_range</a> (std::size_t &amp;seed, It first, It last)</td></tr>
<tr class="memdesc:ab09a051cb1381c71f6c91032cd2ba754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes all elements in the range [first,last) and combines the hashes in-place with seed.  <a href="a00428.html#ab09a051cb1381c71f6c91032cd2ba754">More...</a><br /></td></tr>
<tr class="separator:ab09a051cb1381c71f6c91032cd2ba754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac282bd5d47ea4d2daf9523fb5de848a9"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00400.html#gac282bd5d47ea4d2daf9523fb5de848a9">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="a01861.html">Indent</a> &amp;indent)</td></tr>
<tr class="memdesc:gac282bd5d47ea4d2daf9523fb5de848a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">write indentation to a stream  <a href="a00400.html#gac282bd5d47ea4d2daf9523fb5de848a9">More...</a><br /></td></tr>
<tr class="separator:gac282bd5d47ea4d2daf9523fb5de848a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0959a949c8385a1b41669380e439d5d8"><td class="memTemplParams" colspan="2">template&lt;class F , class I , I... i&gt; </td></tr>
<tr class="memitem:ga0959a949c8385a1b41669380e439d5d8"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00400.html#ga0959a949c8385a1b41669380e439d5d8">unpackIntegerSequence</a> (F &amp;&amp;f, std::integer_sequence&lt; I, i... &gt; sequence)</td></tr>
<tr class="memdesc:ga0959a949c8385a1b41669380e439d5d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack an std::integer_sequence&lt;I,i...&gt; to std::integral_constant&lt;I,i&gt;...  <a href="a00400.html#ga0959a949c8385a1b41669380e439d5d8">More...</a><br /></td></tr>
<tr class="separator:ga0959a949c8385a1b41669380e439d5d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad89f7fc265d9bd63c5b5a8da6748d8af"><td class="memTemplParams" colspan="2">template&lt;class T1 , class V1 , class R1 , class D , class T2 , class V2 , class R2 &gt; </td></tr>
<tr class="memitem:gad89f7fc265d9bd63c5b5a8da6748d8af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a03065.html">EnableIfInterOperable</a>&lt; T1, T2, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00417.html#gad89f7fc265d9bd63c5b5a8da6748d8af">operator==</a> (const <a class="el" href="a01873.html">ForwardIteratorFacade</a>&lt; T1, V1, R1, D &gt; &amp;lhs, const <a class="el" href="a01873.html">ForwardIteratorFacade</a>&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gad89f7fc265d9bd63c5b5a8da6748d8af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for equality.  <a href="a00417.html#gad89f7fc265d9bd63c5b5a8da6748d8af">More...</a><br /></td></tr>
<tr class="separator:gad89f7fc265d9bd63c5b5a8da6748d8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1369bc3ae1876892c6567eff7987620f"><td class="memTemplParams" colspan="2">template&lt;class T1 , class V1 , class R1 , class D , class T2 , class V2 , class R2 &gt; </td></tr>
<tr class="memitem:ga1369bc3ae1876892c6567eff7987620f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a03065.html">EnableIfInterOperable</a>&lt; T1, T2, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00417.html#ga1369bc3ae1876892c6567eff7987620f">operator!=</a> (const <a class="el" href="a01873.html">ForwardIteratorFacade</a>&lt; T1, V1, R1, D &gt; &amp;lhs, const <a class="el" href="a01873.html">ForwardIteratorFacade</a>&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga1369bc3ae1876892c6567eff7987620f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for inequality.  <a href="a00417.html#ga1369bc3ae1876892c6567eff7987620f">More...</a><br /></td></tr>
<tr class="separator:ga1369bc3ae1876892c6567eff7987620f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a147b2ec114b90e57366216029b40bc"><td class="memTemplParams" colspan="2">template&lt;class T1 , class V1 , class R1 , class D , class T2 , class V2 , class R2 &gt; </td></tr>
<tr class="memitem:ga0a147b2ec114b90e57366216029b40bc"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_convertible&lt; T2, T1 &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00417.html#ga0a147b2ec114b90e57366216029b40bc">operator==</a> (const <a class="el" href="a01877.html">BidirectionalIteratorFacade</a>&lt; T1, V1, R1, D &gt; &amp;lhs, const <a class="el" href="a01877.html">BidirectionalIteratorFacade</a>&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga0a147b2ec114b90e57366216029b40bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for equality.  <a href="a00417.html#ga0a147b2ec114b90e57366216029b40bc">More...</a><br /></td></tr>
<tr class="separator:ga0a147b2ec114b90e57366216029b40bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a147b2ec114b90e57366216029b40bc"><td class="memTemplParams" colspan="2">template&lt;class T1 , class V1 , class R1 , class D , class T2 , class V2 , class R2 &gt; </td></tr>
<tr class="memitem:ga0a147b2ec114b90e57366216029b40bc"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_convertible&lt; T1, T2 &gt;::value &amp;&amp;!std::is_convertible&lt; T2, T1 &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#ga0a147b2ec114b90e57366216029b40bc">operator==</a> (const <a class="el" href="a01877.html">BidirectionalIteratorFacade</a>&lt; T1, V1, R1, D &gt; &amp;lhs, const <a class="el" href="a01877.html">BidirectionalIteratorFacade</a>&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga0a147b2ec114b90e57366216029b40bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for equality.  <a href="a00428.html#ga0a147b2ec114b90e57366216029b40bc">More...</a><br /></td></tr>
<tr class="separator:ga0a147b2ec114b90e57366216029b40bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace8cd0fee28b999a64ce7a75ca582cae"><td class="memTemplParams" colspan="2">template&lt;class T1 , class V1 , class R1 , class D , class T2 , class V2 , class R2 &gt; </td></tr>
<tr class="memitem:gace8cd0fee28b999a64ce7a75ca582cae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a03065.html">EnableIfInterOperable</a>&lt; T1, T2, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00417.html#gace8cd0fee28b999a64ce7a75ca582cae">operator!=</a> (const <a class="el" href="a01877.html">BidirectionalIteratorFacade</a>&lt; T1, V1, R1, D &gt; &amp;lhs, const <a class="el" href="a01877.html">BidirectionalIteratorFacade</a>&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gace8cd0fee28b999a64ce7a75ca582cae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for inequality.  <a href="a00417.html#gace8cd0fee28b999a64ce7a75ca582cae">More...</a><br /></td></tr>
<tr class="separator:gace8cd0fee28b999a64ce7a75ca582cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga639a6e346454c1d6635f21ea15af4032"><td class="memTemplParams" colspan="2">template&lt;class T1 , class V1 , class R1 , class D , class T2 , class V2 , class R2 &gt; </td></tr>
<tr class="memitem:ga639a6e346454c1d6635f21ea15af4032"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a03065.html">EnableIfInterOperable</a>&lt; T1, T2, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00417.html#ga639a6e346454c1d6635f21ea15af4032">operator==</a> (const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T1, V1, R1, D &gt; &amp;lhs, const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga639a6e346454c1d6635f21ea15af4032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for equality.  <a href="a00417.html#ga639a6e346454c1d6635f21ea15af4032">More...</a><br /></td></tr>
<tr class="separator:ga639a6e346454c1d6635f21ea15af4032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78d64b70022a4945cb797908fb3f6d65"><td class="memTemplParams" colspan="2">template&lt;class T1 , class V1 , class R1 , class D , class T2 , class V2 , class R2 &gt; </td></tr>
<tr class="memitem:ga78d64b70022a4945cb797908fb3f6d65"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a03065.html">EnableIfInterOperable</a>&lt; T1, T2, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00417.html#ga78d64b70022a4945cb797908fb3f6d65">operator!=</a> (const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T1, V1, R1, D &gt; &amp;lhs, const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga78d64b70022a4945cb797908fb3f6d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for inequality.  <a href="a00417.html#ga78d64b70022a4945cb797908fb3f6d65">More...</a><br /></td></tr>
<tr class="separator:ga78d64b70022a4945cb797908fb3f6d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5760aff14000ebe9042e042b31db949"><td class="memTemplParams" colspan="2">template&lt;class T1 , class V1 , class R1 , class D , class T2 , class V2 , class R2 &gt; </td></tr>
<tr class="memitem:gaa5760aff14000ebe9042e042b31db949"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a03065.html">EnableIfInterOperable</a>&lt; T1, T2, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00417.html#gaa5760aff14000ebe9042e042b31db949">operator&lt;</a> (const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T1, V1, R1, D &gt; &amp;lhs, const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa5760aff14000ebe9042e042b31db949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="a00417.html#gaa5760aff14000ebe9042e042b31db949">More...</a><br /></td></tr>
<tr class="separator:gaa5760aff14000ebe9042e042b31db949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf0c29cb2d498e30122d48b15db41f7f"><td class="memTemplParams" colspan="2">template&lt;class T1 , class V1 , class R1 , class D , class T2 , class V2 , class R2 &gt; </td></tr>
<tr class="memitem:gadf0c29cb2d498e30122d48b15db41f7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a03065.html">EnableIfInterOperable</a>&lt; T1, T2, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00417.html#gadf0c29cb2d498e30122d48b15db41f7f">operator&lt;=</a> (const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T1, V1, R1, D &gt; &amp;lhs, const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gadf0c29cb2d498e30122d48b15db41f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="a00417.html#gadf0c29cb2d498e30122d48b15db41f7f">More...</a><br /></td></tr>
<tr class="separator:gadf0c29cb2d498e30122d48b15db41f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cd2214e489cbe140c0394a24f7d77fa"><td class="memTemplParams" colspan="2">template&lt;class T1 , class V1 , class R1 , class D , class T2 , class V2 , class R2 &gt; </td></tr>
<tr class="memitem:ga4cd2214e489cbe140c0394a24f7d77fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a03065.html">EnableIfInterOperable</a>&lt; T1, T2, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00417.html#ga4cd2214e489cbe140c0394a24f7d77fa">operator&gt;</a> (const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T1, V1, R1, D &gt; &amp;lhs, const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga4cd2214e489cbe140c0394a24f7d77fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="a00417.html#ga4cd2214e489cbe140c0394a24f7d77fa">More...</a><br /></td></tr>
<tr class="separator:ga4cd2214e489cbe140c0394a24f7d77fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd0f438316b237180be4c98e915da261"><td class="memTemplParams" colspan="2">template&lt;class T1 , class V1 , class R1 , class D , class T2 , class V2 , class R2 &gt; </td></tr>
<tr class="memitem:gadd0f438316b237180be4c98e915da261"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a03065.html">EnableIfInterOperable</a>&lt; T1, T2, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00417.html#gadd0f438316b237180be4c98e915da261">operator&gt;=</a> (const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T1, V1, R1, D &gt; &amp;lhs, const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gadd0f438316b237180be4c98e915da261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator.  <a href="a00417.html#gadd0f438316b237180be4c98e915da261">More...</a><br /></td></tr>
<tr class="separator:gadd0f438316b237180be4c98e915da261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga567e9701961fedd3a613c9f6d3b68b5d"><td class="memTemplParams" colspan="2">template&lt;class T1 , class V1 , class R1 , class D , class T2 , class V2 , class R2 &gt; </td></tr>
<tr class="memitem:ga567e9701961fedd3a613c9f6d3b68b5d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a03065.html">EnableIfInterOperable</a>&lt; T1, T2, D &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00417.html#ga567e9701961fedd3a613c9f6d3b68b5d">operator-</a> (const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T1, V1, R1, D &gt; &amp;lhs, const <a class="el" href="a01881.html">RandomAccessIteratorFacade</a>&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga567e9701961fedd3a613c9f6d3b68b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the difference between two pointers.  <a href="a00417.html#ga567e9701961fedd3a613c9f6d3b68b5d">More...</a><br /></td></tr>
<tr class="separator:ga567e9701961fedd3a613c9f6d3b68b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b225faa806a6ba0744fd93ce17b447a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0b225faa806a6ba0744fd93ce17b447a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#a0b225faa806a6ba0744fd93ce17b447a">operator==</a> (const <a class="el" href="a01901.html">MallocAllocator</a>&lt; T &gt; &amp;, const <a class="el" href="a01901.html">MallocAllocator</a>&lt; T &gt; &amp;)</td></tr>
<tr class="memdesc:a0b225faa806a6ba0744fd93ce17b447a"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether allocators are equivalent  <a href="a00428.html#a0b225faa806a6ba0744fd93ce17b447a">More...</a><br /></td></tr>
<tr class="separator:a0b225faa806a6ba0744fd93ce17b447a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336418ea10c30e25ece655d63bdf3d84"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a336418ea10c30e25ece655d63bdf3d84"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#a336418ea10c30e25ece655d63bdf3d84">operator!=</a> (const <a class="el" href="a01901.html">MallocAllocator</a>&lt; T &gt; &amp;, const <a class="el" href="a01901.html">MallocAllocator</a>&lt; T &gt; &amp;)</td></tr>
<tr class="memdesc:a336418ea10c30e25ece655d63bdf3d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether allocators are not equivalent  <a href="a00428.html#a336418ea10c30e25ece655d63bdf3d84">More...</a><br /></td></tr>
<tr class="separator:a336418ea10c30e25ece655d63bdf3d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43fb9e50cbb18051ddf5497465ccf734"><td class="memTemplParams" colspan="2">template&lt;class Mantissa , class Exponent &gt; </td></tr>
<tr class="memitem:a43fb9e50cbb18051ddf5497465ccf734"><td class="memTemplItemLeft" align="right" valign="top">constexpr Mantissa&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#a43fb9e50cbb18051ddf5497465ccf734">power</a> (Mantissa m, Exponent p)</td></tr>
<tr class="memdesc:a43fb9e50cbb18051ddf5497465ccf734"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a02397.html" title="Compute power for a run-time mantissa and a compile-time integer exponent.">Power</a> method for integer exponents.  <a href="a00428.html#a43fb9e50cbb18051ddf5497465ccf734">More...</a><br /></td></tr>
<tr class="separator:a43fb9e50cbb18051ddf5497465ccf734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4eb5cbca2609d132ac6866b4960247b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa4eb5cbca2609d132ac6866b4960247b"><td class="memTemplItemLeft" align="right" valign="top">constexpr static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#aa4eb5cbca2609d132ac6866b4960247b">factorial</a> (const T &amp;n) noexcept</td></tr>
<tr class="memdesc:aa4eb5cbca2609d132ac6866b4960247b"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the factorial of n as a constexpr  <a href="a00428.html#aa4eb5cbca2609d132ac6866b4960247b">More...</a><br /></td></tr>
<tr class="separator:aa4eb5cbca2609d132ac6866b4960247b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4be70f69e2f8bbda33075a643a23d6e"><td class="memTemplParams" colspan="2">template&lt;class T , T n&gt; </td></tr>
<tr class="memitem:ad4be70f69e2f8bbda33075a643a23d6e"><td class="memTemplItemLeft" align="right" valign="top">constexpr static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#ad4be70f69e2f8bbda33075a643a23d6e">factorial</a> (std::integral_constant&lt; T, n &gt;) noexcept</td></tr>
<tr class="memdesc:ad4be70f69e2f8bbda33075a643a23d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the factorial of n as a constexpr  <a href="a00428.html#ad4be70f69e2f8bbda33075a643a23d6e">More...</a><br /></td></tr>
<tr class="separator:ad4be70f69e2f8bbda33075a643a23d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae548cdfab3c07fd32610c7b4da8f0eb9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae548cdfab3c07fd32610c7b4da8f0eb9"><td class="memTemplItemLeft" align="right" valign="top">constexpr static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#ae548cdfab3c07fd32610c7b4da8f0eb9">binomial</a> (const T &amp;n, const T &amp;k) noexcept</td></tr>
<tr class="memdesc:ae548cdfab3c07fd32610c7b4da8f0eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the binomial coefficient n over k as a constexpr  <a href="a00428.html#ae548cdfab3c07fd32610c7b4da8f0eb9">More...</a><br /></td></tr>
<tr class="separator:ae548cdfab3c07fd32610c7b4da8f0eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03852ec1241ecb93d746dc64bc0e41cc"><td class="memTemplParams" colspan="2">template&lt;class T , T n, T k&gt; </td></tr>
<tr class="memitem:a03852ec1241ecb93d746dc64bc0e41cc"><td class="memTemplItemLeft" align="right" valign="top">constexpr static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#a03852ec1241ecb93d746dc64bc0e41cc">binomial</a> (std::integral_constant&lt; T, n &gt;, std::integral_constant&lt; T, k &gt;) noexcept</td></tr>
<tr class="memdesc:a03852ec1241ecb93d746dc64bc0e41cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the binomial coefficient n over k as a constexpr  <a href="a00428.html#a03852ec1241ecb93d746dc64bc0e41cc">More...</a><br /></td></tr>
<tr class="separator:a03852ec1241ecb93d746dc64bc0e41cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1169603932af226513ef054667a1657d"><td class="memTemplParams" colspan="2">template&lt;class T , T n&gt; </td></tr>
<tr class="memitem:a1169603932af226513ef054667a1657d"><td class="memTemplItemLeft" align="right" valign="top">constexpr static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#a1169603932af226513ef054667a1657d">binomial</a> (std::integral_constant&lt; T, n &gt;, std::integral_constant&lt; T, n &gt;) noexcept</td></tr>
<tr class="separator:a1169603932af226513ef054667a1657d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ef69fa70938d4aa93d8e30d3813c13"><td class="memTemplParams" colspan="2">template&lt;class K &gt; </td></tr>
<tr class="memitem:ae6ef69fa70938d4aa93d8e30d3813c13"><td class="memTemplItemLeft" align="right" valign="top">K&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#ae6ef69fa70938d4aa93d8e30d3813c13">conjugateComplex</a> (const K &amp;x)</td></tr>
<tr class="memdesc:ae6ef69fa70938d4aa93d8e30d3813c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute conjugate complex of x  <a href="a00428.html#ae6ef69fa70938d4aa93d8e30d3813c13">More...</a><br /></td></tr>
<tr class="separator:ae6ef69fa70938d4aa93d8e30d3813c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1712a3bb38c829a2c339355cdb28133"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac1712a3bb38c829a2c339355cdb28133"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#ac1712a3bb38c829a2c339355cdb28133">sign</a> (const T &amp;val)</td></tr>
<tr class="memdesc:ac1712a3bb38c829a2c339355cdb28133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sign of the value.  <a href="a00428.html#ac1712a3bb38c829a2c339355cdb28133">More...</a><br /></td></tr>
<tr class="separator:ac1712a3bb38c829a2c339355cdb28133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae007ebc02578de3fe994b28e4378fd80"><td class="memTemplParams" colspan="2">template&lt;class... F&gt; </td></tr>
<tr class="memitem:gae007ebc02578de3fe994b28e4378fd80"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00409.html#gae007ebc02578de3fe994b28e4378fd80">overload</a> (F &amp;&amp;... f)</td></tr>
<tr class="memdesc:gae007ebc02578de3fe994b28e4378fd80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an overload set.  <a href="a00409.html#gae007ebc02578de3fe994b28e4378fd80">More...</a><br /></td></tr>
<tr class="separator:gae007ebc02578de3fe994b28e4378fd80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85390a9ae268b1ed2be79b8637e8becd"><td class="memTemplParams" colspan="2">template&lt;class... F&gt; </td></tr>
<tr class="memitem:ga85390a9ae268b1ed2be79b8637e8becd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00409.html#ga85390a9ae268b1ed2be79b8637e8becd">orderedOverload</a> (F &amp;&amp;... f)</td></tr>
<tr class="memdesc:ga85390a9ae268b1ed2be79b8637e8becd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an ordered overload set.  <a href="a00409.html#ga85390a9ae268b1ed2be79b8637e8becd">More...</a><br /></td></tr>
<tr class="separator:ga85390a9ae268b1ed2be79b8637e8becd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0776cda12fa2fc183e2796bcc23743"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#aee0776cda12fa2fc183e2796bcc23743">operator==</a> (const <a class="el" href="a01957.html">No_Comm</a> &amp;, const <a class="el" href="a01957.html">No_Comm</a> &amp;)</td></tr>
<tr class="memdesc:aee0776cda12fa2fc183e2796bcc23743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator for MPI compatibility.  <a href="a00428.html#aee0776cda12fa2fc183e2796bcc23743">More...</a><br /></td></tr>
<tr class="separator:aee0776cda12fa2fc183e2796bcc23743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c039e6b551a3771cc8c60e84e9bcdc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a02c039e6b551a3771cc8c60e84e9bcdc">operator!=</a> (const <a class="el" href="a01957.html">No_Comm</a> &amp;, const <a class="el" href="a01957.html">No_Comm</a> &amp;)</td></tr>
<tr class="memdesc:a02c039e6b551a3771cc8c60e84e9bcdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator for MPI compatibility.  <a href="a00428.html#a02c039e6b551a3771cc8c60e84e9bcdc">More...</a><br /></td></tr>
<tr class="separator:a02c039e6b551a3771cc8c60e84e9bcdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fcd5b444a9e60cfdc21f7d0cfd22250"><td class="memTemplParams" colspan="2">template&lt;class TG , class TL &gt; </td></tr>
<tr class="memitem:ga7fcd5b444a9e60cfdc21f7d0cfd22250"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#ga7fcd5b444a9e60cfdc21f7d0cfd22250">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="a02065.html">IndexPair</a>&lt; TG, TL &gt; &amp;pair)</td></tr>
<tr class="memdesc:ga7fcd5b444a9e60cfdc21f7d0cfd22250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an index pair.  <a href="a00419.html#ga7fcd5b444a9e60cfdc21f7d0cfd22250">More...</a><br /></td></tr>
<tr class="separator:ga7fcd5b444a9e60cfdc21f7d0cfd22250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7795b290702a59497007270c46e2b8c6"><td class="memTemplParams" colspan="2">template&lt;class TG , class TL &gt; </td></tr>
<tr class="memitem:ga7795b290702a59497007270c46e2b8c6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#ga7795b290702a59497007270c46e2b8c6">operator==</a> (const <a class="el" href="a02065.html">IndexPair</a>&lt; TG, TL &gt; &amp;, const <a class="el" href="a02065.html">IndexPair</a>&lt; TG, TL &gt; &amp;)</td></tr>
<tr class="separator:ga7795b290702a59497007270c46e2b8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a50aa86c8ff96eee7ef68200531326d"><td class="memTemplParams" colspan="2">template&lt;class TG , class TL &gt; </td></tr>
<tr class="memitem:ga3a50aa86c8ff96eee7ef68200531326d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#ga3a50aa86c8ff96eee7ef68200531326d">operator!=</a> (const <a class="el" href="a02065.html">IndexPair</a>&lt; TG, TL &gt; &amp;, const <a class="el" href="a02065.html">IndexPair</a>&lt; TG, TL &gt; &amp;)</td></tr>
<tr class="separator:ga3a50aa86c8ff96eee7ef68200531326d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d9a1c3873a538aa66c22b03b406db87"><td class="memTemplParams" colspan="2">template&lt;class TG , class TL &gt; </td></tr>
<tr class="memitem:ga0d9a1c3873a538aa66c22b03b406db87"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#ga0d9a1c3873a538aa66c22b03b406db87">operator&lt;</a> (const <a class="el" href="a02065.html">IndexPair</a>&lt; TG, TL &gt; &amp;, const <a class="el" href="a02065.html">IndexPair</a>&lt; TG, TL &gt; &amp;)</td></tr>
<tr class="separator:ga0d9a1c3873a538aa66c22b03b406db87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bc63043e58d66643b64cbd6b08dfb82"><td class="memTemplParams" colspan="2">template&lt;class TG , class TL &gt; </td></tr>
<tr class="memitem:ga0bc63043e58d66643b64cbd6b08dfb82"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#ga0bc63043e58d66643b64cbd6b08dfb82">operator&gt;</a> (const <a class="el" href="a02065.html">IndexPair</a>&lt; TG, TL &gt; &amp;, const <a class="el" href="a02065.html">IndexPair</a>&lt; TG, TL &gt; &amp;)</td></tr>
<tr class="separator:ga0bc63043e58d66643b64cbd6b08dfb82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cdf9614911aa5cd70ed58663de013c2"><td class="memTemplParams" colspan="2">template&lt;class TG , class TL &gt; </td></tr>
<tr class="memitem:ga6cdf9614911aa5cd70ed58663de013c2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#ga6cdf9614911aa5cd70ed58663de013c2">operator&lt;=</a> (const <a class="el" href="a02065.html">IndexPair</a>&lt; TG, TL &gt; &amp;, const <a class="el" href="a02065.html">IndexPair</a>&lt; TG, TL &gt; &amp;)</td></tr>
<tr class="separator:ga6cdf9614911aa5cd70ed58663de013c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c5245f4fd0352faad94ca8e9c1f6c6f"><td class="memTemplParams" colspan="2">template&lt;class TG , class TL &gt; </td></tr>
<tr class="memitem:ga5c5245f4fd0352faad94ca8e9c1f6c6f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#ga5c5245f4fd0352faad94ca8e9c1f6c6f">operator&gt;=</a> (const <a class="el" href="a02065.html">IndexPair</a>&lt; TG, TL &gt; &amp;, const <a class="el" href="a02065.html">IndexPair</a>&lt; TG, TL &gt; &amp;)</td></tr>
<tr class="separator:ga5c5245f4fd0352faad94ca8e9c1f6c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga239e646b27f7f35ac944aebb59380913"><td class="memTemplParams" colspan="2">template&lt;class TG , class TL &gt; </td></tr>
<tr class="memitem:ga239e646b27f7f35ac944aebb59380913"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#ga239e646b27f7f35ac944aebb59380913">operator==</a> (const <a class="el" href="a02065.html">IndexPair</a>&lt; TG, TL &gt; &amp;, const TG &amp;)</td></tr>
<tr class="separator:ga239e646b27f7f35ac944aebb59380913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf0b39a244a69d9e7f71811f960a5728"><td class="memTemplParams" colspan="2">template&lt;class TG , class TL &gt; </td></tr>
<tr class="memitem:gadf0b39a244a69d9e7f71811f960a5728"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#gadf0b39a244a69d9e7f71811f960a5728">operator!=</a> (const <a class="el" href="a02065.html">IndexPair</a>&lt; TG, TL &gt; &amp;, const TG &amp;)</td></tr>
<tr class="separator:gadf0b39a244a69d9e7f71811f960a5728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga912a9eba5f4d34e7e50ef4335b7ba108"><td class="memTemplParams" colspan="2">template&lt;class TG , class TL &gt; </td></tr>
<tr class="memitem:ga912a9eba5f4d34e7e50ef4335b7ba108"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#ga912a9eba5f4d34e7e50ef4335b7ba108">operator&lt;</a> (const <a class="el" href="a02065.html">IndexPair</a>&lt; TG, TL &gt; &amp;, const TG &amp;)</td></tr>
<tr class="separator:ga912a9eba5f4d34e7e50ef4335b7ba108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4b337bd4e613e88381306db889e811f"><td class="memTemplParams" colspan="2">template&lt;class TG , class TL &gt; </td></tr>
<tr class="memitem:gab4b337bd4e613e88381306db889e811f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#gab4b337bd4e613e88381306db889e811f">operator&gt;</a> (const <a class="el" href="a02065.html">IndexPair</a>&lt; TG, TL &gt; &amp;, const TG &amp;)</td></tr>
<tr class="separator:gab4b337bd4e613e88381306db889e811f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6d5923b72e3214d9f20349b722ea874"><td class="memTemplParams" colspan="2">template&lt;class TG , class TL &gt; </td></tr>
<tr class="memitem:gad6d5923b72e3214d9f20349b722ea874"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#gad6d5923b72e3214d9f20349b722ea874">operator&lt;=</a> (const <a class="el" href="a02065.html">IndexPair</a>&lt; TG, TL &gt; &amp;, const TG &amp;)</td></tr>
<tr class="separator:gad6d5923b72e3214d9f20349b722ea874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d670d228f6635f587d21ef117951fd9"><td class="memTemplParams" colspan="2">template&lt;class TG , class TL &gt; </td></tr>
<tr class="memitem:ga7d670d228f6635f587d21ef117951fd9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#ga7d670d228f6635f587d21ef117951fd9">operator&gt;=</a> (const <a class="el" href="a02065.html">IndexPair</a>&lt; TG, TL &gt; &amp;, const TG &amp;)</td></tr>
<tr class="separator:ga7d670d228f6635f587d21ef117951fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac377e14b5944471054bdb0012008393b"><td class="memTemplParams" colspan="2">template&lt;class TG , class TL , int N&gt; </td></tr>
<tr class="memitem:gac377e14b5944471054bdb0012008393b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#gac377e14b5944471054bdb0012008393b">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="a02077.html">ParallelIndexSet</a>&lt; TG, TL, N &gt; &amp;indexSet)</td></tr>
<tr class="memdesc:gac377e14b5944471054bdb0012008393b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an index set.  <a href="a00419.html#gac377e14b5944471054bdb0012008393b">More...</a><br /></td></tr>
<tr class="separator:gac377e14b5944471054bdb0012008393b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf61fa30bf15e87a0f910b9068f775067"><td class="memTemplParams" colspan="2">template&lt;typename TG , typename TA &gt; </td></tr>
<tr class="memitem:gaf61fa30bf15e87a0f910b9068f775067"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#gaf61fa30bf15e87a0f910b9068f775067">operator&lt;</a> (const <a class="el" href="a02065.html">IndexPair</a>&lt; TG, <a class="el" href="a02193.html">ParallelLocalIndex</a>&lt; TA &gt; &gt; &amp;i1, const std::pair&lt; TG, TA &gt; &amp;i2)</td></tr>
<tr class="separator:gaf61fa30bf15e87a0f910b9068f775067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5b7bd4e69ee01360e666f12913c1459"><td class="memTemplParams" colspan="2">template&lt;typename TG , typename TA &gt; </td></tr>
<tr class="memitem:gae5b7bd4e69ee01360e666f12913c1459"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#gae5b7bd4e69ee01360e666f12913c1459">operator&lt;</a> (const std::pair&lt; TG, TA &gt; &amp;i1, const <a class="el" href="a02065.html">IndexPair</a>&lt; TG, <a class="el" href="a02193.html">ParallelLocalIndex</a>&lt; TA &gt; &gt; &amp;i2)</td></tr>
<tr class="separator:gae5b7bd4e69ee01360e666f12913c1459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga058ac87cbdd5c6c4bf3166e8f55efa30"><td class="memTemplParams" colspan="2">template&lt;typename TG , typename TA &gt; </td></tr>
<tr class="memitem:ga058ac87cbdd5c6c4bf3166e8f55efa30"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#ga058ac87cbdd5c6c4bf3166e8f55efa30">operator==</a> (const <a class="el" href="a02065.html">IndexPair</a>&lt; TG, <a class="el" href="a02193.html">ParallelLocalIndex</a>&lt; TA &gt; &gt; &amp;i1, const std::pair&lt; TG, TA &gt; &amp;i2)</td></tr>
<tr class="separator:ga058ac87cbdd5c6c4bf3166e8f55efa30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94296b1fafb04cd392611a43968df582"><td class="memTemplParams" colspan="2">template&lt;typename TG , typename TA &gt; </td></tr>
<tr class="memitem:ga94296b1fafb04cd392611a43968df582"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#ga94296b1fafb04cd392611a43968df582">operator!=</a> (const <a class="el" href="a02065.html">IndexPair</a>&lt; TG, <a class="el" href="a02193.html">ParallelLocalIndex</a>&lt; TA &gt; &gt; &amp;i1, const std::pair&lt; TG, TA &gt; &amp;i2)</td></tr>
<tr class="separator:ga94296b1fafb04cd392611a43968df582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300a4a465d5bb251de3953c682d314cb"><td class="memTemplParams" colspan="2">template&lt;typename TG , typename TA &gt; </td></tr>
<tr class="memitem:ga300a4a465d5bb251de3953c682d314cb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#ga300a4a465d5bb251de3953c682d314cb">operator==</a> (const std::pair&lt; TG, TA &gt; &amp;i2, const <a class="el" href="a02065.html">IndexPair</a>&lt; TG, <a class="el" href="a02193.html">ParallelLocalIndex</a>&lt; TA &gt; &gt; &amp;i1)</td></tr>
<tr class="separator:ga300a4a465d5bb251de3953c682d314cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga114537d071365593e8ec0ac11de6ac31"><td class="memTemplParams" colspan="2">template&lt;typename TG , typename TA &gt; </td></tr>
<tr class="memitem:ga114537d071365593e8ec0ac11de6ac31"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#ga114537d071365593e8ec0ac11de6ac31">operator!=</a> (const std::pair&lt; TG, TA &gt; &amp;i2, const <a class="el" href="a02065.html">IndexPair</a>&lt; TG, <a class="el" href="a02193.html">ParallelLocalIndex</a>&lt; TA &gt; &gt; &amp;i1)</td></tr>
<tr class="separator:ga114537d071365593e8ec0ac11de6ac31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac603bb313a217401041e4afc6fe4fa3a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A , typename A1 &gt; </td></tr>
<tr class="memitem:gac603bb313a217401041e4afc6fe4fa3a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#gac603bb313a217401041e4afc6fe4fa3a">storeGlobalIndicesOfRemoteIndices</a> (std::map&lt; int, <a class="el" href="a02829.html">SLList</a>&lt; std::pair&lt; typename T::GlobalIndex, typename T::LocalIndex::Attribute &gt;, A &gt; &gt; &amp;globalMap, const <a class="el" href="a02209.html">RemoteIndices</a>&lt; T, A1 &gt; &amp;remoteIndices)</td></tr>
<tr class="memdesc:gac603bb313a217401041e4afc6fe4fa3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the corresponding global indices of the remote index information.  <a href="a00419.html#gac603bb313a217401041e4afc6fe4fa3a">More...</a><br /></td></tr>
<tr class="separator:gac603bb313a217401041e4afc6fe4fa3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33d784101a8baf32ce462c484a90674c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A , typename A1 &gt; </td></tr>
<tr class="memitem:ga33d784101a8baf32ce462c484a90674c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#ga33d784101a8baf32ce462c484a90674c">repairLocalIndexPointers</a> (std::map&lt; int, <a class="el" href="a02829.html">SLList</a>&lt; std::pair&lt; typename T::GlobalIndex, typename T::LocalIndex::Attribute &gt;, A &gt; &gt; &amp;globalMap, <a class="el" href="a02209.html">RemoteIndices</a>&lt; T, A1 &gt; &amp;remoteIndices, const T &amp;indexSet)</td></tr>
<tr class="memdesc:ga33d784101a8baf32ce462c484a90674c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repair the pointers to the local indices in the remote indices.  <a href="a00419.html#ga33d784101a8baf32ce462c484a90674c">More...</a><br /></td></tr>
<tr class="separator:ga33d784101a8baf32ce462c484a90674c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1640f7fd69aac13c49a1750bdfa8ac5"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#ae1640f7fd69aac13c49a1750bdfa8ac5">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="a02121.html">Interface</a> &amp;interface)</td></tr>
<tr class="separator:ae1640f7fd69aac13c49a1750bdfa8ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a2fa61f1387001cea29f6934ff2316"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a59a2fa61f1387001cea29f6934ff2316">ComposeMPIOp</a> (std::plus, MPI_SUM)</td></tr>
<tr class="separator:a59a2fa61f1387001cea29f6934ff2316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1b0f5e50429120ba7fc972b022c620"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a8b1b0f5e50429120ba7fc972b022c620">ComposeMPIOp</a> (std::multiplies, MPI_PROD)</td></tr>
<tr class="separator:a8b1b0f5e50429120ba7fc972b022c620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428c0ab2a3d2fd8f57aaf06a51bcc558"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a428c0ab2a3d2fd8f57aaf06a51bcc558">ComposeMPIOp</a> (<a class="el" href="a01309.html">Min</a>, MPI_MIN)</td></tr>
<tr class="separator:a428c0ab2a3d2fd8f57aaf06a51bcc558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6814315ac90b4c03e394688a30c63d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#ac6814315ac90b4c03e394688a30c63d9">ComposeMPIOp</a> (<a class="el" href="a01313.html">Max</a>, MPI_MAX)</td></tr>
<tr class="separator:ac6814315ac90b4c03e394688a30c63d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e5c2863bb763524cbc65eaea515adb"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a60e5c2863bb763524cbc65eaea515adb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#a60e5c2863bb763524cbc65eaea515adb">getMPIData</a> (T &amp;t)</td></tr>
<tr class="separator:a60e5c2863bb763524cbc65eaea515adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f6a56e79b01b4bd4385c81502559be3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga6f6a56e79b01b4bd4385c81502559be3"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#ga6f6a56e79b01b4bd4385c81502559be3">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="a02193.html">ParallelLocalIndex</a>&lt; T &gt; &amp;index)</td></tr>
<tr class="memdesc:ga6f6a56e79b01b4bd4385c81502559be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the local index to a stream.  <a href="a00419.html#ga6f6a56e79b01b4bd4385c81502559be3">More...</a><br /></td></tr>
<tr class="separator:ga6f6a56e79b01b4bd4385c81502559be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f656ae09bca24998c26b42304a9d1b2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3f656ae09bca24998c26b42304a9d1b2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#ga3f656ae09bca24998c26b42304a9d1b2">operator==</a> (const <a class="el" href="a02193.html">ParallelLocalIndex</a>&lt; T &gt; &amp;p1, const <a class="el" href="a02193.html">ParallelLocalIndex</a>&lt; T &gt; &amp;p2)</td></tr>
<tr class="separator:ga3f656ae09bca24998c26b42304a9d1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga773d38fd187016eb6fef134776f7d761"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga773d38fd187016eb6fef134776f7d761"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#ga773d38fd187016eb6fef134776f7d761">operator!=</a> (const <a class="el" href="a02193.html">ParallelLocalIndex</a>&lt; T &gt; &amp;p1, const <a class="el" href="a02193.html">ParallelLocalIndex</a>&lt; T &gt; &amp;p2)</td></tr>
<tr class="separator:ga773d38fd187016eb6fef134776f7d761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadff1176482f8b02fb98cc4e08695a2ce"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gadff1176482f8b02fb98cc4e08695a2ce"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#gadff1176482f8b02fb98cc4e08695a2ce">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="a02213.html">RemoteIndex</a>&lt; T1, T2 &gt; &amp;index)</td></tr>
<tr class="separator:gadff1176482f8b02fb98cc4e08695a2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4298476f0be2dd2f85d9fb856ff228a1"><td class="memTemplParams" colspan="2">template&lt;class T , class A &gt; </td></tr>
<tr class="memitem:ga4298476f0be2dd2f85d9fb856ff228a1"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00419.html#ga4298476f0be2dd2f85d9fb856ff228a1">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="a02209.html">RemoteIndices</a>&lt; T, A &gt; &amp;indices)</td></tr>
<tr class="separator:ga4298476f0be2dd2f85d9fb856ff228a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fcca471c1f5c5909f0b8fe316e6dcf"><td class="memTemplParams" colspan="2">template&lt;typename TG , typename TA &gt; </td></tr>
<tr class="memitem:ad5fcca471c1f5c5909f0b8fe316e6dcf"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#ad5fcca471c1f5c5909f0b8fe316e6dcf">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="a02213.html">RemoteIndex</a>&lt; TG, TA &gt; &amp;index)</td></tr>
<tr class="separator:ad5fcca471c1f5c5909f0b8fe316e6dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf35055b90526b3266f36956a4e361f50"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00403.html#gaf35055b90526b3266f36956a4e361f50">concatPaths</a> (const std::string &amp;base, const std::string &amp;p)</td></tr>
<tr class="memdesc:gaf35055b90526b3266f36956a4e361f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">concatenate two paths  <a href="a00403.html#gaf35055b90526b3266f36956a4e361f50">More...</a><br /></td></tr>
<tr class="separator:gaf35055b90526b3266f36956a4e361f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b4c87bd874abdd0db9f6dc51d9588b0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00403.html#ga1b4c87bd874abdd0db9f6dc51d9588b0">processPath</a> (const std::string &amp;p)</td></tr>
<tr class="memdesc:ga1b4c87bd874abdd0db9f6dc51d9588b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">sanitize a path for further processing  <a href="a00403.html#ga1b4c87bd874abdd0db9f6dc51d9588b0">More...</a><br /></td></tr>
<tr class="separator:ga1b4c87bd874abdd0db9f6dc51d9588b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d1669ed8677a07b152b1de21640b3f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00403.html#ga1d1669ed8677a07b152b1de21640b3f9">pathIndicatesDirectory</a> (const std::string &amp;p)</td></tr>
<tr class="memdesc:ga1d1669ed8677a07b152b1de21640b3f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether the given path indicates that it is a directory  <a href="a00403.html#ga1d1669ed8677a07b152b1de21640b3f9">More...</a><br /></td></tr>
<tr class="separator:ga1d1669ed8677a07b152b1de21640b3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9908e9eb153f3d37d7c7063ffc9b6a2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00403.html#gaa9908e9eb153f3d37d7c7063ffc9b6a2">prettyPath</a> (const std::string &amp;p, bool isDirectory)</td></tr>
<tr class="memdesc:gaa9908e9eb153f3d37d7c7063ffc9b6a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">pretty print path  <a href="a00403.html#gaa9908e9eb153f3d37d7c7063ffc9b6a2">More...</a><br /></td></tr>
<tr class="separator:gaa9908e9eb153f3d37d7c7063ffc9b6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae07624c824232706454d5d6d1d1cb5c8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00403.html#gae07624c824232706454d5d6d1d1cb5c8">prettyPath</a> (const std::string &amp;p)</td></tr>
<tr class="memdesc:gae07624c824232706454d5d6d1d1cb5c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">pretty print path  <a href="a00403.html#gae07624c824232706454d5d6d1d1cb5c8">More...</a><br /></td></tr>
<tr class="separator:gae07624c824232706454d5d6d1d1cb5c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2ce1b1de5e4a5c74802d615b4027a7b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00403.html#gab2ce1b1de5e4a5c74802d615b4027a7b">relativePath</a> (const std::string &amp;newbase, const std::string &amp;p)</td></tr>
<tr class="memdesc:gab2ce1b1de5e4a5c74802d615b4027a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute a relative path between two paths  <a href="a00403.html#gab2ce1b1de5e4a5c74802d615b4027a7b">More...</a><br /></td></tr>
<tr class="separator:gab2ce1b1de5e4a5c74802d615b4027a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67f486062c5bfb92aa3365373d491836"><td class="memTemplParams" colspan="2">template&lt;typename T1 , std::size_t t1, typename T2 , std::size_t t2&gt; </td></tr>
<tr class="memitem:ga67f486062c5bfb92aa3365373d491836"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00401.html#ga67f486062c5bfb92aa3365373d491836">operator==</a> (const <a class="el" href="a02369.html">PoolAllocator</a>&lt; T1, t1 &gt; &amp;, const <a class="el" href="a02369.html">PoolAllocator</a>&lt; T2, t2 &gt; &amp;)</td></tr>
<tr class="separator:ga67f486062c5bfb92aa3365373d491836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0e4942c0493dceaf371ba9f0ec29ab6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , std::size_t t1, typename T2 , std::size_t t2&gt; </td></tr>
<tr class="memitem:gaf0e4942c0493dceaf371ba9f0ec29ab6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00401.html#gaf0e4942c0493dceaf371ba9f0ec29ab6">operator!=</a> (const <a class="el" href="a02369.html">PoolAllocator</a>&lt; T1, t1 &gt; &amp;, const <a class="el" href="a02369.html">PoolAllocator</a>&lt; T2, t2 &gt; &amp;)</td></tr>
<tr class="separator:gaf0e4942c0493dceaf371ba9f0ec29ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6358d63f2012e81c5066d6c6d9cb94a"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t t1, std::size_t t2&gt; </td></tr>
<tr class="memitem:gab6358d63f2012e81c5066d6c6d9cb94a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00401.html#gab6358d63f2012e81c5066d6c6d9cb94a">operator==</a> (const <a class="el" href="a02369.html">PoolAllocator</a>&lt; T, t1 &gt; &amp;p1, const <a class="el" href="a02369.html">PoolAllocator</a>&lt; T, t2 &gt; &amp;p2)</td></tr>
<tr class="separator:gab6358d63f2012e81c5066d6c6d9cb94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c515ca850107e6807b75f4d90ca4dcc"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t t1, std::size_t t2&gt; </td></tr>
<tr class="memitem:ga2c515ca850107e6807b75f4d90ca4dcc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00401.html#ga2c515ca850107e6807b75f4d90ca4dcc">operator!=</a> (const <a class="el" href="a02369.html">PoolAllocator</a>&lt; T, t1 &gt; &amp;p1, const <a class="el" href="a02369.html">PoolAllocator</a>&lt; T, t2 &gt; &amp;p2)</td></tr>
<tr class="separator:ga2c515ca850107e6807b75f4d90ca4dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab00b326f648ee860460ddeec2f4b6d3b"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t t1, std::size_t t2&gt; </td></tr>
<tr class="memitem:gab00b326f648ee860460ddeec2f4b6d3b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00401.html#gab00b326f648ee860460ddeec2f4b6d3b">operator==</a> (const <a class="el" href="a02369.html">PoolAllocator</a>&lt; void, t1 &gt; &amp;, const <a class="el" href="a02369.html">PoolAllocator</a>&lt; T, t2 &gt; &amp;)</td></tr>
<tr class="separator:gab00b326f648ee860460ddeec2f4b6d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace25a69f0bcd5ba1fffd567af1d9a9cf"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t t1, std::size_t t2&gt; </td></tr>
<tr class="memitem:gace25a69f0bcd5ba1fffd567af1d9a9cf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00401.html#gace25a69f0bcd5ba1fffd567af1d9a9cf">operator!=</a> (const <a class="el" href="a02369.html">PoolAllocator</a>&lt; void, t1 &gt; &amp;, const <a class="el" href="a02369.html">PoolAllocator</a>&lt; T, t2 &gt; &amp;)</td></tr>
<tr class="separator:gace25a69f0bcd5ba1fffd567af1d9a9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bc475e78eb7d029ee0782eab49d5938"><td class="memTemplParams" colspan="2">template&lt;std::size_t t1, std::size_t t2&gt; </td></tr>
<tr class="memitem:ga5bc475e78eb7d029ee0782eab49d5938"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00401.html#ga5bc475e78eb7d029ee0782eab49d5938">operator==</a> (const <a class="el" href="a02369.html">PoolAllocator</a>&lt; void, t1 &gt; &amp;p1, const <a class="el" href="a02369.html">PoolAllocator</a>&lt; void, t2 &gt; &amp;p2)</td></tr>
<tr class="separator:ga5bc475e78eb7d029ee0782eab49d5938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6795aefd733bd618db889c6f15f1552f"><td class="memTemplParams" colspan="2">template&lt;std::size_t t1, std::size_t t2&gt; </td></tr>
<tr class="memitem:ga6795aefd733bd618db889c6f15f1552f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00401.html#ga6795aefd733bd618db889c6f15f1552f">operator!=</a> (const <a class="el" href="a02369.html">PoolAllocator</a>&lt; void, t1 &gt; &amp;p1, const <a class="el" href="a02369.html">PoolAllocator</a>&lt; void, t2 &gt; &amp;p2)</td></tr>
<tr class="separator:ga6795aefd733bd618db889c6f15f1552f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422c8e50ed4f40b534187b8fb83fbf3d"><td class="memTemplParams" colspan="2">template&lt;class Reference , class PropertyMap , class Key &gt; </td></tr>
<tr class="memitem:a422c8e50ed4f40b534187b8fb83fbf3d"><td class="memTemplItemLeft" align="right" valign="top">Reference&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#a422c8e50ed4f40b534187b8fb83fbf3d">get</a> (const <a class="el" href="a02441.html">RAPropertyMapHelper</a>&lt; Reference, PropertyMap &gt; &amp;pmap, const Key &amp;key)</td></tr>
<tr class="separator:a422c8e50ed4f40b534187b8fb83fbf3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc4d3a226776723750b848ae303a11a"><td class="memTemplParams" colspan="2">template&lt;class Reference , class PropertyMap , class Key , class Value &gt; </td></tr>
<tr class="memitem:a2dc4d3a226776723750b848ae303a11a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#a2dc4d3a226776723750b848ae303a11a">put</a> (const <a class="el" href="a02441.html">RAPropertyMapHelper</a>&lt; Reference, PropertyMap &gt; &amp;pmap, const Key &amp;key, const Value &amp;value)</td></tr>
<tr class="separator:a2dc4d3a226776723750b848ae303a11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab204e4c1df410966214b242af99406a1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab204e4c1df410966214b242af99406a1"><td class="memTemplItemLeft" align="right" valign="top">pointer_or_proxy_holder&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00409.html#gab204e4c1df410966214b242af99406a1">handle_proxy_member_access</a> (T &amp;&amp;t)</td></tr>
<tr class="memdesc:gab204e4c1df410966214b242af99406a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transparent support for providing member access to both lvalues and rvalues (temporary proxies).  <a href="a00409.html#gab204e4c1df410966214b242af99406a1">More...</a><br /></td></tr>
<tr class="separator:gab204e4c1df410966214b242af99406a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf05bafe739a71f1e7f30780dbae4fa05"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; IsIterable&lt; T &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:gaf05bafe739a71f1e7f30780dbae4fa05"><td class="memTemplItemLeft" align="right" valign="top">T::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00404.html#gaf05bafe739a71f1e7f30780dbae4fa05">max_value</a> (const T &amp;v)</td></tr>
<tr class="memdesc:gaf05bafe739a71f1e7f30780dbae4fa05"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the maximum value over a range  <a href="a00404.html#gaf05bafe739a71f1e7f30780dbae4fa05">More...</a><br /></td></tr>
<tr class="separator:gaf05bafe739a71f1e7f30780dbae4fa05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf05bafe739a71f1e7f30780dbae4fa05"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt;!IsIterable&lt; T &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:gaf05bafe739a71f1e7f30780dbae4fa05"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#gaf05bafe739a71f1e7f30780dbae4fa05">max_value</a> (const T &amp;v)</td></tr>
<tr class="separator:gaf05bafe739a71f1e7f30780dbae4fa05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa56de4535eff55ba6d5e418fd26b686c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; IsIterable&lt; T &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:gaa56de4535eff55ba6d5e418fd26b686c"><td class="memTemplItemLeft" align="right" valign="top">T::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00404.html#gaa56de4535eff55ba6d5e418fd26b686c">min_value</a> (const T &amp;v)</td></tr>
<tr class="memdesc:gaa56de4535eff55ba6d5e418fd26b686c"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the minimum value over a range  <a href="a00404.html#gaa56de4535eff55ba6d5e418fd26b686c">More...</a><br /></td></tr>
<tr class="separator:gaa56de4535eff55ba6d5e418fd26b686c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa56de4535eff55ba6d5e418fd26b686c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt;!IsIterable&lt; T &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:gaa56de4535eff55ba6d5e418fd26b686c"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#gaa56de4535eff55ba6d5e418fd26b686c">min_value</a> (const T &amp;v)</td></tr>
<tr class="separator:gaa56de4535eff55ba6d5e418fd26b686c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19dd21ff930466597df962ae58d58c57"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; IsIterable&lt; T &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ga19dd21ff930466597df962ae58d58c57"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00404.html#ga19dd21ff930466597df962ae58d58c57">any_true</a> (const T &amp;v)</td></tr>
<tr class="memdesc:ga19dd21ff930466597df962ae58d58c57"><td class="mdescLeft">&#160;</td><td class="mdescRight">similar to std::bitset&lt;N&gt;::any() return true, if any entries is true  <a href="a00404.html#ga19dd21ff930466597df962ae58d58c57">More...</a><br /></td></tr>
<tr class="separator:ga19dd21ff930466597df962ae58d58c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaca8a2450469eb41c338d8f51231fc34"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:gaaca8a2450469eb41c338d8f51231fc34"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00404.html#gaaca8a2450469eb41c338d8f51231fc34">any_true</a> (const std::bitset&lt; N &gt; &amp;b)</td></tr>
<tr class="separator:gaaca8a2450469eb41c338d8f51231fc34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f11c34177907a5c592990a5f4840e92"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; IsIterable&lt; T &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ga3f11c34177907a5c592990a5f4840e92"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00404.html#ga3f11c34177907a5c592990a5f4840e92">all_true</a> (const T &amp;v)</td></tr>
<tr class="memdesc:ga3f11c34177907a5c592990a5f4840e92"><td class="mdescLeft">&#160;</td><td class="mdescRight">similar to std::bitset&lt;N&gt;::all() return true, if any entries is true  <a href="a00404.html#ga3f11c34177907a5c592990a5f4840e92">More...</a><br /></td></tr>
<tr class="separator:ga3f11c34177907a5c592990a5f4840e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1782fbfe7b40a75fecb933f720357e54"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:ga1782fbfe7b40a75fecb933f720357e54"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00404.html#ga1782fbfe7b40a75fecb933f720357e54">all_true</a> (const std::bitset&lt; N &gt; &amp;b)</td></tr>
<tr class="separator:ga1782fbfe7b40a75fecb933f720357e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20c2d5d24fba2015d933669de38606f9"><td class="memTemplParams" colspan="2">template&lt;class T , class U , std::enable_if_t&lt; std::is_same&lt; std::decay_t&lt; T &gt;, std::decay_t&lt; U &gt;&gt;::value, int &gt;  = 0, std::enable_if_t&lt; std::is_integral&lt; std::decay_t&lt; T &gt;&gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ga20c2d5d24fba2015d933669de38606f9"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="a02473.html">IntegralRange</a>&lt; std::decay_t&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00404.html#ga20c2d5d24fba2015d933669de38606f9">range</a> (T &amp;&amp;from, U &amp;&amp;to) noexcept</td></tr>
<tr class="memdesc:ga20c2d5d24fba2015d933669de38606f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">free standing function for setting up a range based for loop over an integer range for (auto i: range(0,10)) // 0,1,2,3,4,5,6,7,8,9 or for (auto i: range(-10,10)) // -10,-9,..,8,9 or for (auto i: range(10)) // 0,1,2,3,4,5,6,7,8,9  <a href="a00404.html#ga20c2d5d24fba2015d933669de38606f9">More...</a><br /></td></tr>
<tr class="separator:ga20c2d5d24fba2015d933669de38606f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab64fac9d63a7009ccfa29af11ec5fc1c"><td class="memTemplParams" colspan="2">template&lt;class T , std::enable_if_t&lt; std::is_integral&lt; std::decay_t&lt; T &gt;&gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:gab64fac9d63a7009ccfa29af11ec5fc1c"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="a02473.html">IntegralRange</a>&lt; std::decay_t&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00404.html#gab64fac9d63a7009ccfa29af11ec5fc1c">range</a> (T &amp;&amp;to) noexcept</td></tr>
<tr class="separator:gab64fac9d63a7009ccfa29af11ec5fc1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab64fac9d63a7009ccfa29af11ec5fc1c"><td class="memTemplParams" colspan="2">template&lt;class T , std::enable_if_t&lt; std::is_enum&lt; std::decay_t&lt; T &gt;&gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:gab64fac9d63a7009ccfa29af11ec5fc1c"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="a02473.html">IntegralRange</a>&lt; std::underlying_type_t&lt; std::decay_t&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#gab64fac9d63a7009ccfa29af11ec5fc1c">range</a> (T &amp;&amp;to) noexcept</td></tr>
<tr class="separator:gab64fac9d63a7009ccfa29af11ec5fc1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd0ae414ee372842796c06cee030a78b"><td class="memTemplParams" colspan="2">template&lt;class T , T to&gt; </td></tr>
<tr class="memitem:gadd0ae414ee372842796c06cee030a78b"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="a02477.html">StaticIntegralRange</a>&lt; T, to &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00404.html#gadd0ae414ee372842796c06cee030a78b">range</a> (std::integral_constant&lt; T, to &gt;) noexcept</td></tr>
<tr class="separator:gadd0ae414ee372842796c06cee030a78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2dd8cb1fce8767381e33a5b834cf55d"><td class="memTemplParams" colspan="2">template&lt;class R , class F &gt; </td></tr>
<tr class="memitem:gae2dd8cb1fce8767381e33a5b834cf55d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00404.html#gae2dd8cb1fce8767381e33a5b834cf55d">transformedRangeView</a> (R &amp;&amp;<a class="el" href="a00404.html#ga9749b12765838700df3504bcae783e35">range</a>, const F &amp;f)</td></tr>
<tr class="memdesc:gae2dd8cb1fce8767381e33a5b834cf55d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="a02509.html" title="A range transforming the values of another range on-the-fly.">TransformedRangeView</a>.  <a href="a00404.html#gae2dd8cb1fce8767381e33a5b834cf55d">More...</a><br /></td></tr>
<tr class="separator:gae2dd8cb1fce8767381e33a5b834cf55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccf70716194b093e0d21e6da93c108f8"><td class="memTemplParams" colspan="2">template&lt;class R , class F &gt; </td></tr>
<tr class="memitem:gaccf70716194b093e0d21e6da93c108f8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00404.html#gaccf70716194b093e0d21e6da93c108f8">iteratorTransformedRangeView</a> (R &amp;&amp;<a class="el" href="a00404.html#ga9749b12765838700df3504bcae783e35">range</a>, const F &amp;f)</td></tr>
<tr class="memdesc:gaccf70716194b093e0d21e6da93c108f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="a02509.html" title="A range transforming the values of another range on-the-fly.">TransformedRangeView</a> using an iterator transformation.  <a href="a00404.html#gaccf70716194b093e0d21e6da93c108f8">More...</a><br /></td></tr>
<tr class="separator:gaccf70716194b093e0d21e6da93c108f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa75d4e74da1410405a33a5a62b5710e7"><td class="memTemplParams" colspan="2">template&lt;class Range &gt; </td></tr>
<tr class="memitem:gaa75d4e74da1410405a33a5a62b5710e7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00404.html#gaa75d4e74da1410405a33a5a62b5710e7">sparseRange</a> (Range &amp;&amp;<a class="el" href="a00404.html#ga9749b12765838700df3504bcae783e35">range</a>)</td></tr>
<tr class="memdesc:gaa75d4e74da1410405a33a5a62b5710e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow structured-binding for-loops for sparse iterators.  <a href="a00404.html#gaa75d4e74da1410405a33a5a62b5710e7">More...</a><br /></td></tr>
<tr class="separator:gaa75d4e74da1410405a33a5a62b5710e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee36ec1f6416afa0487a8a224376e34"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0ee36ec1f6416afa0487a8a224376e34"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#a0ee36ec1f6416afa0487a8a224376e34">stackobject_to_shared_ptr</a> (T &amp;t)</td></tr>
<tr class="memdesc:a0ee36ec1f6416afa0487a8a224376e34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a shared_ptr for a stack-allocated object.  <a href="a00428.html#a0ee36ec1f6416afa0487a8a224376e34">More...</a><br /></td></tr>
<tr class="separator:a0ee36ec1f6416afa0487a8a224376e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8b6bf5f8910e34829136293000c29e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:abc8b6bf5f8910e34829136293000c29e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#abc8b6bf5f8910e34829136293000c29e">wrap_or_move</a> (T &amp;&amp;t)</td></tr>
<tr class="memdesc:abc8b6bf5f8910e34829136293000c29e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capture R-value reference to shared_ptr.  <a href="a00428.html#abc8b6bf5f8910e34829136293000c29e">More...</a><br /></td></tr>
<tr class="separator:abc8b6bf5f8910e34829136293000c29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3669cc3fbff695e5ae793ab49f1ca8a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab3669cc3fbff695e5ae793ab49f1ca8a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#ab3669cc3fbff695e5ae793ab49f1ca8a">wrap_or_move</a> (T &amp;t)</td></tr>
<tr class="memdesc:ab3669cc3fbff695e5ae793ab49f1ca8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capture L-value reference to std::shared_ptr.  <a href="a00428.html#ab3669cc3fbff695e5ae793ab49f1ca8a">More...</a><br /></td></tr>
<tr class="separator:ab3669cc3fbff695e5ae793ab49f1ca8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b977cae5e0e694b4b108bc1cab9434"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a87b977cae5e0e694b4b108bc1cab9434">DUNE_SIMD_LOOP_BINARY_OP</a> (+)</td></tr>
<tr class="separator:a87b977cae5e0e694b4b108bc1cab9434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa97415d63ec08e63ea87832efe86ddb4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#aa97415d63ec08e63ea87832efe86ddb4">DUNE_SIMD_LOOP_BINARY_OP</a> (-)</td></tr>
<tr class="separator:aa97415d63ec08e63ea87832efe86ddb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed8fafa25b2552e5a1b73ab0b48c87d"><td class="memItemLeft" align="right" valign="top">DUNE_SIMD_LOOP_BINARY_OP *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#abed8fafa25b2552e5a1b73ab0b48c87d">DUNE_SIMD_LOOP_BINARY_OP</a> (/);DUNE_SIMD_LOOP_BINARY_OP(%</td></tr>
<tr class="separator:abed8fafa25b2552e5a1b73ab0b48c87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9fb3b7e66eca6930e91efcbee98b201"><td class="memItemLeft" align="right" valign="top">DUNE_SIMD_LOOP_BINARY_OP &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#ad9fb3b7e66eca6930e91efcbee98b201">DUNE_SIMD_LOOP_BINARY_OP</a> (|);DUNE_SIMD_LOOP_BINARY_OP(^</td></tr>
<tr class="separator:ad9fb3b7e66eca6930e91efcbee98b201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1786e12e4c3efe8a6117ddd99a8724a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#ab1786e12e4c3efe8a6117ddd99a8724a">DUNE_SIMD_LOOP_BITSHIFT_OP</a> (&lt;&lt;)</td></tr>
<tr class="separator:ab1786e12e4c3efe8a6117ddd99a8724a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250563e257d03a8336c3370f5caeaf84"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a250563e257d03a8336c3370f5caeaf84">DUNE_SIMD_LOOP_BITSHIFT_OP</a> (&gt;&gt;)</td></tr>
<tr class="separator:a250563e257d03a8336c3370f5caeaf84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae72f618cfe280b17a988b83395f8927"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#aae72f618cfe280b17a988b83395f8927">DUNE_SIMD_LOOP_COMPARISON_OP</a> (&lt;)</td></tr>
<tr class="separator:aae72f618cfe280b17a988b83395f8927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b3da3ac3b884cf28ba5dc3dfee5652"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a86b3da3ac3b884cf28ba5dc3dfee5652">DUNE_SIMD_LOOP_COMPARISON_OP</a> (&lt;=)</td></tr>
<tr class="separator:a86b3da3ac3b884cf28ba5dc3dfee5652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16bec43001a47bb4b3d6a78aec88476b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a16bec43001a47bb4b3d6a78aec88476b">DUNE_SIMD_LOOP_COMPARISON_OP</a> (&gt;=)</td></tr>
<tr class="separator:a16bec43001a47bb4b3d6a78aec88476b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafcd80f1669dd6eee03a6ff6bbf85150"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#aafcd80f1669dd6eee03a6ff6bbf85150">DUNE_SIMD_LOOP_COMPARISON_OP</a> (!=)</td></tr>
<tr class="separator:aafcd80f1669dd6eee03a6ff6bbf85150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c74f8a0a2706073686260f2dc63012"><td class="memItemLeft" align="right" valign="top">DUNE_SIMD_LOOP_BOOLEAN_OP &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a36c74f8a0a2706073686260f2dc63012">DUNE_SIMD_LOOP_BOOLEAN_OP</a> (||);template&lt; class T, std::size_t S, std::size_t A &gt; std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const <a class="el" href="a02581.html">LoopSIMD</a>&lt; T, S, A &gt; &amp;v</td></tr>
<tr class="separator:a36c74f8a0a2706073686260f2dc63012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e5e1c5f79b6254d378e95cfd322a65"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#aa6e5e1c5f79b6254d378e95cfd322a65">DUNE_SIMD_LOOP_CMATH_UNARY_OP</a> (cos)</td></tr>
<tr class="separator:aa6e5e1c5f79b6254d378e95cfd322a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ab0dba2a12a0bc0a7944f9ae9f1f29"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a79ab0dba2a12a0bc0a7944f9ae9f1f29">DUNE_SIMD_LOOP_CMATH_UNARY_OP</a> (sin)</td></tr>
<tr class="separator:a79ab0dba2a12a0bc0a7944f9ae9f1f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84860183d3c2955e5faa0d0cc32fb4c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#ae84860183d3c2955e5faa0d0cc32fb4c">DUNE_SIMD_LOOP_CMATH_UNARY_OP</a> (tan)</td></tr>
<tr class="separator:ae84860183d3c2955e5faa0d0cc32fb4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa360ad475ef9a72d1d29c5dabcc3bf73"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#aa360ad475ef9a72d1d29c5dabcc3bf73">DUNE_SIMD_LOOP_CMATH_UNARY_OP</a> (acos)</td></tr>
<tr class="separator:aa360ad475ef9a72d1d29c5dabcc3bf73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f392d978d7b88cf99fb06019e7bd40"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a09f392d978d7b88cf99fb06019e7bd40">DUNE_SIMD_LOOP_CMATH_UNARY_OP</a> (asin)</td></tr>
<tr class="separator:a09f392d978d7b88cf99fb06019e7bd40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d537b66b859eb038d3820337c18fce9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a2d537b66b859eb038d3820337c18fce9">DUNE_SIMD_LOOP_CMATH_UNARY_OP</a> (atan)</td></tr>
<tr class="separator:a2d537b66b859eb038d3820337c18fce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680c29e54698d49501b3b2de4ce2ef47"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a680c29e54698d49501b3b2de4ce2ef47">DUNE_SIMD_LOOP_CMATH_UNARY_OP</a> (cosh)</td></tr>
<tr class="separator:a680c29e54698d49501b3b2de4ce2ef47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395094c113cdd8c2121111872085a735"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a395094c113cdd8c2121111872085a735">DUNE_SIMD_LOOP_CMATH_UNARY_OP</a> (sinh)</td></tr>
<tr class="separator:a395094c113cdd8c2121111872085a735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e1c8435b5fa7a7b196806e25a1425f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a98e1c8435b5fa7a7b196806e25a1425f">DUNE_SIMD_LOOP_CMATH_UNARY_OP</a> (tanh)</td></tr>
<tr class="separator:a98e1c8435b5fa7a7b196806e25a1425f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08b81d847b50e9c9c4cee7c7d1f29cf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#aa08b81d847b50e9c9c4cee7c7d1f29cf">DUNE_SIMD_LOOP_CMATH_UNARY_OP</a> (acosh)</td></tr>
<tr class="separator:aa08b81d847b50e9c9c4cee7c7d1f29cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb4e14d3112e1de6b78b1210a991865"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#acbb4e14d3112e1de6b78b1210a991865">DUNE_SIMD_LOOP_CMATH_UNARY_OP</a> (asinh)</td></tr>
<tr class="separator:acbb4e14d3112e1de6b78b1210a991865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfbdf70bffe090b2531d64749b2c91c4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#adfbdf70bffe090b2531d64749b2c91c4">DUNE_SIMD_LOOP_CMATH_UNARY_OP</a> (atanh)</td></tr>
<tr class="separator:adfbdf70bffe090b2531d64749b2c91c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe0541c3cddfa4781331ac0d05887d48"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#abe0541c3cddfa4781331ac0d05887d48">DUNE_SIMD_LOOP_CMATH_UNARY_OP</a> (exp)</td></tr>
<tr class="separator:abe0541c3cddfa4781331ac0d05887d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab0990a076434714f940464ebce3fe9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a0ab0990a076434714f940464ebce3fe9">DUNE_SIMD_LOOP_CMATH_UNARY_OP</a> (log)</td></tr>
<tr class="separator:a0ab0990a076434714f940464ebce3fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af920243bd9e1e124679ead131489016e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#af920243bd9e1e124679ead131489016e">DUNE_SIMD_LOOP_CMATH_UNARY_OP</a> (log10)</td></tr>
<tr class="separator:af920243bd9e1e124679ead131489016e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4544c2a970c27e9ebb3cd7e2ea5ddc7b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a4544c2a970c27e9ebb3cd7e2ea5ddc7b">DUNE_SIMD_LOOP_CMATH_UNARY_OP</a> (exp2)</td></tr>
<tr class="separator:a4544c2a970c27e9ebb3cd7e2ea5ddc7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7634e73ae107cad38d3c1c30d2be80bd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a7634e73ae107cad38d3c1c30d2be80bd">DUNE_SIMD_LOOP_CMATH_UNARY_OP</a> (expm1)</td></tr>
<tr class="separator:a7634e73ae107cad38d3c1c30d2be80bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d65fea3f35e081fc433ef3366cba7b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a17d65fea3f35e081fc433ef3366cba7b">DUNE_SIMD_LOOP_CMATH_UNARY_OP_WITH_RETURN</a> (ilogb, int)</td></tr>
<tr class="separator:a17d65fea3f35e081fc433ef3366cba7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a67dfa432cacbe104d169f89ea161f8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a5a67dfa432cacbe104d169f89ea161f8">DUNE_SIMD_LOOP_CMATH_UNARY_OP</a> (log1p)</td></tr>
<tr class="separator:a5a67dfa432cacbe104d169f89ea161f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca741e8dd2d8cefaf43410eff2f1e28"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a5ca741e8dd2d8cefaf43410eff2f1e28">DUNE_SIMD_LOOP_CMATH_UNARY_OP</a> (log2)</td></tr>
<tr class="separator:a5ca741e8dd2d8cefaf43410eff2f1e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83810e6d9502d807c8bd6500e398df7c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a83810e6d9502d807c8bd6500e398df7c">DUNE_SIMD_LOOP_CMATH_UNARY_OP</a> (logb)</td></tr>
<tr class="separator:a83810e6d9502d807c8bd6500e398df7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160d3e17ed369ef66e6a5616b9d0f0ed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a160d3e17ed369ef66e6a5616b9d0f0ed">DUNE_SIMD_LOOP_CMATH_UNARY_OP</a> (sqrt)</td></tr>
<tr class="separator:a160d3e17ed369ef66e6a5616b9d0f0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade26d1af9df16776724aa09f347d8856"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#ade26d1af9df16776724aa09f347d8856">DUNE_SIMD_LOOP_CMATH_UNARY_OP</a> (cbrt)</td></tr>
<tr class="separator:ade26d1af9df16776724aa09f347d8856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5569c638beb6711c21a041ef6441bc7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#ad5569c638beb6711c21a041ef6441bc7">DUNE_SIMD_LOOP_CMATH_UNARY_OP</a> (erf)</td></tr>
<tr class="separator:ad5569c638beb6711c21a041ef6441bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ef7058640643efbe18ac57cc6eaf48"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a01ef7058640643efbe18ac57cc6eaf48">DUNE_SIMD_LOOP_CMATH_UNARY_OP</a> (erfc)</td></tr>
<tr class="separator:a01ef7058640643efbe18ac57cc6eaf48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e21698991978ed28373a29ebaa7676"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#ac9e21698991978ed28373a29ebaa7676">DUNE_SIMD_LOOP_CMATH_UNARY_OP</a> (tgamma)</td></tr>
<tr class="separator:ac9e21698991978ed28373a29ebaa7676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185f315ad3d194156672fdd4f299197d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a185f315ad3d194156672fdd4f299197d">DUNE_SIMD_LOOP_CMATH_UNARY_OP</a> (lgamma)</td></tr>
<tr class="separator:a185f315ad3d194156672fdd4f299197d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26dcbb76cee8f0300798c309959d86ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a26dcbb76cee8f0300798c309959d86ee">DUNE_SIMD_LOOP_CMATH_UNARY_OP</a> (ceil)</td></tr>
<tr class="separator:a26dcbb76cee8f0300798c309959d86ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762a6b51f18dadfb4eda6047cf754c64"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a762a6b51f18dadfb4eda6047cf754c64">DUNE_SIMD_LOOP_CMATH_UNARY_OP</a> (floor)</td></tr>
<tr class="separator:a762a6b51f18dadfb4eda6047cf754c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2109020367318862d81752b29c3af75d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a2109020367318862d81752b29c3af75d">DUNE_SIMD_LOOP_CMATH_UNARY_OP</a> (trunc)</td></tr>
<tr class="separator:a2109020367318862d81752b29c3af75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38807b16fbd42153aea86c4ccdd6bb91"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a38807b16fbd42153aea86c4ccdd6bb91">DUNE_SIMD_LOOP_CMATH_UNARY_OP</a> (round)</td></tr>
<tr class="separator:a38807b16fbd42153aea86c4ccdd6bb91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33060ecf7417568c97b04111620a1e28"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a33060ecf7417568c97b04111620a1e28">DUNE_SIMD_LOOP_CMATH_UNARY_OP_WITH_RETURN</a> (lround, long)</td></tr>
<tr class="separator:a33060ecf7417568c97b04111620a1e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1749c45138975ab7d1e9a8f426b8811c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a1749c45138975ab7d1e9a8f426b8811c">DUNE_SIMD_LOOP_CMATH_UNARY_OP_WITH_RETURN</a> (llround, long long)</td></tr>
<tr class="separator:a1749c45138975ab7d1e9a8f426b8811c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc68537e003af1c6cc7bf154566008b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#abc68537e003af1c6cc7bf154566008b0">DUNE_SIMD_LOOP_CMATH_UNARY_OP</a> (rint)</td></tr>
<tr class="separator:abc68537e003af1c6cc7bf154566008b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a50ac60761fb189996f0c6455c9deab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a4a50ac60761fb189996f0c6455c9deab">DUNE_SIMD_LOOP_CMATH_UNARY_OP_WITH_RETURN</a> (lrint, long)</td></tr>
<tr class="separator:a4a50ac60761fb189996f0c6455c9deab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa38b41506a8e473669feddb7d1db8c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#adfa38b41506a8e473669feddb7d1db8c">DUNE_SIMD_LOOP_CMATH_UNARY_OP_WITH_RETURN</a> (llrint, long long)</td></tr>
<tr class="separator:adfa38b41506a8e473669feddb7d1db8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10471153b4d96fc5e79f3b771b314ce2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a10471153b4d96fc5e79f3b771b314ce2">DUNE_SIMD_LOOP_CMATH_UNARY_OP</a> (nearbyint)</td></tr>
<tr class="separator:a10471153b4d96fc5e79f3b771b314ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577485241fdec0624801d8463b5987ca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a577485241fdec0624801d8463b5987ca">DUNE_SIMD_LOOP_CMATH_UNARY_OP</a> (fabs)</td></tr>
<tr class="separator:a577485241fdec0624801d8463b5987ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf083bd80799339ad4b7bc26009d1760"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#acf083bd80799339ad4b7bc26009d1760">DUNE_SIMD_LOOP_CMATH_UNARY_OP</a> (abs)</td></tr>
<tr class="separator:acf083bd80799339ad4b7bc26009d1760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5157b5aa1692d5a700cde7d8285ea99"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#ac5157b5aa1692d5a700cde7d8285ea99">DUNE_SIMD_LOOP_STD_UNARY_OP</a> (real)</td></tr>
<tr class="separator:ac5157b5aa1692d5a700cde7d8285ea99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b017f376d4eb1da79440f824f7ee55"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a97b017f376d4eb1da79440f824f7ee55">DUNE_SIMD_LOOP_STD_UNARY_OP</a> (imag)</td></tr>
<tr class="separator:a97b017f376d4eb1da79440f824f7ee55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1853753d5f04e6743b59ef878437e2e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a1853753d5f04e6743b59ef878437e2e1">DUNE_SIMD_LOOP_STD_BINARY_OP</a> (max)</td></tr>
<tr class="separator:a1853753d5f04e6743b59ef878437e2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8461f4eb3f7d2309ba49e96ad8df6305"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a8461f4eb3f7d2309ba49e96ad8df6305">DUNE_SIMD_LOOP_STD_BINARY_OP</a> (min)</td></tr>
<tr class="separator:a8461f4eb3f7d2309ba49e96ad8df6305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2c37fe2704917536f5263272d0a7e2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:afc2c37fe2704917536f5263272d0a7e2"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#afc2c37fe2704917536f5263272d0a7e2">lanes</a> (const T &amp;)</td></tr>
<tr class="memdesc:afc2c37fe2704917536f5263272d0a7e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the number of lanes of a simd vector (scalar version)  <a href="a00428.html#afc2c37fe2704917536f5263272d0a7e2">More...</a><br /></td></tr>
<tr class="separator:afc2c37fe2704917536f5263272d0a7e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87be73bb4b219361645afcce2eb5b7a4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a87be73bb4b219361645afcce2eb5b7a4"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#a87be73bb4b219361645afcce2eb5b7a4">lane</a> (std::size_t l, const T &amp;v)</td></tr>
<tr class="memdesc:a87be73bb4b219361645afcce2eb5b7a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">access a lane of a simd vector (scalar version)  <a href="a00428.html#a87be73bb4b219361645afcce2eb5b7a4">More...</a><br /></td></tr>
<tr class="separator:a87be73bb4b219361645afcce2eb5b7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ebdb04638aaaa3011903e9cd31444d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af7ebdb04638aaaa3011903e9cd31444d"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#af7ebdb04638aaaa3011903e9cd31444d">lane</a> (std::size_t l, T &amp;v)</td></tr>
<tr class="memdesc:af7ebdb04638aaaa3011903e9cd31444d"><td class="mdescLeft">&#160;</td><td class="mdescRight">access a lane of a simd vector (scalar version)  <a href="a00428.html#af7ebdb04638aaaa3011903e9cd31444d">More...</a><br /></td></tr>
<tr class="separator:af7ebdb04638aaaa3011903e9cd31444d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c073df341c13a4da1c1522c60af0c3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a90c073df341c13a4da1c1522c60af0c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#a90c073df341c13a4da1c1522c60af0c3">assign</a> (T &amp;dst, const T &amp;src, bool mask)</td></tr>
<tr class="memdesc:a90c073df341c13a4da1c1522c60af0c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">masked <a class="el" href="a00432.html" title="Namespace for vectorization interface functions used by library developers.">Simd</a> assignment (scalar version)  <a href="a00428.html#a90c073df341c13a4da1c1522c60af0c3">More...</a><br /></td></tr>
<tr class="separator:a90c073df341c13a4da1c1522c60af0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc9a46e5ec32e3b68c3071cf1a25361"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8cc9a46e5ec32e3b68c3071cf1a25361"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#a8cc9a46e5ec32e3b68c3071cf1a25361">swap</a> (T &amp;v1, T &amp;v2, bool mask)</td></tr>
<tr class="separator:a8cc9a46e5ec32e3b68c3071cf1a25361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga572fa4d72fb27c6134aa355abc083969"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:ga572fa4d72fb27c6134aa355abc083969"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00400.html#ga572fa4d72fb27c6134aa355abc083969">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="a02829.html">SLList</a>&lt; T, A &gt; &amp;sllist)</td></tr>
<tr class="separator:ga572fa4d72fb27c6134aa355abc083969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76832a917330622cdf531c2e6375f4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#aa76832a917330622cdf531c2e6375f4c">doAssertCallOnce</a> (const char *file, int line, const char *function)</td></tr>
<tr class="separator:aa76832a917330622cdf531c2e6375f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b55a8ff91fc039845da40a86486a007"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a3b55a8ff91fc039845da40a86486a007">assertCallOnce</a> (const char *file=nullptr, int line=-1, const char *function=nullptr)</td></tr>
<tr class="memdesc:a3b55a8ff91fc039845da40a86486a007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sure call_once() works and provide a helpful error message otherwise.  <a href="a00428.html#a3b55a8ff91fc039845da40a86486a007">More...</a><br /></td></tr>
<tr class="separator:a3b55a8ff91fc039845da40a86486a007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafda8471a933991be73f03e0d349c1bf1"><td class="memTemplParams" colspan="2">template&lt;typename Stream , typename... Ts&gt; </td></tr>
<tr class="memitem:gafda8471a933991be73f03e0d349c1bf1"><td class="memTemplItemLeft" align="right" valign="top">Stream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00400.html#gafda8471a933991be73f03e0d349c1bf1">operator&lt;&lt;</a> (Stream &amp;stream, const std::tuple&lt; Ts... &gt; &amp;t)</td></tr>
<tr class="memdesc:gafda8471a933991be73f03e0d349c1bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a std::tuple.  <a href="a00400.html#gafda8471a933991be73f03e0d349c1bf1">More...</a><br /></td></tr>
<tr class="separator:gafda8471a933991be73f03e0d349c1bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32f86b48dbe3ad88dfcb32ba01dcc4a2"><td class="memTemplParams" colspan="2">template&lt;typename Stream , typename... Ts&gt; </td></tr>
<tr class="memitem:ga32f86b48dbe3ad88dfcb32ba01dcc4a2"><td class="memTemplItemLeft" align="right" valign="top">Stream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00400.html#ga32f86b48dbe3ad88dfcb32ba01dcc4a2">operator&gt;&gt;</a> (Stream &amp;stream, std::tuple&lt; Ts... &gt; &amp;t)</td></tr>
<tr class="memdesc:ga32f86b48dbe3ad88dfcb32ba01dcc4a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a std::tuple.  <a href="a00400.html#ga32f86b48dbe3ad88dfcb32ba01dcc4a2">More...</a><br /></td></tr>
<tr class="separator:ga32f86b48dbe3ad88dfcb32ba01dcc4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga540c7a094361004a08fdbd9c95063822"><td class="memTemplParams" colspan="2">template&lt;typename Stream , typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ga540c7a094361004a08fdbd9c95063822"><td class="memTemplItemLeft" align="right" valign="top">Stream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00400.html#ga540c7a094361004a08fdbd9c95063822">operator&lt;&lt;</a> (Stream &amp;stream, const std::array&lt; T, N &gt; &amp;a)</td></tr>
<tr class="memdesc:ga540c7a094361004a08fdbd9c95063822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a std::array.  <a href="a00400.html#ga540c7a094361004a08fdbd9c95063822">More...</a><br /></td></tr>
<tr class="separator:ga540c7a094361004a08fdbd9c95063822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf31028edab397ce01e0192a2823488f7"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:gaf31028edab397ce01e0192a2823488f7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00405.html#gaf31028edab397ce01e0192a2823488f7">hasPrefix</a> (const C &amp;c, const char *prefix)</td></tr>
<tr class="memdesc:gaf31028edab397ce01e0192a2823488f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a character container has a given prefix.  <a href="a00405.html#gaf31028edab397ce01e0192a2823488f7">More...</a><br /></td></tr>
<tr class="separator:gaf31028edab397ce01e0192a2823488f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga560ea1a14403e04148126a2e9396dea2"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:ga560ea1a14403e04148126a2e9396dea2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00405.html#ga560ea1a14403e04148126a2e9396dea2">hasSuffix</a> (const C &amp;c, const char *suffix)</td></tr>
<tr class="memdesc:ga560ea1a14403e04148126a2e9396dea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a character container has a given suffix.  <a href="a00405.html#ga560ea1a14403e04148126a2e9396dea2">More...</a><br /></td></tr>
<tr class="separator:ga560ea1a14403e04148126a2e9396dea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab825672ce0273462cb092bba70f39d0b"><td class="memTemplParams" colspan="2">template&lt;class... T&gt; </td></tr>
<tr class="memitem:gab825672ce0273462cb092bba70f39d0b"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00405.html#gab825672ce0273462cb092bba70f39d0b">formatString</a> (const std::string &amp;s, const T &amp;... args)</td></tr>
<tr class="memdesc:gab825672ce0273462cb092bba70f39d0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format values according to printf format string.  <a href="a00405.html#gab825672ce0273462cb092bba70f39d0b">More...</a><br /></td></tr>
<tr class="separator:gab825672ce0273462cb092bba70f39d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7db16fea4d4d85c90115bf94e4d7f5"><td class="memTemplParams" colspan="2">template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:ade7db16fea4d4d85c90115bf94e4d7f5"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#ade7db16fea4d4d85c90115bf94e4d7f5">makeToUnique</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ade7db16fea4d4d85c90115bf94e4d7f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>std::make_unique</code> introduced as transition wrapper.  <a href="a00428.html#ade7db16fea4d4d85c90115bf94e4d7f5">More...</a><br /></td></tr>
<tr class="separator:ade7db16fea4d4d85c90115bf94e4d7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413e66bc54b93298e15afc7af231e924"><td class="memTemplParams" colspan="2">template&lt;class Matrix &gt; </td></tr>
<tr class="memitem:a413e66bc54b93298e15afc7af231e924"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#a413e66bc54b93298e15afc7af231e924">transpose</a> (const Matrix &amp;matrix)</td></tr>
<tr class="memdesc:a413e66bc54b93298e15afc7af231e924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a wrapper modelling the transposed matrix.  <a href="a00428.html#a413e66bc54b93298e15afc7af231e924">More...</a><br /></td></tr>
<tr class="separator:a413e66bc54b93298e15afc7af231e924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeeffbe0f382283c9a2314a3947e54be9"><td class="memTemplParams" colspan="2">template&lt;class F , class ArgTuple , class I , I... i&gt; </td></tr>
<tr class="memitem:gaeeffbe0f382283c9a2314a3947e54be9"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00406.html#gaeeffbe0f382283c9a2314a3947e54be9">applyPartial</a> (F &amp;&amp;f, ArgTuple &amp;&amp;args, std::integer_sequence&lt; I, i... &gt;)</td></tr>
<tr class="memdesc:gaeeffbe0f382283c9a2314a3947e54be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply function with arguments from a given tuple.  <a href="a00406.html#gaeeffbe0f382283c9a2314a3947e54be9">More...</a><br /></td></tr>
<tr class="separator:gaeeffbe0f382283c9a2314a3947e54be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee981bf99011a9bc2dd496a7d486e4ab"><td class="memTemplParams" colspan="2">template&lt;class Tuple , class Functor &gt; </td></tr>
<tr class="memitem:gaee981bf99011a9bc2dd496a7d486e4ab"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00406.html#gaee981bf99011a9bc2dd496a7d486e4ab">genericTransformTuple</a> (Tuple &amp;&amp;t, Functor &amp;&amp;f) -&gt; decltype(genericTransformTupleBackend(t, f))</td></tr>
<tr class="separator:gaee981bf99011a9bc2dd496a7d486e4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab09a0e6719518183a81d60695510186a"><td class="memTemplParams" colspan="2">template&lt;template&lt; class &gt; class TE, class... Args&gt; </td></tr>
<tr class="memitem:gab09a0e6719518183a81d60695510186a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a02917.html">TransformTupleFunctor</a>&lt; TE, Args... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00406.html#gab09a0e6719518183a81d60695510186a">makeTransformTupleFunctor</a> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:gab09a0e6719518183a81d60695510186a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24fcc49c0d83971073f4e0bd5e96748b"><td class="memTemplParams" colspan="2">template&lt;template&lt; class &gt; class TypeEvaluator, class Tuple , class... Args&gt; </td></tr>
<tr class="memitem:ga24fcc49c0d83971073f4e0bd5e96748b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00406.html#ga24fcc49c0d83971073f4e0bd5e96748b">transformTuple</a> (Tuple &amp;&amp;orig, Args &amp;&amp;... args) -&gt; decltype(<a class="el" href="a00406.html#gaee981bf99011a9bc2dd496a7d486e4ab">genericTransformTuple</a>(orig, <a class="el" href="a00406.html#gab09a0e6719518183a81d60695510186a">makeTransformTupleFunctor</a>&lt; TypeEvaluator &gt;(args...)))</td></tr>
<tr class="separator:ga24fcc49c0d83971073f4e0bd5e96748b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae982edb333af3a1f24fe324cc593be0d"><td class="memTemplParams" colspan="2">template&lt;class... T&gt; </td></tr>
<tr class="memitem:ae982edb333af3a1f24fe324cc593be0d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#ae982edb333af3a1f24fe324cc593be0d">makeTupleVector</a> (T &amp;&amp;... t)</td></tr>
<tr class="separator:ae982edb333af3a1f24fe324cc593be0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595be06b36830646a9a348d33b7c51c1"><td class="memTemplParams" colspan="2">template&lt;class... T&gt; </td></tr>
<tr class="memitem:a595be06b36830646a9a348d33b7c51c1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00428.html#a595be06b36830646a9a348d33b7c51c1">uniqueTypeList</a> (<a class="el" href="a00407.html#ga7e18d05cb5d1e95f0e7c7409ffe9689f">TypeList</a>&lt; T... &gt; list)</td></tr>
<tr class="memdesc:a595be06b36830646a9a348d33b7c51c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove duplicates from a <a class="el" href="a00407.html#ga7e18d05cb5d1e95f0e7c7409ffe9689f" title="A simple type list.">Dune::TypeList</a>.  <a href="a00428.html#a595be06b36830646a9a348d33b7c51c1">More...</a><br /></td></tr>
<tr class="separator:a595be06b36830646a9a348d33b7c51c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fe355ad7447f0f4bc8ae0b6a39f6318"><td class="memTemplParams" colspan="2">template&lt;class T , T... t, std::size_t index&gt; </td></tr>
<tr class="memitem:ga0fe355ad7447f0f4bc8ae0b6a39f6318"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00409.html#ga0fe355ad7447f0f4bc8ae0b6a39f6318">integerSequenceEntry</a> (std::integer_sequence&lt; T, t... &gt;, std::integral_constant&lt; std::size_t, index &gt; i)</td></tr>
<tr class="memdesc:ga0fe355ad7447f0f4bc8ae0b6a39f6318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get entry of std::integer_sequence.  <a href="a00409.html#ga0fe355ad7447f0f4bc8ae0b6a39f6318">More...</a><br /></td></tr>
<tr class="separator:ga0fe355ad7447f0f4bc8ae0b6a39f6318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab256c9245e4037f7f42aa453e00fd97a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gab256c9245e4037f7f42aa453e00fd97a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a00409.html#ga64c2d9377550162293c4fabd163f457b">AutonomousValue</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00409.html#gab256c9245e4037f7f42aa453e00fd97a">autoCopy</a> (T &amp;&amp;v)</td></tr>
<tr class="memdesc:gab256c9245e4037f7f42aa453e00fd97a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Autonomous copy of an expression's value for use in <code>auto</code> type deduction.  <a href="a00409.html#gab256c9245e4037f7f42aa453e00fd97a">More...</a><br /></td></tr>
<tr class="separator:gab256c9245e4037f7f42aa453e00fd97a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6560bc030b518cf2da62724367f6ccdc"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00428.html#a6560bc030b518cf2da62724367f6ccdc">debugAlignment</a> = 2*alignof(std::max_align_t)</td></tr>
<tr class="memdesc:a6560bc030b518cf2da62724367f6ccdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">an alignment large enough to trigger alignment errors  <a href="a00428.html#a6560bc030b518cf2da62724367f6ccdc">More...</a><br /></td></tr>
<tr class="separator:a6560bc030b518cf2da62724367f6ccdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9749b12765838700df3504bcae783e35"><td class="memTemplParams" colspan="2">template&lt;class T , T from, T to&gt; </td></tr>
<tr class="memitem:ga9749b12765838700df3504bcae783e35"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="a02477.html">StaticIntegralRange</a>&lt; T, to, from &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00404.html#ga9749b12765838700df3504bcae783e35">range</a> (std::integral_constant&lt; T, from &gt;, std::integral_constant&lt; T, to &gt;) noexcept</td></tr>
<tr class="separator:ga9749b12765838700df3504bcae783e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20bcb085658a3b88393e47a1d36d667c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00426.html#ga08d48df3a7a0e3bd9c0425aba8004488">DVVerbType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00426.html#ga20bcb085658a3b88393e47a1d36d667c">dvverb</a> (std::cout)</td></tr>
<tr class="memdesc:ga20bcb085658a3b88393e47a1d36d667c"><td class="mdescLeft">&#160;</td><td class="mdescRight">stream for very verbose output.  <a href="a00426.html#ga20bcb085658a3b88393e47a1d36d667c">More...</a><br /></td></tr>
<tr class="separator:ga20bcb085658a3b88393e47a1d36d667c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8900dadc584357856d4f6cc06324cea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00426.html#ga65d14f278ea400db87ffb6a4bc7ed7b2">DVerbType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00426.html#gab8900dadc584357856d4f6cc06324cea">dverb</a> (std::cout)</td></tr>
<tr class="memdesc:gab8900dadc584357856d4f6cc06324cea"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a02813.html" title="An adapter to turn a class into a singleton.">Singleton</a> of verbose debug stream.  <a href="a00426.html#gab8900dadc584357856d4f6cc06324cea">More...</a><br /></td></tr>
<tr class="separator:gab8900dadc584357856d4f6cc06324cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5d2fce8ed49f95067d9b5b54d6f5def"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00426.html#gab41f4590c73d6408c89475e28bf18a8e">DInfoType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00426.html#gab5d2fce8ed49f95067d9b5b54d6f5def">dinfo</a> (std::cout)</td></tr>
<tr class="memdesc:gab5d2fce8ed49f95067d9b5b54d6f5def"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream for informative output.  <a href="a00426.html#gab5d2fce8ed49f95067d9b5b54d6f5def">More...</a><br /></td></tr>
<tr class="separator:gab5d2fce8ed49f95067d9b5b54d6f5def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bff1feeab1e96f08aca7796cc69b4ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00426.html#ga20379ab9c4472509d420e98659683fe6">DWarnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00426.html#ga4bff1feeab1e96f08aca7796cc69b4ea">dwarn</a> (std::cerr)</td></tr>
<tr class="memdesc:ga4bff1feeab1e96f08aca7796cc69b4ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream for warnings indicating problems.  <a href="a00426.html#ga4bff1feeab1e96f08aca7796cc69b4ea">More...</a><br /></td></tr>
<tr class="separator:ga4bff1feeab1e96f08aca7796cc69b4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga765267750e6b2718fa718ab5f9fa1ed9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00426.html#ga70e0eedd6c7f613d6e9608fabb4d240d">DGraveType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00426.html#ga765267750e6b2718fa718ab5f9fa1ed9">dgrave</a> (std::cerr)</td></tr>
<tr class="memdesc:ga765267750e6b2718fa718ab5f9fa1ed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream for warnings indicating fatal errors.  <a href="a00426.html#ga765267750e6b2718fa718ab5f9fa1ed9">More...</a><br /></td></tr>
<tr class="separator:ga765267750e6b2718fa718ab5f9fa1ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaa61db1e034d693335d33d3919ba9ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00426.html#ga768c0b513889d713fd0017ef7ae35056">DErrType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00426.html#gacaa61db1e034d693335d33d3919ba9ca">derr</a> (std::cerr)</td></tr>
<tr class="memdesc:gacaa61db1e034d693335d33d3919ba9ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream for error messages.  <a href="a00426.html#gacaa61db1e034d693335d33d3919ba9ca">More...</a><br /></td></tr>
<tr class="separator:gacaa61db1e034d693335d33d3919ba9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c074d4df6d5fa8fbe8b4e9d44b35df0"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="a00413.html#ga7b78ef57d1b77933ab277ebe66c79d94">DebugLevel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00426.html#ga2c074d4df6d5fa8fbe8b4e9d44b35df0">MINIMAL_DEBUG_LEVEL</a> = <a class="el" href="a00426.html#ga3a5303f96d33ae7299d9acd71b736998">DUNE_MINIMAL_DEBUG_LEVEL</a></td></tr>
<tr class="separator:ga2c074d4df6d5fa8fbe8b4e9d44b35df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga490cf91178ed464c3eff5871b4b03c8f"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="a00413.html#ga7b78ef57d1b77933ab277ebe66c79d94">DebugLevel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00426.html#ga490cf91178ed464c3eff5871b4b03c8f">VERY_VERBOSE_DEBUG_LEVEL</a> = 1</td></tr>
<tr class="memdesc:ga490cf91178ed464c3eff5871b4b03c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The level of the very verbose debug stream.  <a href="a00426.html#ga490cf91178ed464c3eff5871b4b03c8f">More...</a><br /></td></tr>
<tr class="separator:ga490cf91178ed464c3eff5871b4b03c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdcf3b4c1aefae00afd3ecaf84f755bb"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="a00413.html#ga7b78ef57d1b77933ab277ebe66c79d94">DebugLevel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00426.html#gabdcf3b4c1aefae00afd3ecaf84f755bb">VERBOSE_DEBUG_LEVEL</a> = 2</td></tr>
<tr class="memdesc:gabdcf3b4c1aefae00afd3ecaf84f755bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The level of the verbose debug stream.  <a href="a00426.html#gabdcf3b4c1aefae00afd3ecaf84f755bb">More...</a><br /></td></tr>
<tr class="separator:gabdcf3b4c1aefae00afd3ecaf84f755bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabd88387e7eb826323b9f7d3a53a283e"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="a00413.html#ga7b78ef57d1b77933ab277ebe66c79d94">DebugLevel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00426.html#gaabd88387e7eb826323b9f7d3a53a283e">INFO_DEBUG_LEVEL</a> = 3</td></tr>
<tr class="memdesc:gaabd88387e7eb826323b9f7d3a53a283e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The level of the informative debug stream.  <a href="a00426.html#gaabd88387e7eb826323b9f7d3a53a283e">More...</a><br /></td></tr>
<tr class="separator:gaabd88387e7eb826323b9f7d3a53a283e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed2aba7a7e55b026716d5027406566a0"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="a00413.html#ga7b78ef57d1b77933ab277ebe66c79d94">DebugLevel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00426.html#gaed2aba7a7e55b026716d5027406566a0">WARN_DEBUG_LEVEL</a> = 4</td></tr>
<tr class="memdesc:gaed2aba7a7e55b026716d5027406566a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The level of the debug stream for warnings.  <a href="a00426.html#gaed2aba7a7e55b026716d5027406566a0">More...</a><br /></td></tr>
<tr class="separator:gaed2aba7a7e55b026716d5027406566a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fc828eb9bb6c6b6143034b9211d2b72"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="a00413.html#ga7b78ef57d1b77933ab277ebe66c79d94">DebugLevel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00426.html#ga4fc828eb9bb6c6b6143034b9211d2b72">GRAVE_DEBUG_LEVEL</a> = 5</td></tr>
<tr class="memdesc:ga4fc828eb9bb6c6b6143034b9211d2b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">The level of the debug stream for fatal errors.  <a href="a00426.html#ga4fc828eb9bb6c6b6143034b9211d2b72">More...</a><br /></td></tr>
<tr class="separator:ga4fc828eb9bb6c6b6143034b9211d2b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="a00428.html" title="Dune namespace.">Dune</a> namespace. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a51c6057d41509cc616fb60f483d7d6dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c6057d41509cc616fb60f483d7d6dd">&#9670;&nbsp;</a></span>CollectiveCommunication</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00428.html#a51c6057d41509cc616fb60f483d7d6dd">Dune::CollectiveCommunication</a> = typedef <a class="el" href="a01961.html">Communication</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c668a396cf5cd88bb7da3225787959a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c668a396cf5cd88bb7da3225787959a">&#9670;&nbsp;</a></span>SimdIndex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00428.html#a3c668a396cf5cd88bb7da3225787959a">Dune::SimdIndex</a> = typedef typename <a class="el" href="a02805.html">SimdIndexTypeTraits</a>&lt;V&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An simd vector of indices corresponding to a simd vector V. </p>
<p>lanes(T()) == lanes(SimdIndex&lt;T&gt;()) holds.</p>
<dl class="section note"><dt>Note</dt><dd>The size of the elements of a SimdIndex isn't very well-defined. Be careful. </dd></dl>

</div>
</div>
<a id="a846fa7e0d4cf9e70b148592224eb360f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a846fa7e0d4cf9e70b148592224eb360f">&#9670;&nbsp;</a></span>SimdMask</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00428.html#a846fa7e0d4cf9e70b148592224eb360f">Dune::SimdMask</a> = typedef typename <a class="el" href="a02809.html">SimdMaskTypeTraits</a>&lt;V&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A simd vector of truth values corresponding to a simd vector V. </p>
<p>lanes(T()) == lanes(SimdMask&lt;T&gt;()) holds. </p>

</div>
</div>
<a id="a7cab87dc8a3eff4191a99a1084d7b28e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cab87dc8a3eff4191a99a1084d7b28e">&#9670;&nbsp;</a></span>SimdScalar</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00428.html#a7cab87dc8a3eff4191a99a1084d7b28e">Dune::SimdScalar</a> = typedef typename <a class="el" href="a02797.html">SimdScalarTypeTraits</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9bbde85cc655ad122680398fef8fa5cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bbde85cc655ad122680398fef8fa5cd">&#9670;&nbsp;</a></span>ToUniquePtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00428.html#a9bbde85cc655ad122680398fef8fa5cd">Dune::ToUniquePtr</a> = typedef std::unique_ptr&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for <code>std::unique_ptr</code> introduced as transition wrapper. </p>
<dl class="deprecated"><dt><b><a class="el" href="a00399.html#_deprecated000016">Deprecated:</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="ae06816da928c17285e09ccb74357648b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae06816da928c17285e09ccb74357648b">&#9670;&nbsp;</a></span>TypeListEntry_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t i, class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00428.html#ae06816da928c17285e09ccb74357648b">Dune::TypeListEntry_t</a> = typedef typename <a class="el" href="a03025.html">TypeListElement</a>&lt;i, T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shortcut for TypeListElement&lt;i, T&gt;::type;. </p>

</div>
</div>
<a id="ab8e5f27ee5ff462d88e7eb109f143263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8e5f27ee5ff462d88e7eb109f143263">&#9670;&nbsp;</a></span>UniqueTypeList_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NonUniqueTypeList &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00428.html#ab8e5f27ee5ff462d88e7eb109f143263">Dune::UniqueTypeList_t</a> = typedef typename Impl::UniqueTypesHelper&lt;<a class="el" href="a00407.html#ga7e18d05cb5d1e95f0e7c7409ffe9689f">TypeList</a>, NonUniqueTypeList&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove duplicates from a <a class="el" href="a00407.html#ga7e18d05cb5d1e95f0e7c7409ffe9689f" title="A simple type list.">Dune::TypeList</a>. </p>
<p>For a given <a class="el" href="a00407.html#ga7e18d05cb5d1e95f0e7c7409ffe9689f" title="A simple type list.">Dune::TypeList&lt;T...&gt;</a> this is an alias for <a class="el" href="a00407.html#ga7e18d05cb5d1e95f0e7c7409ffe9689f" title="A simple type list.">Dune::TypeList&lt;S...&gt;</a>, where S... is generated by removing duplicate types from T... . </p>

</div>
</div>
<a id="a7f31a234ebc9fa02660570324eabde1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f31a234ebc9fa02660570324eabde1a">&#9670;&nbsp;</a></span>UniqueTypes_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class... &gt; class Target, class... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00428.html#a7f31a234ebc9fa02660570324eabde1a">Dune::UniqueTypes_t</a> = typedef typename Impl::UniqueTypesHelper&lt;Target, <a class="el" href="a00407.html#ga7e18d05cb5d1e95f0e7c7409ffe9689f">TypeList</a>&lt;T...&gt; &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove duplicates from a list of types. </p>
<p>For a given list of types T... instantiate Target&lt;S...&gt;, where S... is generated by removing duplicate types from T... . This is useful for std::variant which does not like to be instantiated with duplicate types. </p>

</div>
</div>
<a id="a05190548d101a946d1cab292cff5fdb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05190548d101a946d1cab292cff5fdb9">&#9670;&nbsp;</a></span>UnpackTypeList_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class... &gt; class Target, class TL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00428.html#a05190548d101a946d1cab292cff5fdb9">Dune::UnpackTypeList_t</a> = typedef typename Impl::UnpackTypeList&lt;Target, TL&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unpack <a class="el" href="a00407.html#ga7e18d05cb5d1e95f0e7c7409ffe9689f" title="A simple type list.">Dune::TypeList</a>. </p>
<p>For a given <a class="el" href="a00407.html#ga7e18d05cb5d1e95f0e7c7409ffe9689f" title="A simple type list.">Dune::TypeList&lt;T...&gt;</a> this is an alias for Target&lt;T...&gt;. </p>

</div>
</div>
<a id="aeeddbd17746ee9ac74ce286741916e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeddbd17746ee9ac74ce286741916e4c">&#9670;&nbsp;</a></span>ViolatedAlignmentHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00428.html#aeeddbd17746ee9ac74ce286741916e4c">Dune::ViolatedAlignmentHandler</a> = typedef std::function&lt;void(const char*, std::size_t, const void*)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>type of the handler called by <code><a class="el" href="a00428.html#a0e6c32c539889f324d46417dca3dfebe" title="called when an alignment violation is detected">violatedAlignment()</a></code> </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a587081ae4568cb94ed43b5dbaba7870e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a587081ae4568cb94ed43b5dbaba7870e">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ga587081ae4568cb94ed43b5dbaba7870ea7de84f476fd1d9f55ac5e2c25f252c3b"></a>implementationDefined&#160;</td><td class="fielddoc"><p>Dummy integral value used for documentation purposes. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="a00065.html">dune/common/documentation.hh</a>&gt;</span></div>
<div class="ttc" id="aa00065_html"><div class="ttname"><a href="a00065.html">documentation.hh</a></div><div class="ttdoc">Documentation related stuff.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="a01489.html" title="Dummy struct used for documentation purposes.">ImplementationDefined</a> </dd></dl>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a154ffbe53dd8b81b0937ec08481e6b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a154ffbe53dd8b81b0937ec08481e6b09">&#9670;&nbsp;</a></span>aligned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t align = debugAlignment, class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01353.html">AlignedNumber</a>&lt;T, align&gt; Dune::aligned </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>align a value to a certain alignment </p>

</div>
</div>
<a id="a231fdc968bf4b24f6c52031edd1fca96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a231fdc968bf4b24f6c52031edd1fca96">&#9670;&nbsp;</a></span>all_true()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t align&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Dune::all_true </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01353.html">AlignedNumber</a>&lt; bool, align &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ed24891986fbb8fea5cfee4c23a7173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ed24891986fbb8fea5cfee4c23a7173">&#9670;&nbsp;</a></span>any_true()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t align&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Dune::any_true </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01353.html">AlignedNumber</a>&lt; bool, align &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b55a8ff91fc039845da40a86486a007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b55a8ff91fc039845da40a86486a007">&#9670;&nbsp;</a></span>assertCallOnce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Dune::assertCallOnce </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make sure call_once() works and provide a helpful error message otherwise. </p>
<p>For call_once() to work, certain versions of libstdc++ need to be <em>linked</em> with -pthread or similar flags. If that is not the case, call_once() will throw an exception. This function checks that call_once() can indeed be used, i.e. that it does not throw an exception when it should not, and that the code does indeed get executed. If call_once() cannot be used, <a class="el" href="a00428.html#a3b55a8ff91fc039845da40a86486a007" title="Make sure call_once() works and provide a helpful error message otherwise.">assertCallOnce()</a> aborts the program with a helpful error message.</p>
<p>The check is only actually executed the first time <a class="el" href="a00428.html#a3b55a8ff91fc039845da40a86486a007" title="Make sure call_once() works and provide a helpful error message otherwise.">assertCallOnce()</a> is called.</p>
<p>The arguments <code>file</code> and <code>line</code> specify the filename and line number that should appear in the error message. They are ignored if <code>file</code> is 0. The argument <code>function</code> specifies the name of the function to appear in the error message. It is ignored if <code>function</code> is 0. </p>

</div>
</div>
<a id="a90c073df341c13a4da1c1522c60af0c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90c073df341c13a4da1c1522c60af0c3">&#9670;&nbsp;</a></span>assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::assign </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>masked <a class="el" href="a00432.html" title="Namespace for vectorization interface functions used by library developers.">Simd</a> assignment (scalar version) </p>
<p>Assign <code>src</code> to <code>dest</code> for those lanes where <code>mask</code> is true. </p>

</div>
</div>
<a id="ae548cdfab3c07fd32610c7b4da8f0eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae548cdfab3c07fd32610c7b4da8f0eb9">&#9670;&nbsp;</a></span>binomial() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr static T Dune::binomial </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calculate the binomial coefficient n over k as a constexpr </p>

</div>
</div>
<a id="a03852ec1241ecb93d746dc64bc0e41cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03852ec1241ecb93d746dc64bc0e41cc">&#9670;&nbsp;</a></span>binomial() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , T n, T k&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr static auto Dune::binomial </td>
          <td>(</td>
          <td class="paramtype">std::integral_constant&lt; T, n &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::integral_constant&lt; T, k &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calculate the binomial coefficient n over k as a constexpr </p>

</div>
</div>
<a id="a1169603932af226513ef054667a1657d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1169603932af226513ef054667a1657d">&#9670;&nbsp;</a></span>binomial() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , T n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr static auto Dune::binomial </td>
          <td>(</td>
          <td class="paramtype">std::integral_constant&lt; T, n &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::integral_constant&lt; T, n &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a33ac30656648b528235c913852c28ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ac30656648b528235c913852c28ac7">&#9670;&nbsp;</a></span>className() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Dune::className </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide the demangled class name of a type T as a string. </p>

</div>
</div>
<a id="a1d7665500285ebc74f89523cb8cf4fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d7665500285ebc74f89523cb8cf4fae">&#9670;&nbsp;</a></span>className() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Dune::className </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide the demangled class name of a given object as a string. </p>

</div>
</div>
<a id="ac6814315ac90b4c03e394688a30c63d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6814315ac90b4c03e394688a30c63d9">&#9670;&nbsp;</a></span>ComposeMPIOp() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::ComposeMPIOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01313.html">Max</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_MAX&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a428c0ab2a3d2fd8f57aaf06a51bcc558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a428c0ab2a3d2fd8f57aaf06a51bcc558">&#9670;&nbsp;</a></span>ComposeMPIOp() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::ComposeMPIOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01309.html">Min</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_MIN&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b1b0f5e50429120ba7fc972b022c620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1b0f5e50429120ba7fc972b022c620">&#9670;&nbsp;</a></span>ComposeMPIOp() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::ComposeMPIOp </td>
          <td>(</td>
          <td class="paramtype">std::multiplies&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_PROD&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a59a2fa61f1387001cea29f6934ff2316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a2fa61f1387001cea29f6934ff2316">&#9670;&nbsp;</a></span>ComposeMPIOp() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::ComposeMPIOp </td>
          <td>(</td>
          <td class="paramtype">std::plus&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_SUM&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa7df1a64bf1697e91502bce842535577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7df1a64bf1697e91502bce842535577">&#9670;&nbsp;</a></span>cond() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T1 Dune::cond </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>conditional evaluate </p>
<p>sometimes call immediate if, evaluates to</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (b)</div>
<div class="line">   <span class="keywordflow">return</span> v1;</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">   <span class="keywordflow">return</span> v2;</div>
</div><!-- fragment --><p>In contrast to if-then-else the cond function can also be evaluated for vector valued SIMD data types, see simd.hh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>boolean value </td></tr>
    <tr><td class="paramname">v1</td><td>value of b==true </td></tr>
    <tr><td class="paramname">v2</td><td>value of b==false </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e7b894879f459e9da9bfa1d8af0663a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e7b894879f459e9da9bfa1d8af0663a">&#9670;&nbsp;</a></span>cond() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t align&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01353.html">AlignedNumber</a>&lt;T, align&gt; Dune::cond </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01353.html">AlignedNumber</a>&lt; bool, align &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01353.html">AlignedNumber</a>&lt; T, align &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01353.html">AlignedNumber</a>&lt; T, align &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6ef69fa70938d4aa93d8e30d3813c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ef69fa70938d4aa93d8e30d3813c13">&#9670;&nbsp;</a></span>conjugateComplex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">K Dune::conjugateComplex </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute conjugate complex of x </p>

</div>
</div>
<a id="a9f0c3f5a28263a8dd6cb81d9cfd8c929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0c3f5a28263a8dd6cb81d9cfd8c929">&#9670;&nbsp;</a></span>defaultViolatedAlignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Dune::defaultViolatedAlignment </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>className</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>expectedAlignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>default alignment violation handler </p>
<p>Prints it's arguments on <code>stderr</code> and aborts. </p>

</div>
</div>
<a id="aa76832a917330622cdf531c2e6375f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa76832a917330622cdf531c2e6375f4c">&#9670;&nbsp;</a></span>doAssertCallOnce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Dune::doAssertCallOnce </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2d28f67ec2d74f14ec3ce3f9c27c221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2d28f67ec2d74f14ec3ce3f9c27c221">&#9670;&nbsp;</a></span>dotT()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Dune::dotT </td>
          <td>(</td>
          <td class="paramtype">const A &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const B &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(a*b)
  </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes an indefinite vector dot product for fundamental data types according to Petsc's VectTDot function: dotT(a,b) := a*b. </p>
<dl class="section see"><dt>See also</dt><dd><a href="http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Vec/VecTDot.html#VecTDot">http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Vec/VecTDot.html#VecTDot</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td></td></tr>
    <tr><td class="paramname">b</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a*b </dd></dl>

</div>
</div>
<a id="a87b977cae5e0e694b4b108bc1cab9434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b977cae5e0e694b4b108bc1cab9434">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_BINARY_OP() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_BINARY_OP </td>
          <td>(</td>
          <td class="paramtype">+&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa97415d63ec08e63ea87832efe86ddb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa97415d63ec08e63ea87832efe86ddb4">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_BINARY_OP() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_BINARY_OP </td>
          <td>(</td>
          <td class="paramtype">-&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abed8fafa25b2552e5a1b73ab0b48c87d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abed8fafa25b2552e5a1b73ab0b48c87d">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_BINARY_OP() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DUNE_SIMD_LOOP_BINARY_OP* Dune::DUNE_SIMD_LOOP_BINARY_OP </td>
          <td>(</td>
          <td class="paramtype">/&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad9fb3b7e66eca6930e91efcbee98b201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9fb3b7e66eca6930e91efcbee98b201">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_BINARY_OP() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DUNE_SIMD_LOOP_BINARY_OP&amp; Dune::DUNE_SIMD_LOOP_BINARY_OP </td>
          <td>(</td>
          <td class="paramtype">|&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab1786e12e4c3efe8a6117ddd99a8724a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1786e12e4c3efe8a6117ddd99a8724a">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_BITSHIFT_OP() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_BITSHIFT_OP </td>
          <td>(</td>
          <td class="paramtype">&lt;&lt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a250563e257d03a8336c3370f5caeaf84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a250563e257d03a8336c3370f5caeaf84">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_BITSHIFT_OP() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_BITSHIFT_OP </td>
          <td>(</td>
          <td class="paramtype">&gt;&gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a36c74f8a0a2706073686260f2dc63012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36c74f8a0a2706073686260f2dc63012">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_BOOLEAN_OP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DUNE_SIMD_LOOP_BOOLEAN_OP&amp;&amp; Dune::DUNE_SIMD_LOOP_BOOLEAN_OP </td>
          <td>(</td>
          <td class="paramtype">||&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acf083bd80799339ad4b7bc26009d1760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf083bd80799339ad4b7bc26009d1760">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_CMATH_UNARY_OP() <span class="overload">[1/34]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_CMATH_UNARY_OP </td>
          <td>(</td>
          <td class="paramtype">abs&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa360ad475ef9a72d1d29c5dabcc3bf73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa360ad475ef9a72d1d29c5dabcc3bf73">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_CMATH_UNARY_OP() <span class="overload">[2/34]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_CMATH_UNARY_OP </td>
          <td>(</td>
          <td class="paramtype">acos&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa08b81d847b50e9c9c4cee7c7d1f29cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa08b81d847b50e9c9c4cee7c7d1f29cf">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_CMATH_UNARY_OP() <span class="overload">[3/34]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_CMATH_UNARY_OP </td>
          <td>(</td>
          <td class="paramtype">acosh&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a09f392d978d7b88cf99fb06019e7bd40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f392d978d7b88cf99fb06019e7bd40">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_CMATH_UNARY_OP() <span class="overload">[4/34]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_CMATH_UNARY_OP </td>
          <td>(</td>
          <td class="paramtype">asin&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acbb4e14d3112e1de6b78b1210a991865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbb4e14d3112e1de6b78b1210a991865">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_CMATH_UNARY_OP() <span class="overload">[5/34]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_CMATH_UNARY_OP </td>
          <td>(</td>
          <td class="paramtype">asinh&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d537b66b859eb038d3820337c18fce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d537b66b859eb038d3820337c18fce9">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_CMATH_UNARY_OP() <span class="overload">[6/34]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_CMATH_UNARY_OP </td>
          <td>(</td>
          <td class="paramtype">atan&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adfbdf70bffe090b2531d64749b2c91c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfbdf70bffe090b2531d64749b2c91c4">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_CMATH_UNARY_OP() <span class="overload">[7/34]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_CMATH_UNARY_OP </td>
          <td>(</td>
          <td class="paramtype">atanh&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade26d1af9df16776724aa09f347d8856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade26d1af9df16776724aa09f347d8856">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_CMATH_UNARY_OP() <span class="overload">[8/34]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_CMATH_UNARY_OP </td>
          <td>(</td>
          <td class="paramtype">cbrt&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a26dcbb76cee8f0300798c309959d86ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26dcbb76cee8f0300798c309959d86ee">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_CMATH_UNARY_OP() <span class="overload">[9/34]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_CMATH_UNARY_OP </td>
          <td>(</td>
          <td class="paramtype">ceil&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6e5e1c5f79b6254d378e95cfd322a65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e5e1c5f79b6254d378e95cfd322a65">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_CMATH_UNARY_OP() <span class="overload">[10/34]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_CMATH_UNARY_OP </td>
          <td>(</td>
          <td class="paramtype">cos&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a680c29e54698d49501b3b2de4ce2ef47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a680c29e54698d49501b3b2de4ce2ef47">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_CMATH_UNARY_OP() <span class="overload">[11/34]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_CMATH_UNARY_OP </td>
          <td>(</td>
          <td class="paramtype">cosh&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5569c638beb6711c21a041ef6441bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5569c638beb6711c21a041ef6441bc7">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_CMATH_UNARY_OP() <span class="overload">[12/34]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_CMATH_UNARY_OP </td>
          <td>(</td>
          <td class="paramtype">erf&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a01ef7058640643efbe18ac57cc6eaf48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ef7058640643efbe18ac57cc6eaf48">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_CMATH_UNARY_OP() <span class="overload">[13/34]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_CMATH_UNARY_OP </td>
          <td>(</td>
          <td class="paramtype">erfc&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abe0541c3cddfa4781331ac0d05887d48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe0541c3cddfa4781331ac0d05887d48">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_CMATH_UNARY_OP() <span class="overload">[14/34]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_CMATH_UNARY_OP </td>
          <td>(</td>
          <td class="paramtype">exp&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4544c2a970c27e9ebb3cd7e2ea5ddc7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4544c2a970c27e9ebb3cd7e2ea5ddc7b">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_CMATH_UNARY_OP() <span class="overload">[15/34]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_CMATH_UNARY_OP </td>
          <td>(</td>
          <td class="paramtype">exp2&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7634e73ae107cad38d3c1c30d2be80bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7634e73ae107cad38d3c1c30d2be80bd">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_CMATH_UNARY_OP() <span class="overload">[16/34]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_CMATH_UNARY_OP </td>
          <td>(</td>
          <td class="paramtype">expm1&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a577485241fdec0624801d8463b5987ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a577485241fdec0624801d8463b5987ca">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_CMATH_UNARY_OP() <span class="overload">[17/34]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_CMATH_UNARY_OP </td>
          <td>(</td>
          <td class="paramtype">fabs&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a762a6b51f18dadfb4eda6047cf754c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762a6b51f18dadfb4eda6047cf754c64">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_CMATH_UNARY_OP() <span class="overload">[18/34]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_CMATH_UNARY_OP </td>
          <td>(</td>
          <td class="paramtype">floor&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a185f315ad3d194156672fdd4f299197d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a185f315ad3d194156672fdd4f299197d">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_CMATH_UNARY_OP() <span class="overload">[19/34]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_CMATH_UNARY_OP </td>
          <td>(</td>
          <td class="paramtype">lgamma&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ab0990a076434714f940464ebce3fe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ab0990a076434714f940464ebce3fe9">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_CMATH_UNARY_OP() <span class="overload">[20/34]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_CMATH_UNARY_OP </td>
          <td>(</td>
          <td class="paramtype">log&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af920243bd9e1e124679ead131489016e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af920243bd9e1e124679ead131489016e">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_CMATH_UNARY_OP() <span class="overload">[21/34]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_CMATH_UNARY_OP </td>
          <td>(</td>
          <td class="paramtype">log10&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a67dfa432cacbe104d169f89ea161f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a67dfa432cacbe104d169f89ea161f8">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_CMATH_UNARY_OP() <span class="overload">[22/34]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_CMATH_UNARY_OP </td>
          <td>(</td>
          <td class="paramtype">log1p&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ca741e8dd2d8cefaf43410eff2f1e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ca741e8dd2d8cefaf43410eff2f1e28">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_CMATH_UNARY_OP() <span class="overload">[23/34]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_CMATH_UNARY_OP </td>
          <td>(</td>
          <td class="paramtype">log2&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a83810e6d9502d807c8bd6500e398df7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83810e6d9502d807c8bd6500e398df7c">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_CMATH_UNARY_OP() <span class="overload">[24/34]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_CMATH_UNARY_OP </td>
          <td>(</td>
          <td class="paramtype">logb&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a10471153b4d96fc5e79f3b771b314ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10471153b4d96fc5e79f3b771b314ce2">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_CMATH_UNARY_OP() <span class="overload">[25/34]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_CMATH_UNARY_OP </td>
          <td>(</td>
          <td class="paramtype">nearbyint&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abc68537e003af1c6cc7bf154566008b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc68537e003af1c6cc7bf154566008b0">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_CMATH_UNARY_OP() <span class="overload">[26/34]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_CMATH_UNARY_OP </td>
          <td>(</td>
          <td class="paramtype">rint&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a38807b16fbd42153aea86c4ccdd6bb91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38807b16fbd42153aea86c4ccdd6bb91">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_CMATH_UNARY_OP() <span class="overload">[27/34]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_CMATH_UNARY_OP </td>
          <td>(</td>
          <td class="paramtype">round&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a79ab0dba2a12a0bc0a7944f9ae9f1f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ab0dba2a12a0bc0a7944f9ae9f1f29">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_CMATH_UNARY_OP() <span class="overload">[28/34]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_CMATH_UNARY_OP </td>
          <td>(</td>
          <td class="paramtype">sin&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a395094c113cdd8c2121111872085a735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a395094c113cdd8c2121111872085a735">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_CMATH_UNARY_OP() <span class="overload">[29/34]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_CMATH_UNARY_OP </td>
          <td>(</td>
          <td class="paramtype">sinh&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a160d3e17ed369ef66e6a5616b9d0f0ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a160d3e17ed369ef66e6a5616b9d0f0ed">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_CMATH_UNARY_OP() <span class="overload">[30/34]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_CMATH_UNARY_OP </td>
          <td>(</td>
          <td class="paramtype">sqrt&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae84860183d3c2955e5faa0d0cc32fb4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae84860183d3c2955e5faa0d0cc32fb4c">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_CMATH_UNARY_OP() <span class="overload">[31/34]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_CMATH_UNARY_OP </td>
          <td>(</td>
          <td class="paramtype">tan&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a98e1c8435b5fa7a7b196806e25a1425f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98e1c8435b5fa7a7b196806e25a1425f">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_CMATH_UNARY_OP() <span class="overload">[32/34]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_CMATH_UNARY_OP </td>
          <td>(</td>
          <td class="paramtype">tanh&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9e21698991978ed28373a29ebaa7676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e21698991978ed28373a29ebaa7676">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_CMATH_UNARY_OP() <span class="overload">[33/34]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_CMATH_UNARY_OP </td>
          <td>(</td>
          <td class="paramtype">tgamma&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2109020367318862d81752b29c3af75d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2109020367318862d81752b29c3af75d">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_CMATH_UNARY_OP() <span class="overload">[34/34]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_CMATH_UNARY_OP </td>
          <td>(</td>
          <td class="paramtype">trunc&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a17d65fea3f35e081fc433ef3366cba7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17d65fea3f35e081fc433ef3366cba7b">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_CMATH_UNARY_OP_WITH_RETURN() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_CMATH_UNARY_OP_WITH_RETURN </td>
          <td>(</td>
          <td class="paramtype">ilogb&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adfa38b41506a8e473669feddb7d1db8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa38b41506a8e473669feddb7d1db8c">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_CMATH_UNARY_OP_WITH_RETURN() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_CMATH_UNARY_OP_WITH_RETURN </td>
          <td>(</td>
          <td class="paramtype">llrint&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1749c45138975ab7d1e9a8f426b8811c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1749c45138975ab7d1e9a8f426b8811c">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_CMATH_UNARY_OP_WITH_RETURN() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_CMATH_UNARY_OP_WITH_RETURN </td>
          <td>(</td>
          <td class="paramtype">llround&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a50ac60761fb189996f0c6455c9deab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a50ac60761fb189996f0c6455c9deab">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_CMATH_UNARY_OP_WITH_RETURN() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_CMATH_UNARY_OP_WITH_RETURN </td>
          <td>(</td>
          <td class="paramtype">lrint&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a33060ecf7417568c97b04111620a1e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33060ecf7417568c97b04111620a1e28">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_CMATH_UNARY_OP_WITH_RETURN() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_CMATH_UNARY_OP_WITH_RETURN </td>
          <td>(</td>
          <td class="paramtype">lround&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aafcd80f1669dd6eee03a6ff6bbf85150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafcd80f1669dd6eee03a6ff6bbf85150">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_COMPARISON_OP() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_COMPARISON_OP </td>
          <td>(</td>
          <td class="paramtype">!&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aae72f618cfe280b17a988b83395f8927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae72f618cfe280b17a988b83395f8927">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_COMPARISON_OP() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_COMPARISON_OP </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a86b3da3ac3b884cf28ba5dc3dfee5652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b3da3ac3b884cf28ba5dc3dfee5652">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_COMPARISON_OP() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_COMPARISON_OP </td>
          <td>(</td>
          <td class="paramtype">&lt;=&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a16bec43001a47bb4b3d6a78aec88476b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16bec43001a47bb4b3d6a78aec88476b">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_COMPARISON_OP() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_COMPARISON_OP </td>
          <td>(</td>
          <td class="paramtype">&gt;=&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1853753d5f04e6743b59ef878437e2e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1853753d5f04e6743b59ef878437e2e1">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_STD_BINARY_OP() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_STD_BINARY_OP </td>
          <td>(</td>
          <td class="paramtype">max&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8461f4eb3f7d2309ba49e96ad8df6305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8461f4eb3f7d2309ba49e96ad8df6305">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_STD_BINARY_OP() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_STD_BINARY_OP </td>
          <td>(</td>
          <td class="paramtype">min&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a97b017f376d4eb1da79440f824f7ee55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b017f376d4eb1da79440f824f7ee55">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_STD_UNARY_OP() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_STD_UNARY_OP </td>
          <td>(</td>
          <td class="paramtype">imag&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5157b5aa1692d5a700cde7d8285ea99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5157b5aa1692d5a700cde7d8285ea99">&#9670;&nbsp;</a></span>DUNE_SIMD_LOOP_STD_UNARY_OP() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dune::DUNE_SIMD_LOOP_STD_UNARY_OP </td>
          <td>(</td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4eb5cbca2609d132ac6866b4960247b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4eb5cbca2609d132ac6866b4960247b">&#9670;&nbsp;</a></span>factorial() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr static T Dune::factorial </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calculate the factorial of n as a constexpr </p>

</div>
</div>
<a id="ad4be70f69e2f8bbda33075a643a23d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4be70f69e2f8bbda33075a643a23d6e">&#9670;&nbsp;</a></span>factorial() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , T n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr static auto Dune::factorial </td>
          <td>(</td>
          <td class="paramtype">std::integral_constant&lt; T, n &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calculate the factorial of n as a constexpr </p>

</div>
</div>
<a id="a422c8e50ed4f40b534187b8fb83fbf3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a422c8e50ed4f40b534187b8fb83fbf3d">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Reference , class PropertyMap , class Key &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Reference Dune::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a02441.html">RAPropertyMapHelper</a>&lt; Reference, PropertyMap &gt; &amp;&#160;</td>
          <td class="paramname"><em>pmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a60e5c2863bb763524cbc65eaea515adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e5c2863bb763524cbc65eaea515adb">&#9670;&nbsp;</a></span>getMPIData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Dune::getMPIData </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4f0199c109bde1698fb5279a414d01a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4f0199c109bde1698fb5279a414d01a">&#9670;&nbsp;</a></span>hash_combine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Dune::hash_combine </td>
          <td>(</td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the hash value of arg and combines it in-place with seed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>The hash value that will be combined with the hash of arg. </td></tr>
    <tr><td class="paramname">arg</td><td>The object for which to calculate a hash value and combine it with seed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e45658b7c63f546c3c0897608d9d23d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e45658b7c63f546c3c0897608d9d23d">&#9670;&nbsp;</a></span>hash_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Dune::hash_range </td>
          <td>(</td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hashes all elements in the range [first,last) and returns the combined hash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator pointing to the first object to hash. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator pointing one past the last object to hash.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of hashing all objects in the range and combining them using <a class="el" href="a00428.html#aa4f0199c109bde1698fb5279a414d01a" title="Calculates the hash value of arg and combines it in-place with seed.">hash_combine()</a> in sequential fashion, starting with seed 0. </dd></dl>

</div>
</div>
<a id="ab09a051cb1381c71f6c91032cd2ba754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab09a051cb1381c71f6c91032cd2ba754">&#9670;&nbsp;</a></span>hash_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Dune::hash_range </td>
          <td>(</td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hashes all elements in the range [first,last) and combines the hashes in-place with seed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>Start value that will be combined with the hash values of all objects in the range using <a class="el" href="a00428.html#aa4f0199c109bde1698fb5279a414d01a" title="Calculates the hash value of arg and combines it in-place with seed.">hash_combine()</a> in sequential fashion. </td></tr>
    <tr><td class="paramname">first</td><td>Iterator pointing to the first ojbect to hash. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator pointing one past the last object to hash. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf9e4364af213c448afdf072eea1b913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf9e4364af213c448afdf072eea1b913">&#9670;&nbsp;</a></span>isAligned()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Dune::isAligned </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check whether an address conforms to the given alignment </p>

</div>
</div>
<a id="a87be73bb4b219361645afcce2eb5b7a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87be73bb4b219361645afcce2eb5b7a4">&#9670;&nbsp;</a></span>lane() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Dune::lane </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>access a lane of a simd vector (scalar version) </p>

</div>
</div>
<a id="af7ebdb04638aaaa3011903e9cd31444d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ebdb04638aaaa3011903e9cd31444d">&#9670;&nbsp;</a></span>lane() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; Dune::lane </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>access a lane of a simd vector (scalar version) </p>

</div>
</div>
<a id="afc2c37fe2704917536f5263272d0a7e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc2c37fe2704917536f5263272d0a7e2">&#9670;&nbsp;</a></span>lanes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Dune::lanes </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the number of lanes of a simd vector (scalar version) </p>

</div>
</div>
<a id="ade7db16fea4d4d85c90115bf94e4d7f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade7db16fea4d4d85c90115bf94e4d7f5">&#9670;&nbsp;</a></span>makeToUnique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;T&gt; Dune::makeToUnique </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for <code>std::make_unique</code> introduced as transition wrapper. </p>
<dl class="deprecated"><dt><b><a class="el" href="a00399.html#_deprecated000017">Deprecated:</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="ae982edb333af3a1f24fe324cc593be0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae982edb333af3a1f24fe324cc593be0d">&#9670;&nbsp;</a></span>makeTupleVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto Dune::makeTupleVector </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;...&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae23cfd2094b38ad5889b56de92d1f019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae23cfd2094b38ad5889b56de92d1f019">&#9670;&nbsp;</a></span>max_value() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t align&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Dune::max_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01353.html">AlignedNumber</a>&lt; T, align &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaf05bafe739a71f1e7f30780dbae4fa05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf05bafe739a71f1e7f30780dbae4fa05">&#9670;&nbsp;</a></span>max_value() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt;!IsIterable&lt; T &gt;::value, int &gt;::type  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; Dune::max_value </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af97af7156507b5bbb3433e3f7e5a15a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af97af7156507b5bbb3433e3f7e5a15a7">&#9670;&nbsp;</a></span>min_value() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t align&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Dune::min_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01353.html">AlignedNumber</a>&lt; T, align &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaa56de4535eff55ba6d5e418fd26b686c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa56de4535eff55ba6d5e418fd26b686c">&#9670;&nbsp;</a></span>min_value() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt;!IsIterable&lt; T &gt;::value, int &gt;::type  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; Dune::min_value </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a336418ea10c30e25ece655d63bdf3d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a336418ea10c30e25ece655d63bdf3d84">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool Dune::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01901.html">MallocAllocator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01901.html">MallocAllocator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check whether allocators are not equivalent </p>

</div>
</div>
<a id="a02c039e6b551a3771cc8c60e84e9bcdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c039e6b551a3771cc8c60e84e9bcdc">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Dune::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01957.html">No_Comm</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01957.html">No_Comm</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison operator for MPI compatibility. </p>
<p>Always returns false. </p>

</div>
</div>
<a id="ae1640f7fd69aac13c49a1750bdfa8ac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1640f7fd69aac13c49a1750bdfa8ac5">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Dune::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a02121.html">Interface</a> &amp;&#160;</td>
          <td class="paramname"><em>interface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5fcca471c1f5c5909f0b8fe316e6dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5fcca471c1f5c5909f0b8fe316e6dcf">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TG , typename TA &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Dune::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a02213.html">RemoteIndex</a>&lt; TG, TA &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga0a147b2ec114b90e57366216029b40bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a147b2ec114b90e57366216029b40bc">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class V1 , class R1 , class D , class T2 , class V2 , class R2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_convertible&lt;T1,T2&gt;::value &amp;&amp; !std::is_convertible&lt;T2,T1&gt;::value, bool&gt;::type Dune::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01877.html">BidirectionalIteratorFacade</a>&lt; T1, V1, R1, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01877.html">BidirectionalIteratorFacade</a>&lt; T2, V2, R2, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks for equality. </p>
<p>This operation is only defined if either T1 is convertible to T2, and T2 is not convetible to T1. Otherwise the operator is removed from the overload set since the enable_if for the return type yield an invalid type expression. </p>

</div>
</div>
<a id="a0b225faa806a6ba0744fd93ce17b447a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b225faa806a6ba0744fd93ce17b447a">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool Dune::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01901.html">MallocAllocator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01901.html">MallocAllocator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check whether allocators are equivalent </p>

</div>
</div>
<a id="aee0776cda12fa2fc183e2796bcc23743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee0776cda12fa2fc183e2796bcc23743">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Dune::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01957.html">No_Comm</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a01957.html">No_Comm</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison operator for MPI compatibility. </p>
<p>Always returns true. </p>

</div>
</div>
<a id="a43fb9e50cbb18051ddf5497465ccf734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43fb9e50cbb18051ddf5497465ccf734">&#9670;&nbsp;</a></span>power()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Mantissa , class Exponent &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Mantissa Dune::power </td>
          <td>(</td>
          <td class="paramtype">Mantissa&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Exponent&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="a02397.html" title="Compute power for a run-time mantissa and a compile-time integer exponent.">Power</a> method for integer exponents. </p>
<dl class="section note"><dt>Note</dt><dd>Make sure that Mantissa is a non-integer type when using negative exponents! </dd></dl>

</div>
</div>
<a id="a2dc4d3a226776723750b848ae303a11a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dc4d3a226776723750b848ae303a11a">&#9670;&nbsp;</a></span>put()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Reference , class PropertyMap , class Key , class Value &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Dune::put </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a02441.html">RAPropertyMapHelper</a>&lt; Reference, PropertyMap &gt; &amp;&#160;</td>
          <td class="paramname"><em>pmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gab64fac9d63a7009ccfa29af11ec5fc1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab64fac9d63a7009ccfa29af11ec5fc1c">&#9670;&nbsp;</a></span>range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::enable_if_t&lt; std::is_enum&lt; std::decay_t&lt; T &gt;&gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a02473.html">IntegralRange</a>&lt;std::underlying_type_t&lt;std::decay_t&lt;T&gt; &gt; &gt; Dune::range </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>to</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac1712a3bb38c829a2c339355cdb28133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1712a3bb38c829a2c339355cdb28133">&#9670;&nbsp;</a></span>sign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int Dune::sign </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the sign of the value. </p>

</div>
</div>
<a id="a0ee36ec1f6416afa0487a8a224376e34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ee36ec1f6416afa0487a8a224376e34">&#9670;&nbsp;</a></span>stackobject_to_shared_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; T &gt; stackobject_to_shared_ptr </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a shared_ptr for a stack-allocated object. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="a00290.html">dune/common/shared_ptr.hh</a>&gt;</span></div>
<div class="ttc" id="aa00290_html"><div class="ttname"><a href="a00290.html">shared_ptr.hh</a></div><div class="ttdoc">This file implements several utilities related to std::shared_ptr.</div></div>
</div><!-- fragment --><p>Usage: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> i = 10;</div>
<div class="line">std::shared_ptr&lt;int&gt; pi = <a class="code" href="a00428.html#a0ee36ec1f6416afa0487a8a224376e34">stackobject_to_shared_ptr</a>(i);</div>
<div class="ttc" id="aa00428_html_a0ee36ec1f6416afa0487a8a224376e34"><div class="ttname"><a href="a00428.html#a0ee36ec1f6416afa0487a8a224376e34">Dune::stackobject_to_shared_ptr</a></div><div class="ttdeci">std::shared_ptr&lt; T &gt; stackobject_to_shared_ptr(T &amp;t)</div><div class="ttdoc">Create a shared_ptr for a stack-allocated object.</div><div class="ttdef"><b>Definition:</b> shared_ptr.hh:70</div></div>
</div><!-- fragment --><p> The <code>std::shared_ptr</code> points to the object on the stack, but its deleter is set to an instance of <code><a class="el" href="a02549.html" title="implements the Deleter concept of shared_ptr without deleting anything">null_deleter</a></code> so that nothing happens when the <code>shared_ptr</code> is destroyed.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a02549.html" title="implements the Deleter concept of shared_ptr without deleting anything">null_deleter</a> </dd></dl>

</div>
</div>
<a id="a8cc9a46e5ec32e3b68c3071cf1a25361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cc9a46e5ec32e3b68c3071cf1a25361">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::swap </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a413e66bc54b93298e15afc7af231e924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a413e66bc54b93298e15afc7af231e924">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Dune::transpose </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a wrapper modelling the transposed matrix. </p>
<p>Currently the wrapper only implements </p><div class="fragment"><div class="line"><span class="keyword">auto</span> c = a*<a class="code" href="a00428.html#a413e66bc54b93298e15afc7af231e924">transpose</a>(b);</div>
<div class="ttc" id="aa00428_html_a413e66bc54b93298e15afc7af231e924"><div class="ttname"><a href="a00428.html#a413e66bc54b93298e15afc7af231e924">Dune::transpose</a></div><div class="ttdeci">auto transpose(const Matrix &amp;matrix)</div><div class="ttdoc">Create a wrapper modelling the transposed matrix.</div><div class="ttdef"><b>Definition:</b> transpose.hh:70</div></div>
</div><!-- fragment --><p> if a is a <a class="el" href="a01401.html" title="A dense n x m matrix.">FieldMatrix</a> of appropriate size. This is optimal even for sparse b because it only relies on calling b.mv(a[i], c[i]) for the rows of a.</p>
<p>Since the created object only stores a reference to the wrapped matrix, it cannot be modified and should not be stored but used directly. </p>

</div>
</div>
<a id="a595be06b36830646a9a348d33b7c51c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a595be06b36830646a9a348d33b7c51c1">&#9670;&nbsp;</a></span>uniqueTypeList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto Dune::uniqueTypeList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00407.html#ga7e18d05cb5d1e95f0e7c7409ffe9689f">TypeList</a>&lt; T... &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove duplicates from a <a class="el" href="a00407.html#ga7e18d05cb5d1e95f0e7c7409ffe9689f" title="A simple type list.">Dune::TypeList</a>. </p>
<p>For a given <a class="el" href="a00407.html#ga7e18d05cb5d1e95f0e7c7409ffe9689f" title="A simple type list.">Dune::TypeList&lt;T...&gt;</a> this return a <a class="el" href="a00407.html#ga7e18d05cb5d1e95f0e7c7409ffe9689f" title="A simple type list.">Dune::TypeList&lt;S...&gt;</a>, where S... is generated by removing duplicate types from T... . </p>

</div>
</div>
<a id="a0e6c32c539889f324d46417dca3dfebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e6c32c539889f324d46417dca3dfebe">&#9670;&nbsp;</a></span>violatedAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Dune::violatedAlignment </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>className</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>expectedAlignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>called when an alignment violation is detected </p>
<p><code>className</code> Name of the class whose alignment was violated <code>expectedAlignment</code> The (over-)alignment that the class expected <code>address</code> The address the class actually found itself at.</p>
<p>The main purpose of the function is to serve as a convenient breakpoint for debugging &ndash; which is why we put it in an external compilation unit so it isn't inlined. </p>

</div>
</div>
<a id="abeb716c21bff1ff9559bb62074d90e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb716c21bff1ff9559bb62074d90e86">&#9670;&nbsp;</a></span>violatedAlignmentHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00428.html#aeeddbd17746ee9ac74ce286741916e4c">ViolatedAlignmentHandler</a> &amp; Dune::violatedAlignmentHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>access the handler called by <code><a class="el" href="a00428.html#a0e6c32c539889f324d46417dca3dfebe" title="called when an alignment violation is detected">violatedAlignment()</a></code> </p>
<p>This may be used to obtain the handler for the purpose of calling, or for saving it somewhere to restore it later. It may also be used to set the handler simply by assigning a new handler. Setting the handler races with other accesses. </p>

</div>
</div>
<a id="abc8b6bf5f8910e34829136293000c29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc8b6bf5f8910e34829136293000c29e">&#9670;&nbsp;</a></span>wrap_or_move() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Dune::wrap_or_move </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Capture R-value reference to shared_ptr. </p>
<p>This will store a copy of the passed object in a shared_ptr.</p>
<p>The two overloads of wrap_or_move are intended to capture references and temporaries in a unique way without creating copies and only moving if necessary.</p>
<p>Be careful: Only use this function if you are aware of it's implications. You can e.g. easily end up storing a reference to a temporary if you use this inside of another function without perfect forwarding. </p>

</div>
</div>
<a id="ab3669cc3fbff695e5ae793ab49f1ca8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3669cc3fbff695e5ae793ab49f1ca8a">&#9670;&nbsp;</a></span>wrap_or_move() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Dune::wrap_or_move </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Capture L-value reference to std::shared_ptr. </p>
<p>This will store a pointer for the passed reference in a non-owning std::shared_ptr.</p>
<p>The two overloads of wrap_or_move are intended to capture references and temporaries in a unique way without creating copies and only moving if necessary.</p>
<p>Be careful: Only use this function if you are aware of it's implications. You can e.g. easily end up storing a reference to a temporary if you use this inside of another function without perfect forwarding. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a6560bc030b518cf2da62724367f6ccdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6560bc030b518cf2da62724367f6ccdc">&#9670;&nbsp;</a></span>debugAlignment</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto Dune::debugAlignment = 2*alignof(std::max_align_t)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>an alignment large enough to trigger alignment errors </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
