<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>dune-functions: Utility</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">dune-functions
   &#160;<span id="projectnumber">2.8.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Utility</div>  </div>
</div><!--header-->
<div class="contents">

<p>Various helper classes and functions.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Utility:</div>
<div class="dyncontent">
<div class="center"><img src="a00203.png" border="0" usemap="#aa00203" alt=""/></div>
<map name="aa00203" id="aa00203">
<area shape="rect" href="a00204.html" title="Helper classes for implementing type&#45;erased interfaces." alt="" coords="284,5,396,45"/>
<area shape="rect" title="Various helper classes and functions." alt="" coords="5,13,60,38"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:a00204"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html">Utilities for type-erasure</a></td></tr>
<tr class="memdesc:a00204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper classes for implementing type-erased interfaces. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01228.html">Dune::Functions::PolymorphicType&lt; Interface &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class with polymorphic type boiler plate code.  <a href="a01228.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01252.html">Dune::Functions::PolymorphicSmallObject&lt; Base, bufferSize &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper providing small object optimization with polymorphic types.  <a href="a01252.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01256.html">Dune::Functions::ReservedDeque&lt; T, n &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A double-ended queue (deque) class with statically reserved memory.  <a href="a01256.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01284.html">Dune::Functions::UniformNodeVisitor&lt; SimpleNodeVisitorImp, leafOnly &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mixin for visitors that should apply the same action on all nodes.  <a href="a01284.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01288.html">Dune::Functions::TreeData&lt; T, ND, LO &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container allowing to attach data to each node of a tree.  <a href="a01288.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01304.html">Dune::Functions::HasStaticSize&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if type is a statically sized container.  <a href="a01304.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01308.html">Dune::Functions::StaticSize&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain size of statically sized container.  <a href="a01308.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01356.html">Dune::Functions::LastType&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get last entry of type list.  <a href="a01356.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01368.html">Dune::Functions::RotateTuple&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate type list by one, such that last entry is moved to first position.  <a href="a01368.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga673247dd74bcdd9e5acfc7735faf8a5b"><td class="memTemplParams" colspan="2">template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:ga673247dd74bcdd9e5acfc7735faf8a5b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00203.html#ga673247dd74bcdd9e5acfc7735faf8a5b">Dune::Functions::enableIfConstructible</a> = typename std::enable_if&lt; std::is_constructible&lt; T, Args... &gt;::value, int &gt;::type</td></tr>
<tr class="memdesc:ga673247dd74bcdd9e5acfc7735faf8a5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to constrain forwarding constructors.  <a href="a00203.html#ga673247dd74bcdd9e5acfc7735faf8a5b">More...</a><br /></td></tr>
<tr class="separator:ga673247dd74bcdd9e5acfc7735faf8a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga047a2180b455bfa030fba76eb6270952"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class T, class ArgTuple &gt; </td></tr>
<tr class="memitem:ga047a2180b455bfa030fba76eb6270952"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00203.html#ga047a2180b455bfa030fba76eb6270952">Dune::Functions::ExpandTuple</a> = typename Imp::ExpandTupleHelper&lt; T, ArgTuple &gt;::Type</td></tr>
<tr class="memdesc:ga047a2180b455bfa030fba76eb6270952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand tuple arguments as template arguments.  <a href="a00203.html#ga047a2180b455bfa030fba76eb6270952">More...</a><br /></td></tr>
<tr class="separator:ga047a2180b455bfa030fba76eb6270952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ce77345fbee606e5ac22aeef7d109d6"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class F, class... Tuples&gt; </td></tr>
<tr class="memitem:ga1ce77345fbee606e5ac22aeef7d109d6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00203.html#ga1ce77345fbee606e5ac22aeef7d109d6">Dune::Functions::TransformTuple</a> = typename Imp::TransformTupleHelper&lt; F, Tuples... &gt;::Type</td></tr>
<tr class="memdesc:ga1ce77345fbee606e5ac22aeef7d109d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform tuple types argument using type-functor.  <a href="a00203.html#ga1ce77345fbee606e5ac22aeef7d109d6">More...</a><br /></td></tr>
<tr class="separator:ga1ce77345fbee606e5ac22aeef7d109d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2bc5056bab5babdfa8a82409665f5a26"><td class="memTemplParams" colspan="2">template&lt;class F , class... Args&gt; </td></tr>
<tr class="memitem:ga2bc5056bab5babdfa8a82409665f5a26"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00203.html#ga2bc5056bab5babdfa8a82409665f5a26">Dune::Functions::Concept::isCallable</a> ()</td></tr>
<tr class="memdesc:ga2bc5056bab5babdfa8a82409665f5a26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if f is callable with given argument list.  <a href="a00203.html#ga2bc5056bab5babdfa8a82409665f5a26">More...</a><br /></td></tr>
<tr class="separator:ga2bc5056bab5babdfa8a82409665f5a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga437efff5877892cd3a24c660179b32e9"><td class="memTemplParams" colspan="2">template&lt;class F , class... Args&gt; </td></tr>
<tr class="memitem:ga437efff5877892cd3a24c660179b32e9"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00203.html#ga437efff5877892cd3a24c660179b32e9">Dune::Functions::Concept::isCallable</a> (F &amp;&amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga437efff5877892cd3a24c660179b32e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if f is callable with given argument list.  <a href="a00203.html#ga437efff5877892cd3a24c660179b32e9">More...</a><br /></td></tr>
<tr class="separator:ga437efff5877892cd3a24c660179b32e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2226fe3a86eb176df27c9801a98a10ae"><td class="memTemplParams" colspan="2">template&lt;class C , class I , class F , typename std::enable_if&lt; Dune::models&lt; Imp::Concept::HasDynamicIndexAccess&lt; I &gt;, C &gt;(), int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ga2226fe3a86eb176df27c9801a98a10ae"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00203.html#ga2226fe3a86eb176df27c9801a98a10ae">Dune::Functions::hybridIndexAccess</a> (C &amp;&amp;c, const I &amp;i, F &amp;&amp;f) -&gt; decltype(f(c[i]))</td></tr>
<tr class="memdesc:ga2226fe3a86eb176df27c9801a98a10ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide operator[] index-access for containers.  <a href="a00203.html#ga2226fe3a86eb176df27c9801a98a10ae">More...</a><br /></td></tr>
<tr class="separator:ga2226fe3a86eb176df27c9801a98a10ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd5106817636cc5542dc4e9a1817551b"><td class="memTemplParams" colspan="2">template&lt;class Result , class C , class MultiIndex &gt; </td></tr>
<tr class="memitem:gabd5106817636cc5542dc4e9a1817551b"><td class="memTemplItemLeft" align="right" valign="top">Result&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00203.html#gabd5106817636cc5542dc4e9a1817551b">Dune::Functions::hybridMultiIndexAccess</a> (C &amp;&amp;c, const MultiIndex &amp;index)</td></tr>
<tr class="memdesc:gabd5106817636cc5542dc4e9a1817551b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide multi-index access by chaining operator[].  <a href="a00203.html#gabd5106817636cc5542dc4e9a1817551b">More...</a><br /></td></tr>
<tr class="separator:gabd5106817636cc5542dc4e9a1817551b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9aaec884c080483fea267d1098f81590"><td class="memTemplParams" colspan="2">template&lt;class C , class MultiIndex , class IsFinal &gt; </td></tr>
<tr class="memitem:ga9aaec884c080483fea267d1098f81590"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00203.html#ga9aaec884c080483fea267d1098f81590">Dune::Functions::resolveDynamicMultiIndex</a> (C &amp;&amp;c, const MultiIndex &amp;multiIndex, const IsFinal &amp;isFinal)</td></tr>
<tr class="memdesc:ga9aaec884c080483fea267d1098f81590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide multi-index access by chaining operator[].  <a href="a00203.html#ga9aaec884c080483fea267d1098f81590">More...</a><br /></td></tr>
<tr class="separator:ga9aaec884c080483fea267d1098f81590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89fbdd009241b14e86b4fff7ba208a04"><td class="memTemplParams" colspan="2">template&lt;class C , class MultiIndex &gt; </td></tr>
<tr class="memitem:ga89fbdd009241b14e86b4fff7ba208a04"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00203.html#ga89fbdd009241b14e86b4fff7ba208a04">Dune::Functions::resolveDynamicMultiIndex</a> (C &amp;&amp;c, const MultiIndex &amp;multiIndex)</td></tr>
<tr class="memdesc:ga89fbdd009241b14e86b4fff7ba208a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide multi-index access by chaining operator[].  <a href="a00203.html#ga89fbdd009241b14e86b4fff7ba208a04">More...</a><br /></td></tr>
<tr class="separator:ga89fbdd009241b14e86b4fff7ba208a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cc6af2842348271c242c048e0411637"><td class="memTemplParams" colspan="2">template&lt;class C , class MultiIndex &gt; </td></tr>
<tr class="memitem:ga4cc6af2842348271c242c048e0411637"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00203.html#ga4cc6af2842348271c242c048e0411637">Dune::Functions::resolveStaticMultiIndex</a> (C &amp;&amp;c, const MultiIndex &amp;multiIndex)</td></tr>
<tr class="memdesc:ga4cc6af2842348271c242c048e0411637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide multi-index access by chaining operator[].  <a href="a00203.html#ga4cc6af2842348271c242c048e0411637">More...</a><br /></td></tr>
<tr class="separator:ga4cc6af2842348271c242c048e0411637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa625ea93bc3285b8a09c9267302386ec"><td class="memTemplParams" colspan="2">template&lt;std::size_t begin_t, std::size_t end_t, class F , class... Args&gt; </td></tr>
<tr class="memitem:gaa625ea93bc3285b8a09c9267302386ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00203.html#gaa625ea93bc3285b8a09c9267302386ec">Dune::Functions::staticFindInRange</a> (F &amp;&amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:gaa625ea93bc3285b8a09c9267302386ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static find loop.  <a href="a00203.html#gaa625ea93bc3285b8a09c9267302386ec">More...</a><br /></td></tr>
<tr class="separator:gaa625ea93bc3285b8a09c9267302386ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7d45de6c68fce943e6924403389d234"><td class="memTemplParams" colspan="2">template&lt;std::size_t end, class F , class size_type , class... Args&gt; </td></tr>
<tr class="memitem:gac7d45de6c68fce943e6924403389d234"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00203.html#gac7d45de6c68fce943e6924403389d234">Dune::Functions::forwardAsStaticIndex</a> (const size_type &amp;i, F &amp;&amp;f, Args &amp;&amp;... args) -&gt; decltype(f(Dune::Indices::_0, std::forward&lt; Args &gt;(args)...))</td></tr>
<tr class="memdesc:gac7d45de6c68fce943e6924403389d234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform dynamic index to static index_constant.  <a href="a00203.html#gac7d45de6c68fce943e6924403389d234">More...</a><br /></td></tr>
<tr class="separator:gac7d45de6c68fce943e6924403389d234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e5fbe8e1330cdfab9eddd5962682b4c"><td class="memTemplParams" colspan="2">template&lt;class F , class... T&gt; </td></tr>
<tr class="memitem:ga4e5fbe8e1330cdfab9eddd5962682b4c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00203.html#ga4e5fbe8e1330cdfab9eddd5962682b4c">Dune::Functions::transformTuple</a> (F &amp;&amp;f, const std::tuple&lt; T... &gt; &amp;tuple) -&gt; decltype(Imp::transformTupleHelper(std::forward&lt; F &gt;(f), tuple, std::index_sequence_for&lt; T... &gt;{}))</td></tr>
<tr class="memdesc:ga4e5fbe8e1330cdfab9eddd5962682b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform tuple value using a functor.  <a href="a00203.html#ga4e5fbe8e1330cdfab9eddd5962682b4c">More...</a><br /></td></tr>
<tr class="separator:ga4e5fbe8e1330cdfab9eddd5962682b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae663a5bfd683c8a0844bb974807d8f52"><td class="memTemplParams" colspan="2">template&lt;class F , class... T1, class... T2&gt; </td></tr>
<tr class="memitem:gae663a5bfd683c8a0844bb974807d8f52"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00203.html#gae663a5bfd683c8a0844bb974807d8f52">Dune::Functions::transformTuple</a> (F &amp;&amp;f, const std::tuple&lt; T1... &gt; &amp;tuple1, const std::tuple&lt; T2... &gt; &amp;tuple2) -&gt; decltype(Imp::transformTupleHelper(std::forward&lt; F &gt;(f), tuple1, tuple2, std::index_sequence_for&lt; T1... &gt;{}))</td></tr>
<tr class="memdesc:gae663a5bfd683c8a0844bb974807d8f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform tuple value using a binary functor.  <a href="a00203.html#gae663a5bfd683c8a0844bb974807d8f52">More...</a><br /></td></tr>
<tr class="separator:gae663a5bfd683c8a0844bb974807d8f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d55c56e78792c4b169c18d875a60935"><td class="memTemplParams" colspan="2">template&lt;class Expression &gt; </td></tr>
<tr class="memitem:ga7d55c56e78792c4b169c18d875a60935"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00203.html#ga7d55c56e78792c4b169c18d875a60935">Dune::Functions::callableCheck</a> (Expression f)</td></tr>
<tr class="memdesc:ga7d55c56e78792c4b169c18d875a60935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a predicate for checking validity of expressions.  <a href="a00203.html#ga7d55c56e78792c4b169c18d875a60935">More...</a><br /></td></tr>
<tr class="separator:ga7d55c56e78792c4b169c18d875a60935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed02f0c6f78e0d71e09d9bc6a29347c4"><td class="memTemplParams" colspan="2">template&lt;class Check &gt; </td></tr>
<tr class="memitem:gaed02f0c6f78e0d71e09d9bc6a29347c4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00203.html#gaed02f0c6f78e0d71e09d9bc6a29347c4">Dune::Functions::negatePredicate</a> (Check check)</td></tr>
<tr class="memdesc:gaed02f0c6f78e0d71e09d9bc6a29347c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate given predicate.  <a href="a00203.html#gaed02f0c6f78e0d71e09d9bc6a29347c4">More...</a><br /></td></tr>
<tr class="separator:gaed02f0c6f78e0d71e09d9bc6a29347c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Various helper classes and functions. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga673247dd74bcdd9e5acfc7735faf8a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga673247dd74bcdd9e5acfc7735faf8a5b">&#9670;&nbsp;</a></span>enableIfConstructible</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00203.html#ga673247dd74bcdd9e5acfc7735faf8a5b">Dune::Functions::enableIfConstructible</a> = typedef typename std::enable_if&lt; std::is_constructible&lt;T, Args...&gt;::value, int&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper to constrain forwarding constructors. </p>
<p>Helper typedef to remove constructor with forwarding reference from overload set for type is not constructible from argument list. This is useful to avoid failng forwarding constructors for base classes or members. </p>

</div>
</div>
<a id="ga047a2180b455bfa030fba76eb6270952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga047a2180b455bfa030fba76eb6270952">&#9670;&nbsp;</a></span>ExpandTuple</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class... &gt; class T, class ArgTuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00203.html#ga047a2180b455bfa030fba76eb6270952">Dune::Functions::ExpandTuple</a> = typedef typename Imp::ExpandTupleHelper&lt;T, ArgTuple&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand tuple arguments as template arguments. </p>
<p>This template alias refers to T&lt;Args...&gt; if ArgTuple is a std::tuple&lt;Args...&gt;.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A variadic template </td></tr>
    <tr><td class="paramname">ArgTuple</td><td>A tuple of types </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1ce77345fbee606e5ac22aeef7d109d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ce77345fbee606e5ac22aeef7d109d6">&#9670;&nbsp;</a></span>TransformTuple</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class... &gt; class F, class... Tuples&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00203.html#ga1ce77345fbee606e5ac22aeef7d109d6">Dune::Functions::TransformTuple</a> = typedef typename Imp::TransformTupleHelper&lt;F, Tuples...&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform tuple types argument using type-functor. </p>
<p>This is a template alias for a tuple whose i-th type is given by F&lt;T1i,...,TMi&gt; where T1i,...,TMi are the i-th types of the 1,...,M-th tuple of the given tuple list Tuples. Currently only M=1,2 are supported. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>A template alias mapping 1,...,sizeof...(ArgTuple) types to a new one </td></tr>
    <tr><td class="paramname">Tuples</td><td>A list of tuples </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga7d55c56e78792c4b169c18d875a60935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d55c56e78792c4b169c18d875a60935">&#9670;&nbsp;</a></span>callableCheck()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Expression &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Dune::Functions::callableCheck </td>
          <td>(</td>
          <td class="paramtype">Expression&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a predicate for checking validity of expressions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function involving the expression to check.</td></tr>
  </table>
  </dd>
</dl>
<p>This returns a function object that allows to check if the expression encoded in f is valid for the given arguments. To be precise it checks if f can be called using the given arguments. This can be used inthe following way: To generate a check if the expression x(a,b) is valid for some a and b use:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> xIsValid = <a class="code" href="a00203.html#ga7d55c56e78792c4b169c18d875a60935">callableCheck</a>([](<span class="keyword">auto</span>&amp;&amp; a, <span class="keyword">auto</span>&amp;&amp; b) -&gt; std::void_t&lt;decltype(x(a,b))&gt; {});</div>
<div class="line"><span class="keywordflow">if</span> (xIsValid(a,b))</div>
<div class="line">  ...</div>
<div class="ttc" id="aa00203_html_ga7d55c56e78792c4b169c18d875a60935"><div class="ttname"><a href="a00203.html#ga7d55c56e78792c4b169c18d875a60935">Dune::Functions::callableCheck</a></div><div class="ttdeci">auto callableCheck(Expression f)</div><div class="ttdoc">Create a predicate for checking validity of expressions.</div><div class="ttdef"><b>Definition:</b> utility.hh:279</div></div>
</div><!-- fragment --><p>Notice that the given function f is stored by value. </p>

</div>
</div>
<a id="gac7d45de6c68fce943e6924403389d234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7d45de6c68fce943e6924403389d234">&#9670;&nbsp;</a></span>forwardAsStaticIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t end, class F , class size_type , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Dune::Functions::forwardAsStaticIndex </td>
          <td>(</td>
          <td class="paramtype">const size_type &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(f(Dune::Indices::_0, std::forward&lt;Args&gt;(args)...))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform dynamic index to static index_constant. </p>
<p>This will call the given function with index_constant<em> where i is the dynamically provided index.</em></p>
<p><em>To achieve this the conditon i==ii is checked subsequently for al static indices ii in the range 0,...,(end-1). In order to be able to compile this we require for all ii in this range that f(index_constant&lt;ii&gt;()) is well-formed and that the result type of it can be converted to the result type of f(index_constant&lt;0&gt;()). If i is not in this range, the returned value is f(index_constant&lt;n-1&gt;())</em></p>
<p><em></p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Dynamic index </td></tr>
    <tr><td class="paramname">f</td><td>Function to call (e.g., a generic lambda) </td></tr>
    <tr><td class="paramname">args</td><td>Additional arguments for f</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>f(index_constant&lt;i&gt;(), args...) </dd></dl>
<p></em></p>

</div>
</div>
<a id="ga2226fe3a86eb176df27c9801a98a10ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2226fe3a86eb176df27c9801a98a10ae">&#9670;&nbsp;</a></span>hybridIndexAccess()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class I , class F , typename std::enable_if&lt; Dune::models&lt; Imp::Concept::HasDynamicIndexAccess&lt; I &gt;, C &gt;(), int &gt;::type  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Dune::Functions::hybridIndexAccess </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(f(c[i]))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide operator[] index-access for containers. </p>
<p>This is the overload for types providing a operator[] for dynamic std::size_t arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Container to access </td></tr>
    <tr><td class="paramname">i</td><td>The index to use for accessing the container </td></tr>
    <tr><td class="paramname">f</td><td>A functor to call with the result of operator[] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabd5106817636cc5542dc4e9a1817551b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd5106817636cc5542dc4e9a1817551b">&#9670;&nbsp;</a></span>hybridMultiIndexAccess()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Result , class C , class MultiIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Result Dune::Functions::hybridMultiIndexAccess </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MultiIndex &amp;&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide multi-index access by chaining operator[]. </p>
<p>This provides access to a nested container by given multi-index. Internally this is resolved by recusive operator[]-calls with static or dynamic indices. Because this recursion must be terminated using a compile-time criterion, the result type must explicitly be provided. The recursion will terminate once the result can be converted to this result type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Result</td><td>Type of result</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Container to access </td></tr>
    <tr><td class="paramname">index</td><td>Multi-index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2bc5056bab5babdfa8a82409665f5a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bc5056bab5babdfa8a82409665f5a26">&#9670;&nbsp;</a></span>isCallable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto Dune::Functions::Concept::isCallable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if f is callable with given argument list. </p>

</div>
</div>
<a id="ga437efff5877892cd3a24c660179b32e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga437efff5877892cd3a24c660179b32e9">&#9670;&nbsp;</a></span>isCallable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto Dune::Functions::Concept::isCallable </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if f is callable with given argument list. </p>

</div>
</div>
<a id="gaed02f0c6f78e0d71e09d9bc6a29347c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed02f0c6f78e0d71e09d9bc6a29347c4">&#9670;&nbsp;</a></span>negatePredicate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Check &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Dune::Functions::negatePredicate </td>
          <td>(</td>
          <td class="paramtype">Check&#160;</td>
          <td class="paramname"><em>check</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Negate given predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A predicate function to negate</td></tr>
  </table>
  </dd>
</dl>
<p>This returns a function havin the same parameters as f, but negating the result. Negation here means that std::true_type is converted to std::false_type are vice verse, while other return values are converted to bool values and then the negated value is returned as bool, too.</p>
<p>Notice that the given function f is stored by value. </p>

</div>
</div>
<a id="ga89fbdd009241b14e86b4fff7ba208a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89fbdd009241b14e86b4fff7ba208a04">&#9670;&nbsp;</a></span>resolveDynamicMultiIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class MultiIndex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) Dune::Functions::resolveDynamicMultiIndex </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MultiIndex &amp;&#160;</td>
          <td class="paramname"><em>multiIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide multi-index access by chaining operator[]. </p>
<p>This provides access to a nested container by given dynamically sized multi-index. Internally this is resolved by recusive operator[]-calls with static or dynamic indices. Because this recursion must be terminated, a predicate is used to determine if a type is considered final for the multi-index resolution. This version terminates the recursion on values that neither have a static nore a dynamic operator[].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Container to access </td></tr>
    <tr><td class="paramname">index</td><td>Multi-index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9aaec884c080483fea267d1098f81590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9aaec884c080483fea267d1098f81590">&#9670;&nbsp;</a></span>resolveDynamicMultiIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class MultiIndex , class IsFinal &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) Dune::Functions::resolveDynamicMultiIndex </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MultiIndex &amp;&#160;</td>
          <td class="paramname"><em>multiIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IsFinal &amp;&#160;</td>
          <td class="paramname"><em>isFinal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide multi-index access by chaining operator[]. </p>
<p>This provides access to a nested container by given dynamically sized multi-index. Internally this is resolved by recusive operator[]-calls with static or dynamic indices. Because this recursion must be terminated, a predicate is used to determine if a type is considered final for the multi-index resolution. Hence multi-index resolution is terminated for values where the criterion matches. In order to do this statically the predicate has to return its result as std::true_type or std::false_type.</p>
<p>If the entries of the multi-index are exhausted, additional [0] entries are used until the termination criterion is satisfied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Container to access </td></tr>
    <tr><td class="paramname">index</td><td>Multi-index </td></tr>
    <tr><td class="paramname">isFinal</td><td>A predicate function checking if recursion should be terminated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4cc6af2842348271c242c048e0411637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cc6af2842348271c242c048e0411637">&#9670;&nbsp;</a></span>resolveStaticMultiIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class MultiIndex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) Dune::Functions::resolveStaticMultiIndex </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MultiIndex &amp;&#160;</td>
          <td class="paramname"><em>multiIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide multi-index access by chaining operator[]. </p>
<p>This provides access to a nested container by given statically sized multi-index. Internally this is resolved by recusive operator[]-calls with static or dynamic indices. Since the multi-index must have compile-time known size it is possible, that values resolved by different multi-indices have a different size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Container to access </td></tr>
    <tr><td class="paramname">index</td><td>Multi-index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa625ea93bc3285b8a09c9267302386ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa625ea93bc3285b8a09c9267302386ec">&#9670;&nbsp;</a></span>staticFindInRange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t begin_t, std::size_t end_t, class F , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::Functions::staticFindInRange </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Static find loop. </p>
<p>Run static for-loop from 'begin' to 'end-1' with functor. The functor is called with <code>Dune::index_constant&lt;i&gt;</code> as first argument. All other arguments of this method are forwarded to the functor. If the functor returns true the loop is terminated.</p>
<dl class="todo"><dt><b><a class="el" href="a00191.html#_todo000001">Todo:</a></b></dt><dd>Should this be just the StaticForLoop? </dd></dl>

</div>
</div>
<a id="ga4e5fbe8e1330cdfab9eddd5962682b4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e5fbe8e1330cdfab9eddd5962682b4c">&#9670;&nbsp;</a></span>transformTuple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Dune::Functions::transformTuple </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(Imp::transformTupleHelper(std::forward&lt;F&gt;(f), tuple, std::index_sequence_for&lt;T...&gt;{}))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform tuple value using a functor. </p>
<p>This will apply the given functor to all values in given tuple and return the results in a new tuple.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>A functor defined for all tuple entries </td></tr>
    <tr><td class="paramname">tuple</td><td>The tuple to transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae663a5bfd683c8a0844bb974807d8f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae663a5bfd683c8a0844bb974807d8f52">&#9670;&nbsp;</a></span>transformTuple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class... T1, class... T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Dune::Functions::transformTuple </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::tuple&lt; T1... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::tuple&lt; T2... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(Imp::transformTupleHelper(std::forward&lt;F&gt;(f), tuple1, tuple2, std::index_sequence_for&lt;T1...&gt;{}))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform tuple value using a binary functor. </p>
<p>This will apply the given functor to the each corresponding pair of values in the given tuples and return the results in a new tuple.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>A functor defined for all tuple entries </td></tr>
    <tr><td class="paramname">tuple1</td><td>The tuple containing values for the first parameter </td></tr>
    <tr><td class="paramname">tuple2</td><td>The tuple containing values for the second parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
