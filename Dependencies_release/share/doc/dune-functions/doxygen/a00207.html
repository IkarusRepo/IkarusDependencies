<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>dune-functions: Dune::Functions Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">dune-functions
   &#160;<span id="projectnumber">2.8.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00206.html">Dune</a></li><li class="navelem"><a class="el" href="a00207.html">Functions</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Dune::Functions Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:a00213"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00213.html">BasisBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00212"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00212.html">BasisFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00208"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00208.html">Concept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00218"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00218.html">Experimental</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01036.html">Polynomial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A scalar polynomial implementation.  <a href="a01036.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01040.html">TrigonometricFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linear combination of trigonomic functions.  <a href="a01040.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01056.html">CallableFunctionWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a Dune::VirtualFunction into a callable object.  <a href="a01056.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01060.html">InvalidRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy range class to be used if no proper type is available.  <a href="a01060.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01064.html">DefaultDerivativeTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation for derivative traits.  <a href="a01064.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01068.html">DefaultDerivativeTraits&lt; double(double) &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation for derivative traits.  <a href="a01068.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01072.html">DefaultDerivativeTraits&lt; K(FieldVector&lt; K, n &gt;)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation for derivative traits.  <a href="a01072.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01076.html">DefaultDerivativeTraits&lt; FieldVector&lt; K, m &gt;(FieldVector&lt; K, n &gt;)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation for derivative traits.  <a href="a01076.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01080.html">DefaultDerivativeTraits&lt; FieldMatrix&lt; K, 1, m &gt;(FieldVector&lt; K, n &gt;)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation for derivative traits.  <a href="a01080.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01084.html">DifferentiableFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01092.html">DifferentiableFunction&lt; Range(Domain), DerivativeTraits, bufferSize &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class storing differentiable functions using type erasure.  <a href="a01092.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01116.html">DifferentiableFunctionFromCallables</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01120.html">DifferentiableFunctionFromCallables&lt; Range(Domain), DerivativeTraits, F &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a list of callable objects as derivative sequence modelling <a class="el" href="a01144.html">Concept::DifferentiableFunction&lt;Range(Domain), DerivativeTraits&gt;</a>  <a href="a01120.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01124.html">DifferentiableFunctionFromCallables&lt; Range(Domain), DerivativeTraits, F, DF, Derivatives... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a list of callable objects as derivative sequence modelling <a class="el" href="a01144.html">Concept::DifferentiableFunction&lt;Range(Domain), DerivativeTraits&gt;</a>  <a href="a01124.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01200.html">FunctionFromCallable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01204.html">FunctionFromCallable&lt; Range(Domain), F, FunctionInterface &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a callable object as Dune::Function or Dune::VirtualFunction.  <a href="a01204.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01228.html">PolymorphicType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class with polymorphic type boiler plate code.  <a href="a01228.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01232.html">LocalFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01240.html">LocalFunction&lt; Range(Domain), LocalContext, DerivativeTraits, bufferSize &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class storing local functions using type erasure.  <a href="a01240.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01252.html">PolymorphicSmallObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper providing small object optimization with polymorphic types.  <a href="a01252.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01256.html">ReservedDeque</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A double-ended queue (deque) class with statically reserved memory.  <a href="a01256.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01260.html">IsCallable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to check that F is callable.  <a href="a01260.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01264.html">SignatureTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to deduce the signature of a callable.  <a href="a01264.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01268.html">SignatureTag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01272.html">SignatureTag&lt; Range(Domain), DerivativeTraitsT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag-class to encapsulate signature information.  <a href="a01272.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01284.html">UniformNodeVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mixin for visitors that should apply the same action on all nodes.  <a href="a01284.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01288.html">TreeData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container allowing to attach data to each node of a tree.  <a href="a01288.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01304.html">HasStaticSize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if type is a statically sized container.  <a href="a01304.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01308.html">StaticSize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain size of statically sized container.  <a href="a01308.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01324.html">TypeErasureBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for type-erased interface wrapper.  <a href="a01324.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01356.html">LastType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get last entry of type list.  <a href="a01356.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01368.html">RotateTuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate type list by one, such that last entry is moved to first position.  <a href="a01368.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01440.html">BrezziDouglasMariniNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01444.html">BrezziDouglasMariniPreBasis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01452.html">BSplineLocalFiniteElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">LocalFiniteElement in the sense of dune-localfunctions, for the B-spline basis on tensor-product grids.  <a href="a01452.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01456.html">BSplinePreBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-basis for B-spline basis.  <a href="a01456.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01460.html">BSplineLocalBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">LocalBasis class in the sense of dune-localfunctions, presenting the restriction of a B-spline patch to a knot span.  <a href="a01460.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01464.html">BSplineLocalCoefficients</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a shape function to an entity.  <a href="a01464.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01468.html">BSplineLocalInterpolation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local interpolation in the sense of dune-localfunctions, for the B-spline basis on tensor-product grids.  <a href="a01468.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01472.html">BSplineNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01484.html">CompositePreBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pre-basis for composite bases.  <a href="a01484.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01548.html">DefaultGlobalBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global basis for given pre-basis.  <a href="a01548.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01556.html">DefaultLocalView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The restriction of a finite element basis to a single element.  <a href="a01556.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01564.html">DefaultNodeToRangeMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple node to range map using lexicographic ordering.  <a href="a01564.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01572.html">FlatMultiIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-index class with only one level.  <a href="a01572.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01620.html">HierarchicalLagrangeNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01624.html">HierarchicalLagrangePreBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pre-basis for a hierarchical basis.  <a href="a01624.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01632.html">HierarchicNodeToRangeMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple node to range map using the nested tree indices.  <a href="a01632.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01652.html">HierarchicVectorWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper providing multiindex access to vector entries.  <a href="a01652.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01672.html">LagrangeNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01676.html">LagrangePreBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pre-basis for a PQ-lagrange bases with given order.  <a href="a01676.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01688.html">LagrangeDGPreBasis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01700.html">NedelecNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01704.html">NedelecPreBasis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01724.html">BasisNodeMixin</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01728.html">LeafBasisNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01732.html">PowerBasisNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01736.html">CompositeBasisNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01752.html">PowerPreBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pre-basis for power bases.  <a href="a01752.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01760.html">RannacherTurekNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01764.html">RannacherTurekPreBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-basis for a Rannacher-Turek basis.  <a href="a01764.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01816.html">RaviartThomasNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01820.html">RaviartThomasPreBasis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01828.html">SizeInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class encapsulating size information.  <a href="a01828.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01832.html">SubEntityDOFs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range of DOFs associated to sub-entity.  <a href="a01832.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01836.html">SubspaceBasis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01840.html">SubspaceLocalView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The restriction of a finite element basis to a single element.  <a href="a01840.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01844.html">TaylorHoodVelocityTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01848.html">TaylorHoodBasisTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01852.html">TaylorHoodPreBasis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-basis for lowest order Taylor-Hood basis.  <a href="a01852.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01880.html">AnalyticGridViewFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01884.html">AnalyticGridViewFunction&lt; Range(Domain), GV, F, DerivativeTraits &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class wrapping any differentiable function as grid function.  <a href="a01884.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01888.html">DiscreteGlobalBasisFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A grid function induced by a global basis and a coefficient vector.  <a href="a01888.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01896.html">GridFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01904.html">GridFunction&lt; Range(Domain), ES, DerivativeTraits, bufferSize &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class for functions defined on a Grid.  <a href="a01904.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01920.html">GridViewEntitySet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An entity set for all entities of given codim in a grid view.  <a href="a01920.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01924.html">GridViewFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01928.html">GridViewFunction&lt; Range(Domain), GV, DerivativeTraits, bufferSize &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class for functions defined on a GridView.  <a href="a01928.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01932.html">LocalDerivativeTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derivative traits for local functions.  <a href="a01932.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae5c434b1f2c172a6e65d2ff92d3460cb"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae5c434b1f2c172a6e65d2ff92d3460cb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00207.html#ae5c434b1f2c172a6e65d2ff92d3460cb">Optional</a> = std::optional&lt; T &gt;</td></tr>
<tr class="separator:ae5c434b1f2c172a6e65d2ff92d3460cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga673247dd74bcdd9e5acfc7735faf8a5b"><td class="memTemplParams" colspan="2">template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:ga673247dd74bcdd9e5acfc7735faf8a5b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00203.html#ga673247dd74bcdd9e5acfc7735faf8a5b">enableIfConstructible</a> = typename std::enable_if&lt; std::is_constructible&lt; T, Args... &gt;::value, int &gt;::type</td></tr>
<tr class="memdesc:ga673247dd74bcdd9e5acfc7735faf8a5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to constrain forwarding constructors.  <a href="a00203.html#ga673247dd74bcdd9e5acfc7735faf8a5b">More...</a><br /></td></tr>
<tr class="separator:ga673247dd74bcdd9e5acfc7735faf8a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga047a2180b455bfa030fba76eb6270952"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class T, class ArgTuple &gt; </td></tr>
<tr class="memitem:ga047a2180b455bfa030fba76eb6270952"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00203.html#ga047a2180b455bfa030fba76eb6270952">ExpandTuple</a> = typename Imp::ExpandTupleHelper&lt; T, ArgTuple &gt;::Type</td></tr>
<tr class="memdesc:ga047a2180b455bfa030fba76eb6270952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand tuple arguments as template arguments.  <a href="a00203.html#ga047a2180b455bfa030fba76eb6270952">More...</a><br /></td></tr>
<tr class="separator:ga047a2180b455bfa030fba76eb6270952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ce77345fbee606e5ac22aeef7d109d6"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class F, class... Tuples&gt; </td></tr>
<tr class="memitem:ga1ce77345fbee606e5ac22aeef7d109d6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00203.html#ga1ce77345fbee606e5ac22aeef7d109d6">TransformTuple</a> = typename Imp::TransformTupleHelper&lt; F, Tuples... &gt;::Type</td></tr>
<tr class="memdesc:ga1ce77345fbee606e5ac22aeef7d109d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform tuple types argument using type-functor.  <a href="a00203.html#ga1ce77345fbee606e5ac22aeef7d109d6">More...</a><br /></td></tr>
<tr class="separator:ga1ce77345fbee606e5ac22aeef7d109d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7adaea3a8e209aef72602f07a6988b3"><td class="memTemplParams" colspan="2">template&lt;class IntegerSequence &gt; </td></tr>
<tr class="memitem:ad7adaea3a8e209aef72602f07a6988b3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00207.html#ad7adaea3a8e209aef72602f07a6988b3">IntegerSequenceTuple</a> = typename Imp::IntegerSequenceTupleHelper&lt; IntegerSequence &gt;::Type</td></tr>
<tr class="memdesc:ad7adaea3a8e209aef72602f07a6988b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform integer_sequence&lt;I,k...&gt; to tuple&lt;integral_constant&lt;I,k&gt;...&gt;  <a href="a00207.html#ad7adaea3a8e209aef72602f07a6988b3">More...</a><br /></td></tr>
<tr class="separator:ad7adaea3a8e209aef72602f07a6988b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b968ee05cd46e1c58beaf32eef881e"><td class="memTemplParams" colspan="2">template&lt;typename GV , int k&gt; </td></tr>
<tr class="memitem:aa7b968ee05cd46e1c58beaf32eef881e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00207.html#aa7b968ee05cd46e1c58beaf32eef881e">BrezziDouglasMariniBasis</a> = <a class="el" href="a01548.html">DefaultGlobalBasis</a>&lt; <a class="el" href="a01444.html">BrezziDouglasMariniPreBasis</a>&lt; GV, k, <a class="el" href="a01572.html">FlatMultiIndex</a>&lt; std::size_t &gt; &gt; &gt;</td></tr>
<tr class="memdesc:aa7b968ee05cd46e1c58beaf32eef881e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basis of a scalar k-th-order BDM finite element space on simplex and cube grids.  <a href="a00207.html#aa7b968ee05cd46e1c58beaf32eef881e">More...</a><br /></td></tr>
<tr class="separator:aa7b968ee05cd46e1c58beaf32eef881e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf109653b01a1dfb0d2319f56441cc1c9"><td class="memTemplParams" colspan="2">template&lt;typename GV &gt; </td></tr>
<tr class="memitem:gaf109653b01a1dfb0d2319f56441cc1c9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#gaf109653b01a1dfb0d2319f56441cc1c9">BSplineBasis</a> = <a class="el" href="a01548.html">DefaultGlobalBasis</a>&lt; <a class="el" href="a01456.html">BSplinePreBasis</a>&lt; GV, <a class="el" href="a01572.html">FlatMultiIndex</a>&lt; std::size_t &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gaf109653b01a1dfb0d2319f56441cc1c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A global B-spline basis.  <a href="a00201.html#gaf109653b01a1dfb0d2319f56441cc1c9">More...</a><br /></td></tr>
<tr class="separator:gaf109653b01a1dfb0d2319f56441cc1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeba56a3cfdaf499adf0fd9381bb94edf"><td class="memTemplParams" colspan="2">template&lt;typename GV , int k, typename R  = double&gt; </td></tr>
<tr class="memitem:gaeba56a3cfdaf499adf0fd9381bb94edf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#gaeba56a3cfdaf499adf0fd9381bb94edf">HierarchicalLagrangeBasis</a> = <a class="el" href="a01548.html">DefaultGlobalBasis</a>&lt; <a class="el" href="a01624.html">HierarchicalLagrangePreBasis</a>&lt; GV, k, <a class="el" href="a01572.html">FlatMultiIndex</a>&lt; std::size_t &gt;, R &gt; &gt;</td></tr>
<tr class="memdesc:gaeba56a3cfdaf499adf0fd9381bb94edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basis of a scalar Hierarchical Lagrange finite element space.  <a href="a00201.html#gaeba56a3cfdaf499adf0fd9381bb94edf">More...</a><br /></td></tr>
<tr class="separator:gaeba56a3cfdaf499adf0fd9381bb94edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa20eeebc1da5dc12e8f78936f2833b77"><td class="memTemplParams" colspan="2">template&lt;typename GV , int k = -1, typename R  = double&gt; </td></tr>
<tr class="memitem:gaa20eeebc1da5dc12e8f78936f2833b77"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#gaa20eeebc1da5dc12e8f78936f2833b77">LagrangeBasis</a> = <a class="el" href="a01548.html">DefaultGlobalBasis</a>&lt; <a class="el" href="a01676.html">LagrangePreBasis</a>&lt; GV, k, <a class="el" href="a01572.html">FlatMultiIndex</a>&lt; std::size_t &gt;, R &gt; &gt;</td></tr>
<tr class="memdesc:gaa20eeebc1da5dc12e8f78936f2833b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nodal basis of a scalar k-th-order Lagrangean finite element space.  <a href="a00201.html#gaa20eeebc1da5dc12e8f78936f2833b77">More...</a><br /></td></tr>
<tr class="separator:gaa20eeebc1da5dc12e8f78936f2833b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa871daf79a93a0f0b19e6e480b41c95"><td class="memTemplParams" colspan="2">template&lt;typename GV , int k&gt; </td></tr>
<tr class="memitem:afa871daf79a93a0f0b19e6e480b41c95"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00207.html#afa871daf79a93a0f0b19e6e480b41c95">LagrangeDGNode</a> = <a class="el" href="a01672.html">LagrangeNode</a>&lt; GV, k &gt;</td></tr>
<tr class="separator:afa871daf79a93a0f0b19e6e480b41c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ea5830c997ee5a4ff356058e7441b9a"><td class="memTemplParams" colspan="2">template&lt;typename GV , int k&gt; </td></tr>
<tr class="memitem:ga2ea5830c997ee5a4ff356058e7441b9a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#ga2ea5830c997ee5a4ff356058e7441b9a">LagrangeDGBasis</a> = <a class="el" href="a01548.html">DefaultGlobalBasis</a>&lt; <a class="el" href="a01688.html">LagrangeDGPreBasis</a>&lt; GV, k, <a class="el" href="a01572.html">FlatMultiIndex</a>&lt; std::size_t &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga2ea5830c997ee5a4ff356058e7441b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basis of a scalar k-th-order Lagrangean-DG finite element space.  <a href="a00201.html#ga2ea5830c997ee5a4ff356058e7441b9a">More...</a><br /></td></tr>
<tr class="separator:ga2ea5830c997ee5a4ff356058e7441b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c0aec3888b5baa3957c2fe67034d2b"><td class="memTemplParams" colspan="2">template&lt;typename GV , std::size_t kind, std::size_t order, typename Range  = double&gt; </td></tr>
<tr class="memitem:a37c0aec3888b5baa3957c2fe67034d2b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00207.html#a37c0aec3888b5baa3957c2fe67034d2b">NedelecBasis</a> = <a class="el" href="a01548.html">DefaultGlobalBasis</a>&lt; <a class="el" href="a01704.html">NedelecPreBasis</a>&lt; GV, Range, kind, order, <a class="el" href="a01572.html">FlatMultiIndex</a>&lt; std::size_t &gt; &gt; &gt;</td></tr>
<tr class="memdesc:a37c0aec3888b5baa3957c2fe67034d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basis of a k-th-order Nédélec finite element space.  <a href="a00207.html#a37c0aec3888b5baa3957c2fe67034d2b">More...</a><br /></td></tr>
<tr class="separator:a37c0aec3888b5baa3957c2fe67034d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79a4047e00991e7cbbb57be9e5945d64"><td class="memTemplParams" colspan="2">template&lt;typename GV &gt; </td></tr>
<tr class="memitem:ga79a4047e00991e7cbbb57be9e5945d64"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#ga79a4047e00991e7cbbb57be9e5945d64">RannacherTurekBasis</a> = <a class="el" href="a01548.html">DefaultGlobalBasis</a>&lt; <a class="el" href="a01764.html">RannacherTurekPreBasis</a>&lt; GV, <a class="el" href="a01572.html">FlatMultiIndex</a>&lt; std::size_t &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga79a4047e00991e7cbbb57be9e5945d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rannacher-Turek basis.  <a href="a00201.html#ga79a4047e00991e7cbbb57be9e5945d64">More...</a><br /></td></tr>
<tr class="separator:ga79a4047e00991e7cbbb57be9e5945d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8026cfdb4342677d34821811110ac75"><td class="memTemplParams" colspan="2">template&lt;typename GV , int k&gt; </td></tr>
<tr class="memitem:ac8026cfdb4342677d34821811110ac75"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00207.html#ac8026cfdb4342677d34821811110ac75">RaviartThomasBasis</a> = <a class="el" href="a01548.html">DefaultGlobalBasis</a>&lt; <a class="el" href="a01820.html">RaviartThomasPreBasis</a>&lt; GV, k, <a class="el" href="a01572.html">FlatMultiIndex</a>&lt; std::size_t &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ac8026cfdb4342677d34821811110ac75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basis of a k-th-order Raviart Thomas finite element space.  <a href="a00207.html#ac8026cfdb4342677d34821811110ac75">More...</a><br /></td></tr>
<tr class="separator:ac8026cfdb4342677d34821811110ac75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3038d251713f7ac8b7329fd73a8331aa"><td class="memTemplParams" colspan="2">template&lt;typename GV &gt; </td></tr>
<tr class="memitem:ga3038d251713f7ac8b7329fd73a8331aa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00201.html#ga3038d251713f7ac8b7329fd73a8331aa">TaylorHoodBasis</a> = <a class="el" href="a01548.html">DefaultGlobalBasis</a>&lt; <a class="el" href="a01852.html">TaylorHoodPreBasis</a>&lt; GV, Dune::ReservedVector&lt; std::size_t, 2 &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga3038d251713f7ac8b7329fd73a8331aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nodal basis for a lowest order Taylor-Hood Lagrangean finite element space.  <a href="a00201.html#ga3038d251713f7ac8b7329fd73a8331aa">More...</a><br /></td></tr>
<tr class="separator:ga3038d251713f7ac8b7329fd73a8331aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1a465a66908d407dcc465550657997a0"><td class="memTemplParams" colspan="2">template&lt;class K , int sinFactor, int cosFactor&gt; </td></tr>
<tr class="memitem:ga1a465a66908d407dcc465550657997a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01040.html">TrigonometricFunction</a>&lt; K, -cosFactor, sinFactor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00197.html#ga1a465a66908d407dcc465550657997a0">derivative</a> (const <a class="el" href="a01040.html">TrigonometricFunction</a>&lt; K, sinFactor, cosFactor &gt; &amp;f)</td></tr>
<tr class="memdesc:ga1a465a66908d407dcc465550657997a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain derivative of <a class="el" href="a01040.html" title="A linear combination of trigonomic functions.">TrigonometricFunction</a> function.  <a href="a00197.html#ga1a465a66908d407dcc465550657997a0">More...</a><br /></td></tr>
<tr class="separator:ga1a465a66908d407dcc465550657997a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a3b4e397e76b3d02cb06a7793fdb7b"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:ad0a3b4e397e76b3d02cb06a7793fdb7b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00207.html#ad0a3b4e397e76b3d02cb06a7793fdb7b">fieldTypes</a> ()</td></tr>
<tr class="memdesc:ad0a3b4e397e76b3d02cb06a7793fdb7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate list of field types in container.  <a href="a00207.html#ad0a3b4e397e76b3d02cb06a7793fdb7b">More...</a><br /></td></tr>
<tr class="separator:ad0a3b4e397e76b3d02cb06a7793fdb7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b09a0411c63ab6a6500a7b6edb9dfb"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:af8b09a0411c63ab6a6500a7b6edb9dfb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00207.html#af8b09a0411c63ab6a6500a7b6edb9dfb">hasUniqueFieldType</a> ()</td></tr>
<tr class="memdesc:af8b09a0411c63ab6a6500a7b6edb9dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if container has a unique field type.  <a href="a00207.html#af8b09a0411c63ab6a6500a7b6edb9dfb">More...</a><br /></td></tr>
<tr class="separator:af8b09a0411c63ab6a6500a7b6edb9dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5b9f62f85e3d638423142695a74d056"><td class="memTemplParams" colspan="2">template&lt;class Vector &gt; </td></tr>
<tr class="memitem:gae5b9f62f85e3d638423142695a74d056"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#gae5b9f62f85e3d638423142695a74d056">istlVectorBackend</a> (Vector &amp;v)</td></tr>
<tr class="memdesc:gae5b9f62f85e3d638423142695a74d056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector backend wrapping non-const ISTL like containers.  <a href="a00202.html#gae5b9f62f85e3d638423142695a74d056">More...</a><br /></td></tr>
<tr class="separator:gae5b9f62f85e3d638423142695a74d056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50a181637103e7abc011235a9fd30611"><td class="memTemplParams" colspan="2">template&lt;class Vector &gt; </td></tr>
<tr class="memitem:ga50a181637103e7abc011235a9fd30611"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#ga50a181637103e7abc011235a9fd30611">istlVectorBackend</a> (const Vector &amp;v)</td></tr>
<tr class="memdesc:ga50a181637103e7abc011235a9fd30611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector backend wrapping const ISTL like containers.  <a href="a00202.html#ga50a181637103e7abc011235a9fd30611">More...</a><br /></td></tr>
<tr class="separator:ga50a181637103e7abc011235a9fd30611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64f8b5d6ab847a9fe6f2df3a87481947"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:ga64f8b5d6ab847a9fe6f2df3a87481947"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01056.html">CallableFunctionWrapper</a>&lt; F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00197.html#ga64f8b5d6ab847a9fe6f2df3a87481947">callable</a> (const F &amp;f)</td></tr>
<tr class="memdesc:ga64f8b5d6ab847a9fe6f2df3a87481947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a callable object from some Dune::VirtualFunction.  <a href="a00197.html#ga64f8b5d6ab847a9fe6f2df3a87481947">More...</a><br /></td></tr>
<tr class="separator:ga64f8b5d6ab847a9fe6f2df3a87481947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1df485caf63020cd42330a569be9b3c2"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:ga1df485caf63020cd42330a569be9b3c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01056.html">CallableFunctionWrapper</a>&lt; F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00197.html#ga1df485caf63020cd42330a569be9b3c2">callable</a> (const std::shared_ptr&lt; F &gt; &amp;fp)</td></tr>
<tr class="memdesc:ga1df485caf63020cd42330a569be9b3c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a callable object from std::shared_ptr&lt;F&gt;  <a href="a00197.html#ga1df485caf63020cd42330a569be9b3c2">More...</a><br /></td></tr>
<tr class="separator:ga1df485caf63020cd42330a569be9b3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga849c643b37ee127738cf70d602a73cc8"><td class="memTemplParams" colspan="2">template&lt;class Signature , template&lt; class &gt; class DerivativeTraits, class... F&gt; </td></tr>
<tr class="memitem:ga849c643b37ee127738cf70d602a73cc8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01116.html">DifferentiableFunctionFromCallables</a>&lt; Signature, DerivativeTraits, F... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00197.html#ga849c643b37ee127738cf70d602a73cc8">makeDifferentiableFunctionFromCallables</a> (const <a class="el" href="a01268.html">SignatureTag</a>&lt; Signature, DerivativeTraits &gt; &amp;signatureTag, F &amp;&amp;... f)</td></tr>
<tr class="memdesc:ga849c643b37ee127738cf70d602a73cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="a01084.html">DifferentiableFunction</a> from callables.  <a href="a00197.html#ga849c643b37ee127738cf70d602a73cc8">More...</a><br /></td></tr>
<tr class="separator:ga849c643b37ee127738cf70d602a73cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2226fe3a86eb176df27c9801a98a10ae"><td class="memTemplParams" colspan="2">template&lt;class C , class I , class F , typename std::enable_if&lt; Dune::models&lt; Imp::Concept::HasDynamicIndexAccess&lt; I &gt;, C &gt;(), int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ga2226fe3a86eb176df27c9801a98a10ae"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00203.html#ga2226fe3a86eb176df27c9801a98a10ae">hybridIndexAccess</a> (C &amp;&amp;c, const I &amp;i, F &amp;&amp;f) -&gt; decltype(f(c[i]))</td></tr>
<tr class="memdesc:ga2226fe3a86eb176df27c9801a98a10ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide operator[] index-access for containers.  <a href="a00203.html#ga2226fe3a86eb176df27c9801a98a10ae">More...</a><br /></td></tr>
<tr class="separator:ga2226fe3a86eb176df27c9801a98a10ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2226fe3a86eb176df27c9801a98a10ae"><td class="memTemplParams" colspan="2">template&lt;class C , class I , class F , typename std::enable_if&lt; not Dune::models&lt; Imp::Concept::HasDynamicIndexAccess&lt; I &gt;, C &gt;(), int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ga2226fe3a86eb176df27c9801a98a10ae"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00207.html#ga2226fe3a86eb176df27c9801a98a10ae">hybridIndexAccess</a> (C &amp;&amp;c, const I &amp;i, F &amp;&amp;f)</td></tr>
<tr class="memdesc:ga2226fe3a86eb176df27c9801a98a10ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide operator[] index-access for containers.  <a href="a00207.html#ga2226fe3a86eb176df27c9801a98a10ae">More...</a><br /></td></tr>
<tr class="separator:ga2226fe3a86eb176df27c9801a98a10ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd5106817636cc5542dc4e9a1817551b"><td class="memTemplParams" colspan="2">template&lt;class Result , class C , class MultiIndex &gt; </td></tr>
<tr class="memitem:gabd5106817636cc5542dc4e9a1817551b"><td class="memTemplItemLeft" align="right" valign="top">Result&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00203.html#gabd5106817636cc5542dc4e9a1817551b">hybridMultiIndexAccess</a> (C &amp;&amp;c, const MultiIndex &amp;index)</td></tr>
<tr class="memdesc:gabd5106817636cc5542dc4e9a1817551b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide multi-index access by chaining operator[].  <a href="a00203.html#gabd5106817636cc5542dc4e9a1817551b">More...</a><br /></td></tr>
<tr class="separator:gabd5106817636cc5542dc4e9a1817551b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9aaec884c080483fea267d1098f81590"><td class="memTemplParams" colspan="2">template&lt;class C , class MultiIndex , class IsFinal &gt; </td></tr>
<tr class="memitem:ga9aaec884c080483fea267d1098f81590"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00203.html#ga9aaec884c080483fea267d1098f81590">resolveDynamicMultiIndex</a> (C &amp;&amp;c, const MultiIndex &amp;multiIndex, const IsFinal &amp;isFinal)</td></tr>
<tr class="memdesc:ga9aaec884c080483fea267d1098f81590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide multi-index access by chaining operator[].  <a href="a00203.html#ga9aaec884c080483fea267d1098f81590">More...</a><br /></td></tr>
<tr class="separator:ga9aaec884c080483fea267d1098f81590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89fbdd009241b14e86b4fff7ba208a04"><td class="memTemplParams" colspan="2">template&lt;class C , class MultiIndex &gt; </td></tr>
<tr class="memitem:ga89fbdd009241b14e86b4fff7ba208a04"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00203.html#ga89fbdd009241b14e86b4fff7ba208a04">resolveDynamicMultiIndex</a> (C &amp;&amp;c, const MultiIndex &amp;multiIndex)</td></tr>
<tr class="memdesc:ga89fbdd009241b14e86b4fff7ba208a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide multi-index access by chaining operator[].  <a href="a00203.html#ga89fbdd009241b14e86b4fff7ba208a04">More...</a><br /></td></tr>
<tr class="separator:ga89fbdd009241b14e86b4fff7ba208a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cc6af2842348271c242c048e0411637"><td class="memTemplParams" colspan="2">template&lt;class C , class MultiIndex &gt; </td></tr>
<tr class="memitem:ga4cc6af2842348271c242c048e0411637"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00203.html#ga4cc6af2842348271c242c048e0411637">resolveStaticMultiIndex</a> (C &amp;&amp;c, const MultiIndex &amp;multiIndex)</td></tr>
<tr class="memdesc:ga4cc6af2842348271c242c048e0411637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide multi-index access by chaining operator[].  <a href="a00203.html#ga4cc6af2842348271c242c048e0411637">More...</a><br /></td></tr>
<tr class="separator:ga4cc6af2842348271c242c048e0411637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18b2a675f9153814c422d33878daebb2"><td class="memTemplParams" colspan="2">template&lt;class Range , class Domain , template&lt; class &gt; class DerivativeTraits&gt; </td></tr>
<tr class="memitem:ga18b2a675f9153814c422d33878daebb2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00198.html#ga18b2a675f9153814c422d33878daebb2">derivativeSignatureTag</a> (<a class="el" href="a01268.html">SignatureTag</a>&lt; Range(Domain), DerivativeTraits &gt; tag)</td></tr>
<tr class="memdesc:ga18b2a675f9153814c422d33878daebb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct <a class="el" href="a01268.html">SignatureTag</a> for derivative.  <a href="a00198.html#ga18b2a675f9153814c422d33878daebb2">More...</a><br /></td></tr>
<tr class="separator:ga18b2a675f9153814c422d33878daebb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95d38d90c6b8ee6d3a2a0202cb80b56d"><td class="memTemplParams" colspan="2">template&lt;std::size_t maxOrder, class Signature , template&lt; class &gt; class DerivativeTraits&gt; </td></tr>
<tr class="memitem:ga95d38d90c6b8ee6d3a2a0202cb80b56d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00198.html#ga95d38d90c6b8ee6d3a2a0202cb80b56d">derivativeSignatureTags</a> (<a class="el" href="a01268.html">Dune::Functions::SignatureTag</a>&lt; Signature, DerivativeTraits &gt; tag)</td></tr>
<tr class="memdesc:ga95d38d90c6b8ee6d3a2a0202cb80b56d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct SignatureTags for derivatives.  <a href="a00198.html#ga95d38d90c6b8ee6d3a2a0202cb80b56d">More...</a><br /></td></tr>
<tr class="separator:ga95d38d90c6b8ee6d3a2a0202cb80b56d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa625ea93bc3285b8a09c9267302386ec"><td class="memTemplParams" colspan="2">template&lt;std::size_t begin_t, std::size_t end_t, class F , class... Args&gt; </td></tr>
<tr class="memitem:gaa625ea93bc3285b8a09c9267302386ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00203.html#gaa625ea93bc3285b8a09c9267302386ec">staticFindInRange</a> (F &amp;&amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:gaa625ea93bc3285b8a09c9267302386ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static find loop.  <a href="a00203.html#gaa625ea93bc3285b8a09c9267302386ec">More...</a><br /></td></tr>
<tr class="separator:gaa625ea93bc3285b8a09c9267302386ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f8a9700ef8b12973e210ee4674c2b7"><td class="memTemplParams" colspan="2">template&lt;class F , class size_type , size_type firstValue, class... Args&gt; </td></tr>
<tr class="memitem:a84f8a9700ef8b12973e210ee4674c2b7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00207.html#a84f8a9700ef8b12973e210ee4674c2b7">forwardAsStaticInteger</a> (std::integer_sequence&lt; size_type, firstValue &gt; values, const size_type &amp;i, F &amp;&amp;f, Args &amp;&amp;... args) -&gt; decltype(f(std::integral_constant&lt; size_type, firstValue &gt;(), std::forward&lt; Args &gt;(args)...))</td></tr>
<tr class="separator:a84f8a9700ef8b12973e210ee4674c2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e975086fb37cbf3e33cc42a2b4ef1e2"><td class="memTemplParams" colspan="2">template&lt;class F , class size_type , size_type firstValue, size_type secondValue, size_type... otherValues, class... Args&gt; </td></tr>
<tr class="memitem:a4e975086fb37cbf3e33cc42a2b4ef1e2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00207.html#a4e975086fb37cbf3e33cc42a2b4ef1e2">forwardAsStaticInteger</a> (std::integer_sequence&lt; size_type, firstValue, secondValue, otherValues... &gt; values, const size_type i, F &amp;&amp;f, Args &amp;&amp;... args) -&gt; decltype(f(std::integral_constant&lt; size_type, firstValue &gt;(), std::forward&lt; Args &gt;(args)...))</td></tr>
<tr class="separator:a4e975086fb37cbf3e33cc42a2b4ef1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7d45de6c68fce943e6924403389d234"><td class="memTemplParams" colspan="2">template&lt;std::size_t end, class F , class size_type , class... Args&gt; </td></tr>
<tr class="memitem:gac7d45de6c68fce943e6924403389d234"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00203.html#gac7d45de6c68fce943e6924403389d234">forwardAsStaticIndex</a> (const size_type &amp;i, F &amp;&amp;f, Args &amp;&amp;... args) -&gt; decltype(f(Dune::Indices::_0, std::forward&lt; Args &gt;(args)...))</td></tr>
<tr class="memdesc:gac7d45de6c68fce943e6924403389d234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform dynamic index to static index_constant.  <a href="a00203.html#gac7d45de6c68fce943e6924403389d234">More...</a><br /></td></tr>
<tr class="separator:gac7d45de6c68fce943e6924403389d234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e5fbe8e1330cdfab9eddd5962682b4c"><td class="memTemplParams" colspan="2">template&lt;class F , class... T&gt; </td></tr>
<tr class="memitem:ga4e5fbe8e1330cdfab9eddd5962682b4c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00203.html#ga4e5fbe8e1330cdfab9eddd5962682b4c">transformTuple</a> (F &amp;&amp;f, const std::tuple&lt; T... &gt; &amp;tuple) -&gt; decltype(Imp::transformTupleHelper(std::forward&lt; F &gt;(f), tuple, std::index_sequence_for&lt; T... &gt;{}))</td></tr>
<tr class="memdesc:ga4e5fbe8e1330cdfab9eddd5962682b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform tuple value using a functor.  <a href="a00203.html#ga4e5fbe8e1330cdfab9eddd5962682b4c">More...</a><br /></td></tr>
<tr class="separator:ga4e5fbe8e1330cdfab9eddd5962682b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae663a5bfd683c8a0844bb974807d8f52"><td class="memTemplParams" colspan="2">template&lt;class F , class... T1, class... T2&gt; </td></tr>
<tr class="memitem:gae663a5bfd683c8a0844bb974807d8f52"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00203.html#gae663a5bfd683c8a0844bb974807d8f52">transformTuple</a> (F &amp;&amp;f, const std::tuple&lt; T1... &gt; &amp;tuple1, const std::tuple&lt; T2... &gt; &amp;tuple2) -&gt; decltype(Imp::transformTupleHelper(std::forward&lt; F &gt;(f), tuple1, tuple2, std::index_sequence_for&lt; T1... &gt;{}))</td></tr>
<tr class="memdesc:gae663a5bfd683c8a0844bb974807d8f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform tuple value using a binary functor.  <a href="a00203.html#gae663a5bfd683c8a0844bb974807d8f52">More...</a><br /></td></tr>
<tr class="separator:gae663a5bfd683c8a0844bb974807d8f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d55c56e78792c4b169c18d875a60935"><td class="memTemplParams" colspan="2">template&lt;class Expression &gt; </td></tr>
<tr class="memitem:ga7d55c56e78792c4b169c18d875a60935"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00203.html#ga7d55c56e78792c4b169c18d875a60935">callableCheck</a> (Expression f)</td></tr>
<tr class="memdesc:ga7d55c56e78792c4b169c18d875a60935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a predicate for checking validity of expressions.  <a href="a00203.html#ga7d55c56e78792c4b169c18d875a60935">More...</a><br /></td></tr>
<tr class="separator:ga7d55c56e78792c4b169c18d875a60935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed02f0c6f78e0d71e09d9bc6a29347c4"><td class="memTemplParams" colspan="2">template&lt;class Check &gt; </td></tr>
<tr class="memitem:gaed02f0c6f78e0d71e09d9bc6a29347c4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00203.html#gaed02f0c6f78e0d71e09d9bc6a29347c4">negatePredicate</a> (Check check)</td></tr>
<tr class="memdesc:gaed02f0c6f78e0d71e09d9bc6a29347c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate given predicate.  <a href="a00203.html#gaed02f0c6f78e0d71e09d9bc6a29347c4">More...</a><br /></td></tr>
<tr class="separator:gaed02f0c6f78e0d71e09d9bc6a29347c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb3a351c2ab1b4eb46d4ba1ec3d95a0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6bb3a351c2ab1b4eb46d4ba1ec3d95a0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00207.html#a6bb3a351c2ab1b4eb46d4ba1ec3d95a0">forwardCapture</a> (T &amp;&amp;t)</td></tr>
<tr class="memdesc:a6bb3a351c2ab1b4eb46d4ba1ec3d95a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a capture object for perfect forwarding.  <a href="a00207.html#a6bb3a351c2ab1b4eb46d4ba1ec3d95a0">More...</a><br /></td></tr>
<tr class="separator:a6bb3a351c2ab1b4eb46d4ba1ec3d95a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa60b94e3da01aa62a555f6955a7f09e5"><td class="memTemplParams" colspan="2">template&lt;class Basis , class F , decltype(std::declval&lt; std::decay_t&lt; F &gt;&gt;()(0, std::declval&lt; typename Basis::LocalView &gt;(), std::declval&lt; typename Basis::GridView::Intersection &gt;()), 0)  = 0&gt; </td></tr>
<tr class="memitem:gaa60b94e3da01aa62a555f6955a7f09e5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#gaa60b94e3da01aa62a555f6955a7f09e5">forEachBoundaryDOF</a> (const Basis &amp;basis, F &amp;&amp;f)</td></tr>
<tr class="memdesc:gaa60b94e3da01aa62a555f6955a7f09e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loop over all DOFs on the boundary.  <a href="a00202.html#gaa60b94e3da01aa62a555f6955a7f09e5">More...</a><br /></td></tr>
<tr class="separator:gaa60b94e3da01aa62a555f6955a7f09e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ba8b217ca5a05cddfe065e8191699e"><td class="memTemplParams" colspan="2">template&lt;class Tree &gt; </td></tr>
<tr class="memitem:ab1ba8b217ca5a05cddfe065e8191699e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01564.html">DefaultNodeToRangeMap</a>&lt; Tree &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00207.html#ab1ba8b217ca5a05cddfe065e8191699e">makeDefaultNodeToRangeMap</a> (const Tree &amp;tree)</td></tr>
<tr class="separator:ab1ba8b217ca5a05cddfe065e8191699e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5971c4cc40d4d8a400ef5fe9e596350"><td class="memTemplParams" colspan="2">template&lt;class Basis , class TreePath &gt; </td></tr>
<tr class="memitem:ad5971c4cc40d4d8a400ef5fe9e596350"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00207.html#ad5971c4cc40d4d8a400ef5fe9e596350">makeDefaultNodeToRangeMap</a> (const Basis &amp;basis, TreePath &amp;&amp;treePath) -&gt; decltype(makeDefaultNodeToRangeMap(TypeTree::child(basis.localView().tree(), treePath)))</td></tr>
<tr class="separator:ad5971c4cc40d4d8a400ef5fe9e596350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98b265d97ebd619e7732df6a8d1f7da"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad98b265d97ebd619e7732df6a8d1f7da"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00207.html#ad98b265d97ebd619e7732df6a8d1f7da">flatVectorView</a> (T &amp;t)</td></tr>
<tr class="memdesc:ad98b265d97ebd619e7732df6a8d1f7da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create flat vector view of passed mutable container.  <a href="a00207.html#ad98b265d97ebd619e7732df6a8d1f7da">More...</a><br /></td></tr>
<tr class="separator:ad98b265d97ebd619e7732df6a8d1f7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37c350bd2f6cb4fea793ac4f665c0fe"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac37c350bd2f6cb4fea793ac4f665c0fe"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00207.html#ac37c350bd2f6cb4fea793ac4f665c0fe">flatVectorView</a> (const T &amp;t)</td></tr>
<tr class="memdesc:ac37c350bd2f6cb4fea793ac4f665c0fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create flat vector view of passed const container.  <a href="a00207.html#ac37c350bd2f6cb4fea793ac4f665c0fe">More...</a><br /></td></tr>
<tr class="separator:ac37c350bd2f6cb4fea793ac4f665c0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fac6802f21000f59e52aade3cd47b08"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4fac6802f21000f59e52aade3cd47b08"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00207.html#a4fac6802f21000f59e52aade3cd47b08">flatVectorView</a> (T &amp;&amp;t)</td></tr>
<tr class="memdesc:a4fac6802f21000f59e52aade3cd47b08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create flat vector view of passed container temporary.  <a href="a00207.html#a4fac6802f21000f59e52aade3cd47b08">More...</a><br /></td></tr>
<tr class="separator:a4fac6802f21000f59e52aade3cd47b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74497c764d8ce0b365abae3637dadc8"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:aa74497c764d8ce0b365abae3637dadc8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01652.html">HierarchicVectorWrapper</a>&lt; V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00207.html#aa74497c764d8ce0b365abae3637dadc8">hierarchicVector</a> (V &amp;v)</td></tr>
<tr class="separator:aa74497c764d8ce0b365abae3637dadc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12dae1e674d190f9f5490e8cbb31eb10"><td class="memTemplParams" colspan="2">template&lt;class MultiIndex , class V , typename std::enable_if&lt; models&lt; Concept::HasIndexAccess, V, MultiIndex &gt;(), int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a12dae1e674d190f9f5490e8cbb31eb10"><td class="memTemplItemLeft" align="right" valign="top">V &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00207.html#a12dae1e674d190f9f5490e8cbb31eb10">makeHierarchicVectorForMultiIndex</a> (V &amp;v)</td></tr>
<tr class="separator:a12dae1e674d190f9f5490e8cbb31eb10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48bf799daaf0751086b47457350675e"><td class="memTemplParams" colspan="2">template&lt;class MultiIndex , class V , typename std::enable_if&lt; not models&lt; Concept::HasIndexAccess, V, MultiIndex &gt;(), int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ae48bf799daaf0751086b47457350675e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01652.html">HierarchicVectorWrapper</a>&lt; V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00207.html#ae48bf799daaf0751086b47457350675e">makeHierarchicVectorForMultiIndex</a> (V &amp;v)</td></tr>
<tr class="separator:ae48bf799daaf0751086b47457350675e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b0c6bf02d744e7b2078d1a535b5211"><td class="memTemplParams" colspan="2">template&lt;class B , class C , class F , class BV , class NTRE &gt; </td></tr>
<tr class="memitem:a13b0c6bf02d744e7b2078d1a535b5211"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00207.html#a13b0c6bf02d744e7b2078d1a535b5211">interpolate</a> (const B &amp;basis, C &amp;&amp;coeff, const F &amp;f, const BV &amp;bv, const NTRE &amp;nodeToRangeEntry)</td></tr>
<tr class="memdesc:a13b0c6bf02d744e7b2078d1a535b5211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate given function in discrete function space.  <a href="a00207.html#a13b0c6bf02d744e7b2078d1a535b5211">More...</a><br /></td></tr>
<tr class="separator:a13b0c6bf02d744e7b2078d1a535b5211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae167dc7b5ace0ff9617a3205b05744b5"><td class="memTemplParams" colspan="2">template&lt;class B , class C , class F , class BV &gt; </td></tr>
<tr class="memitem:ae167dc7b5ace0ff9617a3205b05744b5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00207.html#ae167dc7b5ace0ff9617a3205b05744b5">interpolate</a> (const B &amp;basis, C &amp;&amp;coeff, const F &amp;f, const BV &amp;bitVector)</td></tr>
<tr class="memdesc:ae167dc7b5ace0ff9617a3205b05744b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate given function in discrete function space.  <a href="a00207.html#ae167dc7b5ace0ff9617a3205b05744b5">More...</a><br /></td></tr>
<tr class="separator:ae167dc7b5ace0ff9617a3205b05744b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e34859322800ae26a292903910ef9f7"><td class="memTemplParams" colspan="2">template&lt;class B , class C , class F &gt; </td></tr>
<tr class="memitem:a2e34859322800ae26a292903910ef9f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00207.html#a2e34859322800ae26a292903910ef9f7">interpolate</a> (const B &amp;basis, C &amp;&amp;coeff, const F &amp;f)</td></tr>
<tr class="memdesc:a2e34859322800ae26a292903910ef9f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate given function in discrete function space.  <a href="a00207.html#a2e34859322800ae26a292903910ef9f7">More...</a><br /></td></tr>
<tr class="separator:a2e34859322800ae26a292903910ef9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475e15e64943b3461f2f87a7805a3c8e"><td class="memTemplParams" colspan="2">template&lt;typename Tree &gt; </td></tr>
<tr class="memitem:a475e15e64943b3461f2f87a7805a3c8e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00207.html#a475e15e64943b3461f2f87a7805a3c8e">clearSize</a> (Tree &amp;tree, std::size_t offset)</td></tr>
<tr class="separator:a475e15e64943b3461f2f87a7805a3c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc892a209e0f55bc65eadaf2c808454"><td class="memTemplParams" colspan="2">template&lt;typename Tree , typename Entity &gt; </td></tr>
<tr class="memitem:a4dc892a209e0f55bc65eadaf2c808454"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00207.html#a4dc892a209e0f55bc65eadaf2c808454">bindTree</a> (Tree &amp;tree, const Entity &amp;entity, std::size_t offset=0)</td></tr>
<tr class="separator:a4dc892a209e0f55bc65eadaf2c808454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e19b913a34ad68144f4fd873c51b977"><td class="memTemplParams" colspan="2">template&lt;typename Tree &gt; </td></tr>
<tr class="memitem:a5e19b913a34ad68144f4fd873c51b977"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00207.html#a5e19b913a34ad68144f4fd873c51b977">initializeTree</a> (Tree &amp;tree, std::size_t treeIndexOffset=0)</td></tr>
<tr class="separator:a5e19b913a34ad68144f4fd873c51b977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7076a1d0d200fecdaec99b0d4348b7"><td class="memTemplParams" colspan="2">template&lt;class Basis &gt; </td></tr>
<tr class="memitem:aee7076a1d0d200fecdaec99b0d4348b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01828.html">SizeInfo</a>&lt; Basis &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00207.html#aee7076a1d0d200fecdaec99b0d4348b7">sizeInfo</a> (const Basis &amp;basis)</td></tr>
<tr class="separator:aee7076a1d0d200fecdaec99b0d4348b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae09b88262b86388c9c65d4af1a00aa1f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gae09b88262b86388c9c65d4af1a00aa1f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#gae09b88262b86388c9c65d4af1a00aa1f">subEntityDOFs</a> (const T &amp;t)</td></tr>
<tr class="memdesc:gae09b88262b86388c9c65d4af1a00aa1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="a01832.html" title="Range of DOFs associated to sub-entity.">SubEntityDOFs</a> object.  <a href="a00202.html#gae09b88262b86388c9c65d4af1a00aa1f">More...</a><br /></td></tr>
<tr class="separator:gae09b88262b86388c9c65d4af1a00aa1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5803226b1ed4bf848a9532181c952244"><td class="memTemplParams" colspan="2">template&lt;class LocalView &gt; </td></tr>
<tr class="memitem:ga5803226b1ed4bf848a9532181c952244"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#ga5803226b1ed4bf848a9532181c952244">subEntityDOFs</a> (const LocalView &amp;localView, std::size_t subEntityIndex, std::size_t subEntityCodim)</td></tr>
<tr class="memdesc:ga5803226b1ed4bf848a9532181c952244"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create bound <a class="el" href="a01832.html" title="Range of DOFs associated to sub-entity.">SubEntityDOFs</a> object.  <a href="a00202.html#ga5803226b1ed4bf848a9532181c952244">More...</a><br /></td></tr>
<tr class="separator:ga5803226b1ed4bf848a9532181c952244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09ad7987f85909bfcf269a0de9c652d8"><td class="memTemplParams" colspan="2">template&lt;class LocalView , class Intersection &gt; </td></tr>
<tr class="memitem:ga09ad7987f85909bfcf269a0de9c652d8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#ga09ad7987f85909bfcf269a0de9c652d8">subEntityDOFs</a> (const LocalView &amp;localView, const Intersection &amp;intersection)</td></tr>
<tr class="memdesc:ga09ad7987f85909bfcf269a0de9c652d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create bound <a class="el" href="a01832.html" title="Range of DOFs associated to sub-entity.">SubEntityDOFs</a> object.  <a href="a00202.html#ga09ad7987f85909bfcf269a0de9c652d8">More...</a><br /></td></tr>
<tr class="separator:ga09ad7987f85909bfcf269a0de9c652d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9effbb98da0e9104a60979fa734c1220"><td class="memTemplParams" colspan="2">template&lt;class RootBasis , class... PrefixTreeIndices&gt; </td></tr>
<tr class="memitem:a9effbb98da0e9104a60979fa734c1220"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00207.html#a9effbb98da0e9104a60979fa734c1220">subspaceBasis</a> (const RootBasis &amp;rootBasis, const TypeTree::HybridTreePath&lt; PrefixTreeIndices... &gt; &amp;prefixPath)</td></tr>
<tr class="separator:a9effbb98da0e9104a60979fa734c1220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8781cf3fb98ca29446be66bcf65ac4"><td class="memTemplParams" colspan="2">template&lt;class RootBasis , class... PrefixTreeIndices&gt; </td></tr>
<tr class="memitem:abb8781cf3fb98ca29446be66bcf65ac4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00207.html#abb8781cf3fb98ca29446be66bcf65ac4">subspaceBasis</a> (const RootBasis &amp;rootBasis, const PrefixTreeIndices &amp;... prefixTreeIndices)</td></tr>
<tr class="separator:abb8781cf3fb98ca29446be66bcf65ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a471f45051ed25e237bfe9a81adb20eb4"><td class="memTemplParams" colspan="2">template&lt;class F , class GridView &gt; </td></tr>
<tr class="memitem:a471f45051ed25e237bfe9a81adb20eb4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01880.html">AnalyticGridViewFunction</a>&lt; typename std::result_of&lt; F(typename GridView::template Codim&lt; 0 &gt;::Geometry::GlobalCoordinate)&gt;::type(typename GridView::template Codim&lt; 0 &gt;::Geometry::GlobalCoordinate), GridView, typename std::decay&lt; F &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00207.html#a471f45051ed25e237bfe9a81adb20eb4">makeAnalyticGridViewFunction</a> (F &amp;&amp;f, const GridView &amp;gridView)</td></tr>
<tr class="memdesc:a471f45051ed25e237bfe9a81adb20eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct <a class="el" href="a01880.html">AnalyticGridViewFunction</a> from function and grid view.  <a href="a00207.html#a471f45051ed25e237bfe9a81adb20eb4">More...</a><br /></td></tr>
<tr class="separator:a471f45051ed25e237bfe9a81adb20eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65a144489c2841d44f67fe62cf98f3f3"><td class="memTemplParams" colspan="2">template&lt;typename... TT&gt; </td></tr>
<tr class="memitem:ga65a144489c2841d44f67fe62cf98f3f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00197.html#ga65a144489c2841d44f67fe62cf98f3f3">localFunction</a> (<a class="el" href="a01888.html">DiscreteGlobalBasisFunction</a>&lt; TT... &gt; &amp;&amp;t)=delete</td></tr>
<tr class="memdesc:ga65a144489c2841d44f67fe62cf98f3f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction of local functions from a temporary <a class="el" href="a01888.html" title="A grid function induced by a global basis and a coefficient vector.">DiscreteGlobalBasisFunction</a> (forbidden)  <a href="a00197.html#ga65a144489c2841d44f67fe62cf98f3f3">More...</a><br /></td></tr>
<tr class="separator:ga65a144489c2841d44f67fe62cf98f3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f1349f01c550144fcb58d3cbb85684"><td class="memTemplParams" colspan="2">template&lt;typename R , typename B , typename V &gt; </td></tr>
<tr class="memitem:a56f1349f01c550144fcb58d3cbb85684"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00207.html#a56f1349f01c550144fcb58d3cbb85684">makeDiscreteGlobalBasisFunction</a> (B &amp;&amp;basis, V &amp;&amp;vector)</td></tr>
<tr class="separator:a56f1349f01c550144fcb58d3cbb85684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66025b0e668b0f22585efc8715049077"><td class="memTemplParams" colspan="2">template&lt;class F , class GridView , typename std::enable_if&lt; models&lt; Imp::HasFreeLocalFunction, F &gt;(), int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a66025b0e668b0f22585efc8715049077"><td class="memTemplItemLeft" align="right" valign="top">std::decay&lt; F &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00207.html#a66025b0e668b0f22585efc8715049077">makeGridViewFunction</a> (F &amp;&amp;f, const GridView &amp;gridView)</td></tr>
<tr class="memdesc:a66025b0e668b0f22585efc8715049077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a function modeling <a class="el" href="a01924.html">GridViewFunction</a> from function and grid view.  <a href="a00207.html#a66025b0e668b0f22585efc8715049077">More...</a><br /></td></tr>
<tr class="separator:a66025b0e668b0f22585efc8715049077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f2d140a1fed46862286f68d26c9975"><td class="memTemplParams" colspan="2">template&lt;class F , class GridView , typename std::enable_if&lt; not(models&lt; Imp::HasFreeLocalFunction, F &gt;()), int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a34f2d140a1fed46862286f68d26c9975"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00207.html#a34f2d140a1fed46862286f68d26c9975">makeGridViewFunction</a> (F &amp;&amp;f, const GridView &amp;gridView) -&gt; decltype(<a class="el" href="a00207.html#a471f45051ed25e237bfe9a81adb20eb4">makeAnalyticGridViewFunction</a>(std::forward&lt; F &gt;(f), gridView))</td></tr>
<tr class="memdesc:a34f2d140a1fed46862286f68d26c9975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a function modeling <a class="el" href="a01924.html">GridViewFunction</a> from function and grid view.  <a href="a00207.html#a34f2d140a1fed46862286f68d26c9975">More...</a><br /></td></tr>
<tr class="separator:a34f2d140a1fed46862286f68d26c9975"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="aa7b968ee05cd46e1c58beaf32eef881e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b968ee05cd46e1c58beaf32eef881e">&#9670;&nbsp;</a></span>BrezziDouglasMariniBasis</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GV , int k&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00207.html#aa7b968ee05cd46e1c58beaf32eef881e">Dune::Functions::BrezziDouglasMariniBasis</a> = typedef <a class="el" href="a01548.html">DefaultGlobalBasis</a>&lt;<a class="el" href="a01444.html">BrezziDouglasMariniPreBasis</a>&lt;GV, k, <a class="el" href="a01572.html">FlatMultiIndex</a>&lt;std::size_t&gt; &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Basis of a scalar k-th-order BDM finite element space on simplex and cube grids. </p>
<p>TODO: Fix this for grids with more than one element type</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GV</td><td>The GridView that the space is defined on </td></tr>
    <tr><td class="paramname">k</td><td>The order of the basis </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7adaea3a8e209aef72602f07a6988b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7adaea3a8e209aef72602f07a6988b3">&#9670;&nbsp;</a></span>IntegerSequenceTuple</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IntegerSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00207.html#ad7adaea3a8e209aef72602f07a6988b3">Dune::Functions::IntegerSequenceTuple</a> = typedef typename Imp::IntegerSequenceTupleHelper&lt;IntegerSequence&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform integer_sequence&lt;I,k...&gt; to tuple&lt;integral_constant&lt;I,k&gt;...&gt; </p>

</div>
</div>
<a id="afa871daf79a93a0f0b19e6e480b41c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa871daf79a93a0f0b19e6e480b41c95">&#9670;&nbsp;</a></span>LagrangeDGNode</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GV , int k&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00207.html#afa871daf79a93a0f0b19e6e480b41c95">Dune::Functions::LagrangeDGNode</a> = typedef <a class="el" href="a01672.html">LagrangeNode</a>&lt;GV, k&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a37c0aec3888b5baa3957c2fe67034d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37c0aec3888b5baa3957c2fe67034d2b">&#9670;&nbsp;</a></span>NedelecBasis</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GV , std::size_t kind, std::size_t order, typename Range  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00207.html#a37c0aec3888b5baa3957c2fe67034d2b">Dune::Functions::NedelecBasis</a> = typedef <a class="el" href="a01548.html">DefaultGlobalBasis</a>&lt;<a class="el" href="a01704.html">NedelecPreBasis</a>&lt;GV, Range, kind, order, <a class="el" href="a01572.html">FlatMultiIndex</a>&lt;std::size_t&gt; &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Basis of a k-th-order Nédélec finite element space. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GV</td><td>The GridView that the space is defined on </td></tr>
    <tr><td class="paramname">Range</td><td>Number type used for shape function values </td></tr>
    <tr><td class="paramname">kind</td><td>Kind of the basis: 1 (for Nédélec element of the first kind) or 2 </td></tr>
    <tr><td class="paramname">order</td><td>The order of the basis (lowest order is '1') </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5c434b1f2c172a6e65d2ff92d3460cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c434b1f2c172a6e65d2ff92d3460cb">&#9670;&nbsp;</a></span>Optional</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00207.html#ae5c434b1f2c172a6e65d2ff92d3460cb">Dune::Functions::Optional</a> = typedef std::optional&lt; T &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8026cfdb4342677d34821811110ac75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8026cfdb4342677d34821811110ac75">&#9670;&nbsp;</a></span>RaviartThomasBasis</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GV , int k&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a00207.html#ac8026cfdb4342677d34821811110ac75">Dune::Functions::RaviartThomasBasis</a> = typedef <a class="el" href="a01548.html">DefaultGlobalBasis</a>&lt;<a class="el" href="a01820.html">RaviartThomasPreBasis</a>&lt;GV, k, <a class="el" href="a01572.html">FlatMultiIndex</a>&lt;std::size_t&gt; &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Basis of a k-th-order Raviart Thomas finite element space. </p>
<p>TODO: Fix this for grids with more than one element type</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GV</td><td>The GridView that the space is defined on </td></tr>
    <tr><td class="paramname">k</td><td>The order of the basis </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a4dc892a209e0f55bc65eadaf2c808454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dc892a209e0f55bc65eadaf2c808454">&#9670;&nbsp;</a></span>bindTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tree , typename Entity &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::Functions::bindTree </td>
          <td>(</td>
          <td class="paramtype">Tree &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Entity &amp;&#160;</td>
          <td class="paramname"><em>entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a475e15e64943b3461f2f87a7805a3c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a475e15e64943b3461f2f87a7805a3c8e">&#9670;&nbsp;</a></span>clearSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tree &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::Functions::clearSize </td>
          <td>(</td>
          <td class="paramtype">Tree &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0a3b4e397e76b3d02cb06a7793fdb7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a3b4e397e76b3d02cb06a7793fdb7b">&#9670;&nbsp;</a></span>fieldTypes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto Dune::Functions::fieldTypes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate list of field types in container. </p>
<p>This generates a Dune::TypeList of the field types in the given container type. To determine the field types, operator[] is called as often as passible with std::size_t or Dune::index_constant arguments. The return types obtained if no more operator[] call is available are returned as Dune::TypeList. Notice that possible duplicate entries are removed. However, const and reference qualifiers are deliberately preserved. </p>

</div>
</div>
<a id="ac37c350bd2f6cb4fea793ac4f665c0fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac37c350bd2f6cb4fea793ac4f665c0fe">&#9670;&nbsp;</a></span>flatVectorView() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Dune::Functions::flatVectorView </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create flat vector view of passed const container. </p>
<p>When passed a nested container, the resulting value is a flat-vector-like view object. It provides an operator[] method to access all entries of the underlying nested container using flat consecutive indices and a size() method to compute the corresponding total size.</p>
<p>This method will create a view object storing a pointer to the passed const container. </p>

</div>
</div>
<a id="a4fac6802f21000f59e52aade3cd47b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fac6802f21000f59e52aade3cd47b08">&#9670;&nbsp;</a></span>flatVectorView() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Dune::Functions::flatVectorView </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create flat vector view of passed container temporary. </p>
<p>When passed a nested container, the resulting value is a flat-vector-like view object. It provides an operator[] method to access all entries of the underlying nested container using flat consecutive indices and a size() method to compute the corresponding total size.</p>
<p>This method will create a 'view' object storing the provided temporary container by value. </p>

</div>
</div>
<a id="ad98b265d97ebd619e7732df6a8d1f7da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad98b265d97ebd619e7732df6a8d1f7da">&#9670;&nbsp;</a></span>flatVectorView() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Dune::Functions::flatVectorView </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create flat vector view of passed mutable container. </p>
<p>When passed a nested container, the resulting value is a flat-vector-like view object. It provides an operator[] method to access all entries of the underlying nested container using flat consecutive indices and a size() method to compute the corresponding total size.</p>
<p>This method will create a view object storing a pointer to the passed mutable container. </p>

</div>
</div>
<a id="a84f8a9700ef8b12973e210ee4674c2b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84f8a9700ef8b12973e210ee4674c2b7">&#9670;&nbsp;</a></span>forwardAsStaticInteger() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class size_type , size_type firstValue, class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Dune::Functions::forwardAsStaticInteger </td>
          <td>(</td>
          <td class="paramtype">std::integer_sequence&lt; size_type, firstValue &gt;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(f(std::integral_constant&lt;size_type, firstValue&gt;(), std::forward&lt;Args&gt;(args)...))
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e975086fb37cbf3e33cc42a2b4ef1e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e975086fb37cbf3e33cc42a2b4ef1e2">&#9670;&nbsp;</a></span>forwardAsStaticInteger() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class size_type , size_type firstValue, size_type secondValue, size_type... otherValues, class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Dune::Functions::forwardAsStaticInteger </td>
          <td>(</td>
          <td class="paramtype">std::integer_sequence&lt; size_type, firstValue, secondValue, otherValues... &gt;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_type&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(f(std::integral_constant&lt;size_type, firstValue&gt;(), std::forward&lt;Args&gt;(args)...))
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6bb3a351c2ab1b4eb46d4ba1ec3d95a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bb3a351c2ab1b4eb46d4ba1ec3d95a0">&#9670;&nbsp;</a></span>forwardCapture()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Dune::Functions::forwardCapture </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a capture object for perfect forwarding. </p>
<p>The returned object will capture the passed argument t. If t is passed as r-value, then it is captured by value, otherwise by reference. The captured value is accessible once using the forward() method which either returns the catured reference or moves the captured value.</p>
<p>This allows to capture values for perfect forwarding in lambda functions using [t=forwardCapture(std::forward&lt;T&gt;(t))]() -&gt; decltype(auto) { return t.forward(); } </p>

</div>
</div>
<a id="af8b09a0411c63ab6a6500a7b6edb9dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8b09a0411c63ab6a6500a7b6edb9dfb">&#9670;&nbsp;</a></span>hasUniqueFieldType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool Dune::Functions::hasUniqueFieldType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if container has a unique field type. </p>
<p>This returns if <a class="el" href="a00207.html#ad0a3b4e397e76b3d02cb06a7793fdb7b" title="Generate list of field types in container.">fieldTypes&lt;V&gt;()</a> has exactly one entry. </p>

</div>
</div>
<a id="aa74497c764d8ce0b365abae3637dadc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa74497c764d8ce0b365abae3637dadc8">&#9670;&nbsp;</a></span>hierarchicVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01652.html">HierarchicVectorWrapper</a>&lt; V &gt; Dune::Functions::hierarchicVector </td>
          <td>(</td>
          <td class="paramtype">V &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga2226fe3a86eb176df27c9801a98a10ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2226fe3a86eb176df27c9801a98a10ae">&#9670;&nbsp;</a></span>hybridIndexAccess()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class I , class F , typename std::enable_if&lt; not Dune::models&lt; Imp::Concept::HasDynamicIndexAccess&lt; I &gt;, C &gt;(), int &gt;::type  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) Dune::Functions::hybridIndexAccess </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide operator[] index-access for containers. </p>
<p>This is the overload for types providing a operator[] only for static arguments of type std::integral_constant&lt;std::size_t,k&gt;. This does a static linear search until a static index matching the given dynamic index is found. Since the result type will in general be different for different indices the method does not return the result directly but passes it to a given functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Container to access </td></tr>
    <tr><td class="paramname">i</td><td>The index to use for accessing the container </td></tr>
    <tr><td class="paramname">f</td><td>A functor to call with the result of operator[] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e19b913a34ad68144f4fd873c51b977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e19b913a34ad68144f4fd873c51b977">&#9670;&nbsp;</a></span>initializeTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tree &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::Functions::initializeTree </td>
          <td>(</td>
          <td class="paramtype">Tree &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>treeIndexOffset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e34859322800ae26a292903910ef9f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e34859322800ae26a292903910ef9f7">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class C , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::Functions::interpolate </td>
          <td>(</td>
          <td class="paramtype">const B &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate given function in discrete function space. </p>
<p>Notice that this will only work if the range type of f and the block type of coeff are compatible and supported by flatVectorView.</p>
<p>This function will only work, if the local ansatz tree of the basis is trivial, i.e., a single leaf node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis</td><td>Global function space basis of discrete function space </td></tr>
    <tr><td class="paramname">coeff</td><td>Coefficient vector to represent the interpolation </td></tr>
    <tr><td class="paramname">f</td><td>Function to interpolate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae167dc7b5ace0ff9617a3205b05744b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae167dc7b5ace0ff9617a3205b05744b5">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class C , class F , class BV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::Functions::interpolate </td>
          <td>(</td>
          <td class="paramtype">const B &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BV &amp;&#160;</td>
          <td class="paramname"><em>bitVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate given function in discrete function space. </p>
<p>Only vector coefficients marked as 'true' in the bitVector argument are interpolated. Use this, e.g., to interpolate Dirichlet boundary values.</p>
<p>Notice that this will only work if the range type of f and the block type of coeff are compatible and supported by flatVectorView.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis</td><td>Global function space basis of discrete function space </td></tr>
    <tr><td class="paramname">coeff</td><td>Coefficient vector to represent the interpolation </td></tr>
    <tr><td class="paramname">f</td><td>Function to interpolate </td></tr>
    <tr><td class="paramname">bitVector</td><td>A vector with flags marking all DOFs that should be interpolated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13b0c6bf02d744e7b2078d1a535b5211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b0c6bf02d744e7b2078d1a535b5211">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B , class C , class F , class BV , class NTRE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::Functions::interpolate </td>
          <td>(</td>
          <td class="paramtype">const B &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BV &amp;&#160;</td>
          <td class="paramname"><em>bv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTRE &amp;&#160;</td>
          <td class="paramname"><em>nodeToRangeEntry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate given function in discrete function space. </p>
<p>Only vector coefficients marked as 'true' in the bitVector argument are interpolated. Use this, e.g., to interpolate Dirichlet boundary values.</p>
<p>Notice that this will only work if the range type of f and the block type of coeff are compatible and supported by flatVectorView.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis</td><td>Global function space basis of discrete function space </td></tr>
    <tr><td class="paramname">coeff</td><td>Coefficient vector to represent the interpolation </td></tr>
    <tr><td class="paramname">f</td><td>Function to interpolate </td></tr>
    <tr><td class="paramname">bitVector</td><td>A vector with flags marking all DOFs that should be interpolated </td></tr>
    <tr><td class="paramname">nodeToRangeEntry</td><td>Polymorphic functor mapping local ansatz nodes to range-indices of given function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a471f45051ed25e237bfe9a81adb20eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a471f45051ed25e237bfe9a81adb20eb4">&#9670;&nbsp;</a></span>makeAnalyticGridViewFunction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class GridView &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01880.html">AnalyticGridViewFunction</a>&lt; typename std::result_of&lt;F(typename GridView::template Codim&lt;0&gt;::Geometry::GlobalCoordinate)&gt;::type (typename GridView::template Codim&lt;0&gt;::Geometry::GlobalCoordinate), GridView, typename std::decay&lt;F&gt;::type &gt; Dune::Functions::makeAnalyticGridViewFunction </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridView &amp;&#160;</td>
          <td class="paramname"><em>gridView</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct <a class="el" href="a01880.html">AnalyticGridViewFunction</a> from function and grid view. </p>
<p>The returned function supports <a class="el" href="a00197.html#ga65a144489c2841d44f67fe62cf98f3f3" title="Construction of local functions from a temporary DiscreteGlobalBasisFunction (forbidden)">localFunction()</a> and stores a copy of the original function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function object supporting argument compatible with global coordinates </td></tr>
    <tr><td class="paramname">gridView</td><td>The GridView the function should act on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A function that models the <a class="el" href="a01896.html">GridFunction</a> interface. </dd></dl>

</div>
</div>
<a id="ad5971c4cc40d4d8a400ef5fe9e596350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5971c4cc40d4d8a400ef5fe9e596350">&#9670;&nbsp;</a></span>makeDefaultNodeToRangeMap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Basis , class TreePath &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Dune::Functions::makeDefaultNodeToRangeMap </td>
          <td>(</td>
          <td class="paramtype">const Basis &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TreePath &amp;&amp;&#160;</td>
          <td class="paramname"><em>treePath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(makeDefaultNodeToRangeMap(TypeTree::child(basis.localView().tree(),treePath)))
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab1ba8b217ca5a05cddfe065e8191699e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ba8b217ca5a05cddfe065e8191699e">&#9670;&nbsp;</a></span>makeDefaultNodeToRangeMap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Tree &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01564.html">DefaultNodeToRangeMap</a>&lt;Tree&gt; Dune::Functions::makeDefaultNodeToRangeMap </td>
          <td>(</td>
          <td class="paramtype">const Tree &amp;&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a56f1349f01c550144fcb58d3cbb85684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56f1349f01c550144fcb58d3cbb85684">&#9670;&nbsp;</a></span>makeDiscreteGlobalBasisFunction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename B , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Dune::Functions::makeDiscreteGlobalBasisFunction </td>
          <td>(</td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a66025b0e668b0f22585efc8715049077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66025b0e668b0f22585efc8715049077">&#9670;&nbsp;</a></span>makeGridViewFunction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class GridView , typename std::enable_if&lt; models&lt; Imp::HasFreeLocalFunction, F &gt;(), int &gt;::type  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::decay&lt;F&gt;::type Dune::Functions::makeGridViewFunction </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridView &amp;&#160;</td>
          <td class="paramname"><em>gridView</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a function modeling <a class="el" href="a01924.html">GridViewFunction</a> from function and grid view. </p>
<p>This spezialization is used for functions that already support <a class="el" href="a00197.html#ga65a144489c2841d44f67fe62cf98f3f3" title="Construction of local functions from a temporary DiscreteGlobalBasisFunction (forbidden)">localFunction()</a>. It will simply return a copy of f.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function object supporting argument compatible with global coordinates </td></tr>
    <tr><td class="paramname">gridView</td><td>The GridView the function should act on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A function that models the <a class="el" href="a01924.html">GridViewFunction</a> interface. </dd></dl>

</div>
</div>
<a id="a34f2d140a1fed46862286f68d26c9975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f2d140a1fed46862286f68d26c9975">&#9670;&nbsp;</a></span>makeGridViewFunction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class GridView , typename std::enable_if&lt; not(models&lt; Imp::HasFreeLocalFunction, F &gt;()), int &gt;::type  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Dune::Functions::makeGridViewFunction </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GridView &amp;&#160;</td>
          <td class="paramname"><em>gridView</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="a00207.html#a471f45051ed25e237bfe9a81adb20eb4">makeAnalyticGridViewFunction</a>(std::forward&lt;F&gt;(f), gridView))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a function modeling <a class="el" href="a01924.html">GridViewFunction</a> from function and grid view. </p>
<p>This spezialization is used for functions that do not support <a class="el" href="a00197.html#ga65a144489c2841d44f67fe62cf98f3f3" title="Construction of local functions from a temporary DiscreteGlobalBasisFunction (forbidden)">localFunction()</a> themselves. It will forward to makeAnalyticGridViewFunction. Notice that the returned function will store a copy of the original function and a pointer to the GridView. It can only be used as long as the latter exists. Hence you must take care to store the GridView yourself. </p><dl class="todo"><dt><b><a class="el" href="a00191.html#_todo000013">Todo:</a></b></dt><dd>Should we store a copy of the GridView?</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function object supporting argument compatible with global coordinates </td></tr>
    <tr><td class="paramname">gridView</td><td>The GridView the function should act on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A function that models the <a class="el" href="a01896.html">GridFunction</a> interface. </dd></dl>

</div>
</div>
<a id="a12dae1e674d190f9f5490e8cbb31eb10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12dae1e674d190f9f5490e8cbb31eb10">&#9670;&nbsp;</a></span>makeHierarchicVectorForMultiIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MultiIndex , class V , typename std::enable_if&lt; models&lt; Concept::HasIndexAccess, V, MultiIndex &gt;(), int &gt;::type  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V&amp; Dune::Functions::makeHierarchicVectorForMultiIndex </td>
          <td>(</td>
          <td class="paramtype">V &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae48bf799daaf0751086b47457350675e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae48bf799daaf0751086b47457350675e">&#9670;&nbsp;</a></span>makeHierarchicVectorForMultiIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MultiIndex , class V , typename std::enable_if&lt; not models&lt; Concept::HasIndexAccess, V, MultiIndex &gt;(), int &gt;::type  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01652.html">HierarchicVectorWrapper</a>&lt; V &gt; Dune::Functions::makeHierarchicVectorForMultiIndex </td>
          <td>(</td>
          <td class="paramtype">V &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aee7076a1d0d200fecdaec99b0d4348b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7076a1d0d200fecdaec99b0d4348b7">&#9670;&nbsp;</a></span>sizeInfo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Basis &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01828.html">SizeInfo</a>&lt;Basis&gt; Dune::Functions::sizeInfo </td>
          <td>(</td>
          <td class="paramtype">const Basis &amp;&#160;</td>
          <td class="paramname"><em>basis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abb8781cf3fb98ca29446be66bcf65ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8781cf3fb98ca29446be66bcf65ac4">&#9670;&nbsp;</a></span>subspaceBasis() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RootBasis , class... PrefixTreeIndices&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Dune::Functions::subspaceBasis </td>
          <td>(</td>
          <td class="paramtype">const RootBasis &amp;&#160;</td>
          <td class="paramname"><em>rootBasis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PrefixTreeIndices &amp;...&#160;</td>
          <td class="paramname"><em>prefixTreeIndices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9effbb98da0e9104a60979fa734c1220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9effbb98da0e9104a60979fa734c1220">&#9670;&nbsp;</a></span>subspaceBasis() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RootBasis , class... PrefixTreeIndices&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Dune::Functions::subspaceBasis </td>
          <td>(</td>
          <td class="paramtype">const RootBasis &amp;&#160;</td>
          <td class="paramname"><em>rootBasis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TypeTree::HybridTreePath&lt; PrefixTreeIndices... &gt; &amp;&#160;</td>
          <td class="paramname"><em>prefixPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
