<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>dune-typetree: Dune::TypeTree Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">dune-typetree
   &#160;<span id="projectnumber">2.8.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00097.html">Dune</a></li><li class="navelem"><a class="el" href="a00098.html">TypeTree</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Dune::TypeTree Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:a00107"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00107.html">apply_to_tuple_policy</a></td></tr>
<tr class="memdesc:a00107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policies for the function <a class="el" href="a00090.html#ga74366514796c2f1ee6a2f8a41fdd8e90" title="Apply a functor to each element of a std::tuple.">apply_to_tuple()</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00103"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html">Detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00100"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00100.html">Experimental</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00106"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00106.html">impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00105"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00105.html">TreePathType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00925.html">or_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically combine two values of type result_type using ||.  <a href="a00925.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00933.html">and_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically combine two values of type result_type using &amp;&amp;.  <a href="a00933.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00941.html">plus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically combine two values of type result_type using +.  <a href="a00941.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00949.html">minus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically combine two values of type result_type using -.  <a href="a00949.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00957.html">multiply</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically combine two values of type result_type using *.  <a href="a00957.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00965.html">min</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically combine two values of type result_type by returning their minimum.  <a href="a00965.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00973.html">max</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically combine two values of type result_type by returning their maximum.  <a href="a00973.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01017.html">AccumulateValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically accumulate a value over the nodes of a <a class="el" href="a00098.html">TypeTree</a>.  <a href="a01017.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01069.html">TypeAccumulationPolicy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01073.html">AccumulateType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically accumulate a type over the nodes of a <a class="el" href="a00098.html">TypeTree</a>.  <a href="a01073.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01077.html">CompositeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for composite nodes based on variadic templates.  <a href="a01077.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01085.html">DynamicPowerNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect multiple instances of type T within a <a class="el" href="a00090.html">dune-typetree</a>.  <a href="a01085.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01089.html">Exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all <a class="el" href="a00098.html">TypeTree</a> exceptions.  <a href="a01089.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01093.html">FilteredCompositeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for composite nodes representing a filtered view on an underlying composite node.  <a href="a01093.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01105.html">FilterEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A filter entry describing the mapping of one child in the filtered node.  <a href="a01105.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01109.html">FilterResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result of a filter.  <a href="a01109.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01117.html">SimpleFilterTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag describing a simple filter that can only decide whether or not to include a single given child.  <a href="a01117.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01121.html">AdvancedFilterTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag describing an advanced filter that has full control over the construction of the list of FilterEntries.  <a href="a01121.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01125.html">AdvancedFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for advanced filters.  <a href="a01125.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01133.html">SimpleFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default simple filter that accepts any node and leaves its child structure unchanged.  <a href="a01133.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01161.html">IndexFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter class for <a class="el" href="a01093.html" title="Base class for composite nodes representing a filtered view on an underlying composite node.">FilteredCompositeNode</a> that selects the children with the given indices.  <a href="a01161.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01181.html">filter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapter class that takes a <a class="el" href="a01133.html" title="Default simple filter that accepts any node and leaves its child structure unchanged.">SimpleFilter</a>, validated it and turns it into an <a class="el" href="a01125.html" title="Base class for advanced filters.">AdvancedFilter</a>.  <a href="a01181.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01189.html">FixedCapacityStackView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01197.html">FixedCapacityStack</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01201.html">GenericLeafNodeTransformation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01205.html">TemplatizedGenericPowerNodeTransformation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01213.html">GenericPowerNodeTransformation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01217.html">TemplatizedGenericDynamicPowerNodeTransformation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01225.html">GenericDynamicPowerNodeTransformation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01229.html">TemplatizedGenericCompositeNodeTransformation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01237.html">GenericCompositeNodeTransformation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01241.html">LeafNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for leaf nodes in a <a class="el" href="a00090.html">dune-typetree</a>.  <a href="a01241.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01245.html">NodeInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for nodes in a <a class="el" href="a00090.html">dune-typetree</a>.  <a href="a01245.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01249.html">LeafNodeTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag designating a leaf node.  <a href="a01249.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01253.html">PowerNodeTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag designating a power node.  <a href="a01253.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01257.html">DynamicPowerNodeTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag designating a power node with runtime degree.  <a href="a01257.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01261.html">CompositeNodeTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag designating a composite node.  <a href="a01261.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01265.html">GenericPowerNodeTransformationTemplate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01273.html">GenericDynamicPowerNodeTransformationTemplate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01281.html">GenericCompositeNodeTransformationTemplate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01289.html">PowerNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect k instances of type T within a <a class="el" href="a00090.html">dune-typetree</a>.  <a href="a01289.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01297.html">ProxyNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for nodes acting as a proxy for an existing node.  <a href="a01297.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01301.html">StaticChildAccessors</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mixin class providing methods for child access with compile-time parameter.  <a href="a01301.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01313.html">DynamicChildAccessors</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mixin class providing methods for child access with run-time parameter.  <a href="a01313.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01317.html">ProxyNodeBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag-based dispatch to appropriate base class that provides necessary functionality.  <a href="a01317.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01321.html">ProxyNodeBase&lt; Node, LeafNodeTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a01297.html" title="Base class for nodes acting as a proxy for an existing node.">ProxyNode</a> base class for <a class="el" href="a01241.html" title="Base class for leaf nodes in a dune-typetree.">LeafNode</a>.  <a href="a01321.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01325.html">ProxyNodeBase&lt; Node, CompositeNodeTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a01297.html" title="Base class for nodes acting as a proxy for an existing node.">ProxyNode</a> base class for <a class="el" href="a01077.html" title="Base class for composite nodes based on variadic templates.">CompositeNode</a>.  <a href="a01325.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01329.html">ProxyNodeBase&lt; Node, PowerNodeTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a01297.html" title="Base class for nodes acting as a proxy for an existing node.">ProxyNode</a> base class for <a class="el" href="a01289.html" title="Collect k instances of type T within a dune-typetree.">PowerNode</a>.  <a href="a01329.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01333.html">SimpleLeafNodeTransformation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01337.html">SimplePowerNodeTransformation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01345.html">SimpleDynamicPowerNodeTransformation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01353.html">SimpleCompositeNodeTransformation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01361.html">TransformTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a <a class="el" href="a00098.html">TypeTree</a>.  <a href="a01361.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01381.html">HybridTreePath</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hybrid version of TreePath that supports both compile time and run time indices.  <a href="a01381.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01385.html">TreePathSize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01389.html">TreePathPushBack</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01393.html">TreePathPushFront</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01397.html">TreePathBack</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01401.html">TreePathFront</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01405.html">TreePathPopBack</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01409.html">TreePathPopFront</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01413.html">TreePathConcat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01417.html">TreePathSize&lt; HybridTreePath&lt; index_constant&lt; i &gt;... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01421.html">TreePathPushBack&lt; HybridTreePath&lt; index_constant&lt; i &gt;... &gt;, k &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01425.html">TreePathPushFront&lt; HybridTreePath&lt; index_constant&lt; i &gt;... &gt;, k &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01429.html">TreePathBack&lt; HybridTreePath&lt; index_constant&lt; k &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01433.html">TreePathBack&lt; HybridTreePath&lt; index_constant&lt; j &gt;, index_constant&lt; k &gt;, index_constant&lt; l &gt;... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01437.html">TreePathFront&lt; HybridTreePath&lt; index_constant&lt; k &gt;, index_constant&lt; i &gt;... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01441.html">TreePathPopBack&lt; HybridTreePath&lt; index_constant&lt; k &gt; &gt;, i... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01445.html">TreePathPopBack&lt; HybridTreePath&lt; index_constant&lt; j &gt;, index_constant&lt; k &gt;, index_constant&lt; l &gt;... &gt;, i... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01449.html">TreePathPopFront&lt; HybridTreePath&lt; index_constant&lt; k &gt;, index_constant&lt; i &gt;... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01453.html">TreePathConcat&lt; HybridTreePath&lt; index_constant&lt; i &gt;... &gt;, HybridTreePath&lt; index_constant&lt; k &gt;... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01465.html">has_node_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01477.html">has_node_tag_value</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01493.html">has_implementation_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01505.html">has_implementation_tag_value</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01521.html">AlwaysVoid</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01525.html">meta_function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marker tag declaring a meta function.  <a href="a01525.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01529.html">lazy_evaluate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper meta function to delay evaluation of F.  <a href="a01529.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01533.html">lazy_identity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identity function.  <a href="a01533.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01537.html">evaluate_if_meta_function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function that evaluates its argument iff it inherits from <a class="el" href="a01525.html" title="Marker tag declaring a meta function.">meta_function</a>.  <a href="a01537.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01541.html">IsTreePath</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if type represents a tree path.  <a href="a01541.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01545.html">TreeInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct for obtaining some basic structural information about a <a class="el" href="a00098.html">TypeTree</a>.  <a href="a01545.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01557.html">DefaultVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor interface and base class for <a class="el" href="a00098.html">TypeTree</a> visitors.  <a href="a01557.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01561.html">DefaultPairVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor interface and base class for visitors of pairs of TypeTrees.  <a href="a01561.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01569.html">VisitDirectChildren</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mixin base class for visitors that only want to visit the direct children of a node.  <a href="a01569.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01577.html">VisitTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mixin base class for visitors that want to visit the complete tree.  <a href="a01577.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01585.html">StaticTraversal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mixin base class for visitors that require a static TreePath during traversal.  <a href="a01585.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01589.html">DynamicTraversal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mixin base class for visitors that only need a dynamic TreePath during traversal.  <a href="a01589.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01593.html">TreeVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience base class for visiting the entire tree.  <a href="a01593.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01597.html">DirectChildrenVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience base class for visiting the direct children of a node.  <a href="a01597.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01601.html">TreePairVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience base class for visiting an entire tree pair.  <a href="a01601.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01605.html">DirectChildrenPairVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience base class for visiting the direct children of a node pair.  <a href="a01605.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga8136d392450f4308b90a04a143e20feb"><td class="memTemplParams" colspan="2">template&lt;typename Node , std::size_t... indices&gt; </td></tr>
<tr class="memitem:ga8136d392450f4308b90a04a143e20feb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00092.html#ga8136d392450f4308b90a04a143e20feb">Child</a> = typename impl::_Child&lt; Node, indices... &gt;::type</td></tr>
<tr class="memdesc:ga8136d392450f4308b90a04a143e20feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template alias for the type of a child node given by a list of child indices.  <a href="a00092.html#ga8136d392450f4308b90a04a143e20feb">More...</a><br /></td></tr>
<tr class="separator:ga8136d392450f4308b90a04a143e20feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7126c2c9df855877ce3e71c77738398"><td class="memTemplParams" colspan="2">template&lt;typename Node , typename TreePath &gt; </td></tr>
<tr class="memitem:gac7126c2c9df855877ce3e71c77738398"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00092.html#gac7126c2c9df855877ce3e71c77738398">ChildForTreePath</a> = typename impl::_ChildForTreePath&lt; Node, <a class="el" href="a00094.html#gae8b7332de9e11aaed628b9b1e52384d3">TreePath</a> &gt;::type</td></tr>
<tr class="memdesc:gac7126c2c9df855877ce3e71c77738398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template alias for the type of a child node given by a TreePath or a <a class="el" href="a01381.html" title="A hybrid version of TreePath that supports both compile time and run time indices.">HybridTreePath</a> type.  <a href="a00092.html#gac7126c2c9df855877ce3e71c77738398">More...</a><br /></td></tr>
<tr class="separator:gac7126c2c9df855877ce3e71c77738398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5832a3bb33ab6b058aee3b201699584a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5832a3bb33ab6b058aee3b201699584a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00092.html#ga5832a3bb33ab6b058aee3b201699584a">is_flat_index</a> = typename impl::_is_flat_index&lt; std::decay_t&lt; T &gt; &gt;::type</td></tr>
<tr class="memdesc:ga5832a3bb33ab6b058aee3b201699584a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait that determines whether T is a flat index in the context of child extraction.  <a href="a00092.html#ga5832a3bb33ab6b058aee3b201699584a">More...</a><br /></td></tr>
<tr class="separator:ga5832a3bb33ab6b058aee3b201699584a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69a1959f7e199cc23ff490487dc683b9"><td class="memTemplParams" colspan="2">template&lt;typename Node &gt; </td></tr>
<tr class="memitem:ga69a1959f7e199cc23ff490487dc683b9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00093.html#ga69a1959f7e199cc23ff490487dc683b9">NodeTag</a> = typename std::decay_t&lt; Node &gt;::<a class="el" href="a00093.html#ga69a1959f7e199cc23ff490487dc683b9">NodeTag</a></td></tr>
<tr class="memdesc:ga69a1959f7e199cc23ff490487dc683b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node tag of the given Node.  <a href="a00093.html#ga69a1959f7e199cc23ff490487dc683b9">More...</a><br /></td></tr>
<tr class="separator:ga69a1959f7e199cc23ff490487dc683b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9fecf64a233645a10b181d50e519441"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab9fecf64a233645a10b181d50e519441"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00093.html#gab9fecf64a233645a10b181d50e519441">ImplementationTag</a> = typename std::decay_t&lt; T &gt;::<a class="el" href="a00093.html#gab9fecf64a233645a10b181d50e519441">ImplementationTag</a></td></tr>
<tr class="memdesc:gab9fecf64a233645a10b181d50e519441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the implementation tag of the given Node.  <a href="a00093.html#gab9fecf64a233645a10b181d50e519441">More...</a><br /></td></tr>
<tr class="separator:gab9fecf64a233645a10b181d50e519441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5f09e67114a2b620494f80cff734a02"><td class="memTemplParams" colspan="2">template&lt;typename Node &gt; </td></tr>
<tr class="memitem:gad5f09e67114a2b620494f80cff734a02"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00093.html#gad5f09e67114a2b620494f80cff734a02">StaticDegree</a> = decltype(Node::degree())</td></tr>
<tr class="memdesc:gad5f09e67114a2b620494f80cff734a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the statically known degree of the given Node type as a std::integral_constant.  <a href="a00093.html#gad5f09e67114a2b620494f80cff734a02">More...</a><br /></td></tr>
<tr class="separator:gad5f09e67114a2b620494f80cff734a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e7a9f48131918fa219eac08f77f7d29"><td class="memTemplParams" colspan="2">template&lt;class Value , class Tree &gt; </td></tr>
<tr class="memitem:ga3e7a9f48131918fa219eac08f77f7d29"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00090.html#ga3e7a9f48131918fa219eac08f77f7d29">UniformTreeContainer</a> = std::decay_t&lt; decltype(<a class="el" href="a00090.html#ga241c26f7d26dc7428cce30566d41c085">makeTreeContainer</a>&lt; Value &gt;(std::declval&lt; const Tree &amp; &gt;()))&gt;</td></tr>
<tr class="memdesc:ga3e7a9f48131918fa219eac08f77f7d29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to container type generated by makeTreeContainer for given tree type and uniform value type.  <a href="a00090.html#ga3e7a9f48131918fa219eac08f77f7d29">More...</a><br /></td></tr>
<tr class="separator:ga3e7a9f48131918fa219eac08f77f7d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7535d1bef6c77c758247e58c779f9b2"><td class="memTemplParams" colspan="2">template&lt;template&lt; class Node &gt; class LeafToValue, class Tree &gt; </td></tr>
<tr class="memitem:gab7535d1bef6c77c758247e58c779f9b2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00090.html#gab7535d1bef6c77c758247e58c779f9b2">TreeContainer</a> = std::decay_t&lt; decltype(<a class="el" href="a00090.html#ga241c26f7d26dc7428cce30566d41c085">makeTreeContainer</a>(std::declval&lt; const Tree &amp; &gt;(), std::declval&lt; <a class="el" href="a01377.html">Detail::LeafToDefaultConstructibleValue</a>&lt; LeafToValue &gt; &gt;()))&gt;</td></tr>
<tr class="memdesc:gab7535d1bef6c77c758247e58c779f9b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to container type generated by makeTreeContainer for give tree type and when using LeafToValue to create values.  <a href="a00090.html#gab7535d1bef6c77c758247e58c779f9b2">More...</a><br /></td></tr>
<tr class="separator:gab7535d1bef6c77c758247e58c779f9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8b7332de9e11aaed628b9b1e52384d3"><td class="memTemplParams" colspan="2">template&lt;std::size_t... i&gt; </td></tr>
<tr class="memitem:gae8b7332de9e11aaed628b9b1e52384d3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00094.html#gae8b7332de9e11aaed628b9b1e52384d3">TreePath</a> = <a class="el" href="a01381.html">HybridTreePath</a>&lt; Dune::index_constant&lt; i &gt;... &gt;</td></tr>
<tr class="separator:gae8b7332de9e11aaed628b9b1e52384d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5777c11461f29c81c8d2440ed36dca12"><td class="memTemplParams" colspan="2">template&lt;std::size_t... i&gt; </td></tr>
<tr class="memitem:ga5777c11461f29c81c8d2440ed36dca12"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00094.html#ga5777c11461f29c81c8d2440ed36dca12">StaticTreePath</a> = <a class="el" href="a01381.html">HybridTreePath</a>&lt; Dune::index_constant&lt; i &gt;... &gt;</td></tr>
<tr class="separator:ga5777c11461f29c81c8d2440ed36dca12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab8f2fef526363564e7bbe91daad49b9b"><td class="memTemplParams" colspan="2">template&lt;typename Node , typename... Indices&gt; </td></tr>
<tr class="memitem:gab8f2fef526363564e7bbe91daad49b9b"><td class="memTemplItemLeft" align="right" valign="top">ImplementationDefined&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00092.html#gab8f2fef526363564e7bbe91daad49b9b">child</a> (Node &amp;&amp;node, Indices... indices)</td></tr>
<tr class="memdesc:gab8f2fef526363564e7bbe91daad49b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the child of a node given by a sequence of compile-time and run-time indices.  <a href="a00092.html#gab8f2fef526363564e7bbe91daad49b9b">More...</a><br /></td></tr>
<tr class="separator:gab8f2fef526363564e7bbe91daad49b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d60a84ddd0be65b0cae4a5e6032a52a"><td class="memTemplParams" colspan="2">template&lt;typename Node , typename... Indices&gt; </td></tr>
<tr class="memitem:ga6d60a84ddd0be65b0cae4a5e6032a52a"><td class="memTemplItemLeft" align="right" valign="top">ImplementationDefined&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00092.html#ga6d60a84ddd0be65b0cae4a5e6032a52a">childStorage</a> (Node &amp;&amp;node, Indices... indices)</td></tr>
<tr class="separator:ga6d60a84ddd0be65b0cae4a5e6032a52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4133f4dba113143455fcab49d8a103e"><td class="memTemplParams" colspan="2">template&lt;typename Node , typename... Indices&gt; </td></tr>
<tr class="memitem:gae4133f4dba113143455fcab49d8a103e"><td class="memTemplItemLeft" align="right" valign="top">ImplementationDefined&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00092.html#gae4133f4dba113143455fcab49d8a103e">child</a> (Node &amp;&amp;node, <a class="el" href="a01381.html">HybridTreePath</a>&lt; Indices... &gt; <a class="el" href="a00094.html#ga7151438fa6a456a95fe90029f28fae49">treePath</a>)</td></tr>
<tr class="memdesc:gae4133f4dba113143455fcab49d8a103e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the child of a node given by a <a class="el" href="a01381.html" title="A hybrid version of TreePath that supports both compile time and run time indices.">HybridTreePath</a> object.  <a href="a00092.html#gae4133f4dba113143455fcab49d8a103e">More...</a><br /></td></tr>
<tr class="separator:gae4133f4dba113143455fcab49d8a103e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56ec139aa8b8af4e8fd25d3b31b970cd"><td class="memTemplParams" colspan="2">template&lt;typename Node &gt; </td></tr>
<tr class="memitem:ga56ec139aa8b8af4e8fd25d3b31b970cd"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00093.html#ga56ec139aa8b8af4e8fd25d3b31b970cd">degree</a> (const Node &amp;node)</td></tr>
<tr class="memdesc:ga56ec139aa8b8af4e8fd25d3b31b970cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the degree of node as run time information.  <a href="a00093.html#ga56ec139aa8b8af4e8fd25d3b31b970cd">More...</a><br /></td></tr>
<tr class="separator:ga56ec139aa8b8af4e8fd25d3b31b970cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga677ef3ed3418747507fd30687854f5c4"><td class="memTemplParams" colspan="2">template&lt;typename Tree1 , typename Tree2 , typename Visitor &gt; </td></tr>
<tr class="memitem:ga677ef3ed3418747507fd30687854f5c4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00091.html#ga677ef3ed3418747507fd30687854f5c4">applyToTreePair</a> (Tree1 &amp;&amp;tree1, Tree2 &amp;&amp;tree2, Visitor &amp;&amp;visitor)</td></tr>
<tr class="memdesc:ga677ef3ed3418747507fd30687854f5c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply visitor to a pair of TypeTrees.  <a href="a00091.html#ga677ef3ed3418747507fd30687854f5c4">More...</a><br /></td></tr>
<tr class="separator:ga677ef3ed3418747507fd30687854f5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48cffe31075a96776d284a184097a2aa"><td class="memTemplParams" colspan="2">template&lt;typename SourceNode , typename Transformation , typename Tag &gt; </td></tr>
<tr class="memitem:ga48cffe31075a96776d284a184097a2aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00095.html#ga48cffe31075a96776d284a184097a2aa">registerNodeTransformation</a> (SourceNode *, Transformation *, Tag *)</td></tr>
<tr class="memdesc:ga48cffe31075a96776d284a184097a2aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register transformation descriptor to transform SourceNode with Transformation.  <a href="a00095.html#ga48cffe31075a96776d284a184097a2aa">More...</a><br /></td></tr>
<tr class="separator:ga48cffe31075a96776d284a184097a2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40f2a5d5435d0ae5ff375e2d54beb973"><td class="memTemplParams" colspan="2">template&lt;class Tree , TreePathType::Type pathType = TreePathType::dynamic&gt; </td></tr>
<tr class="memitem:ga40f2a5d5435d0ae5ff375e2d54beb973"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00091.html#ga40f2a5d5435d0ae5ff375e2d54beb973">leafTreePathTuple</a> ()</td></tr>
<tr class="memdesc:ga40f2a5d5435d0ae5ff375e2d54beb973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create tuple of tree paths to leafs.  <a href="a00091.html#ga40f2a5d5435d0ae5ff375e2d54beb973">More...</a><br /></td></tr>
<tr class="separator:ga40f2a5d5435d0ae5ff375e2d54beb973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafebbce1d18f7ddd62e267df3de139334"><td class="memTemplParams" colspan="2">template&lt;typename Tree , typename Visitor &gt; </td></tr>
<tr class="memitem:gafebbce1d18f7ddd62e267df3de139334"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00091.html#gafebbce1d18f7ddd62e267df3de139334">applyToTree</a> (Tree &amp;&amp;tree, Visitor &amp;&amp;visitor)</td></tr>
<tr class="memdesc:gafebbce1d18f7ddd62e267df3de139334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply visitor to <a class="el" href="a00098.html">TypeTree</a>.  <a href="a00091.html#gafebbce1d18f7ddd62e267df3de139334">More...</a><br /></td></tr>
<tr class="separator:gafebbce1d18f7ddd62e267df3de139334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34c3cff4dfdb9a5288c2d9109cafea00"><td class="memTemplParams" colspan="2">template&lt;class Tree , class PreFunc , class LeafFunc , class PostFunc &gt; </td></tr>
<tr class="memitem:ga34c3cff4dfdb9a5288c2d9109cafea00"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00091.html#ga34c3cff4dfdb9a5288c2d9109cafea00">forEachNode</a> (Tree &amp;&amp;tree, PreFunc &amp;&amp;preFunc, LeafFunc &amp;&amp;leafFunc, PostFunc &amp;&amp;postFunc)</td></tr>
<tr class="memdesc:ga34c3cff4dfdb9a5288c2d9109cafea00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse tree and visit each node.  <a href="a00091.html#ga34c3cff4dfdb9a5288c2d9109cafea00">More...</a><br /></td></tr>
<tr class="separator:ga34c3cff4dfdb9a5288c2d9109cafea00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dc67191859047ac5da055c0e5cea67d"><td class="memTemplParams" colspan="2">template&lt;class Tree , class InnerFunc , class LeafFunc &gt; </td></tr>
<tr class="memitem:ga3dc67191859047ac5da055c0e5cea67d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00091.html#ga3dc67191859047ac5da055c0e5cea67d">forEachNode</a> (Tree &amp;&amp;tree, InnerFunc &amp;&amp;innerFunc, LeafFunc &amp;&amp;leafFunc)</td></tr>
<tr class="memdesc:ga3dc67191859047ac5da055c0e5cea67d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse tree and visit each node.  <a href="a00091.html#ga3dc67191859047ac5da055c0e5cea67d">More...</a><br /></td></tr>
<tr class="separator:ga3dc67191859047ac5da055c0e5cea67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29b6b44967c09f379358b0264124c0a7"><td class="memTemplParams" colspan="2">template&lt;class Tree , class NodeFunc &gt; </td></tr>
<tr class="memitem:ga29b6b44967c09f379358b0264124c0a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00091.html#ga29b6b44967c09f379358b0264124c0a7">forEachNode</a> (Tree &amp;&amp;tree, NodeFunc &amp;&amp;nodeFunc)</td></tr>
<tr class="memdesc:ga29b6b44967c09f379358b0264124c0a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse tree and visit each node.  <a href="a00091.html#ga29b6b44967c09f379358b0264124c0a7">More...</a><br /></td></tr>
<tr class="separator:ga29b6b44967c09f379358b0264124c0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2f9c441b6882fcd11419500df8a56ec"><td class="memTemplParams" colspan="2">template&lt;class Tree , class LeafFunc &gt; </td></tr>
<tr class="memitem:gad2f9c441b6882fcd11419500df8a56ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00091.html#gad2f9c441b6882fcd11419500df8a56ec">forEachLeafNode</a> (Tree &amp;&amp;tree, LeafFunc &amp;&amp;leafFunc)</td></tr>
<tr class="memdesc:gad2f9c441b6882fcd11419500df8a56ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse tree and visit each leaf node.  <a href="a00091.html#gad2f9c441b6882fcd11419500df8a56ec">More...</a><br /></td></tr>
<tr class="separator:gad2f9c441b6882fcd11419500df8a56ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab407f8e914f8fa3fee78d35a102e2693"><td class="memTemplParams" colspan="2">template&lt;typename ResultType , typename Tree , typename F , typename R &gt; </td></tr>
<tr class="memitem:gab407f8e914f8fa3fee78d35a102e2693"><td class="memTemplItemLeft" align="right" valign="top">ResultType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00091.html#gab407f8e914f8fa3fee78d35a102e2693">reduceOverLeafs</a> (const Tree &amp;tree, F functor, R reduction, ResultType startValue)</td></tr>
<tr class="memdesc:gab407f8e914f8fa3fee78d35a102e2693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a quantity as a reduction over the leaf nodes of a <a class="el" href="a00098.html">TypeTree</a>.  <a href="a00091.html#gab407f8e914f8fa3fee78d35a102e2693">More...</a><br /></td></tr>
<tr class="separator:gab407f8e914f8fa3fee78d35a102e2693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga241c26f7d26dc7428cce30566d41c085"><td class="memTemplParams" colspan="2">template&lt;class Tree , class LeafToValue &gt; </td></tr>
<tr class="memitem:ga241c26f7d26dc7428cce30566d41c085"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00090.html#ga241c26f7d26dc7428cce30566d41c085">makeTreeContainer</a> (const Tree &amp;tree, LeafToValue &amp;&amp;leafToValue)</td></tr>
<tr class="memdesc:ga241c26f7d26dc7428cce30566d41c085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create container havin the same structure as the given tree.  <a href="a00090.html#ga241c26f7d26dc7428cce30566d41c085">More...</a><br /></td></tr>
<tr class="separator:ga241c26f7d26dc7428cce30566d41c085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeba09096f7d6149b08123f545eaccc85"><td class="memTemplParams" colspan="2">template&lt;class Value , class Tree &gt; </td></tr>
<tr class="memitem:gaeba09096f7d6149b08123f545eaccc85"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00090.html#gaeba09096f7d6149b08123f545eaccc85">makeTreeContainer</a> (const Tree &amp;tree)</td></tr>
<tr class="memdesc:gaeba09096f7d6149b08123f545eaccc85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create container havin the same structure as the given tree.  <a href="a00090.html#gaeba09096f7d6149b08123f545eaccc85">More...</a><br /></td></tr>
<tr class="separator:gaeba09096f7d6149b08123f545eaccc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb32e41118574398d079d0a22a5e1f80"><td class="memTemplParams" colspan="2">template&lt;std::size_t... i&gt; </td></tr>
<tr class="memitem:gaeb32e41118574398d079d0a22a5e1f80"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00094.html#gaeb32e41118574398d079d0a22a5e1f80">print_tree_path</a> (std::ostream &amp;os)</td></tr>
<tr class="separator:gaeb32e41118574398d079d0a22a5e1f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3668be2162ed006dbd170855d7ef042"><td class="memTemplParams" colspan="2">template&lt;std::size_t k, std::size_t... i&gt; </td></tr>
<tr class="memitem:gaa3668be2162ed006dbd170855d7ef042"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00094.html#gaa3668be2162ed006dbd170855d7ef042">print_tree_path</a> (std::ostream &amp;os)</td></tr>
<tr class="separator:gaa3668be2162ed006dbd170855d7ef042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cdc358a3da2f3ada59ae8565473e71f"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ga9cdc358a3da2f3ada59ae8565473e71f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a01381.html">HybridTreePath</a>&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00094.html#ga9cdc358a3da2f3ada59ae8565473e71f">hybridTreePath</a> (const T &amp;... t)</td></tr>
<tr class="memdesc:ga9cdc358a3da2f3ada59ae8565473e71f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new <code><a class="el" href="a01381.html" title="A hybrid version of TreePath that supports both compile time and run time indices.">HybridTreePath</a></code> from the given indices.  <a href="a00094.html#ga9cdc358a3da2f3ada59ae8565473e71f">More...</a><br /></td></tr>
<tr class="separator:ga9cdc358a3da2f3ada59ae8565473e71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7151438fa6a456a95fe90029f28fae49"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ga7151438fa6a456a95fe90029f28fae49"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a01381.html">HybridTreePath</a>&lt; T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00094.html#ga7151438fa6a456a95fe90029f28fae49">treePath</a> (const T &amp;... t)</td></tr>
<tr class="memdesc:ga7151438fa6a456a95fe90029f28fae49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new <code><a class="el" href="a01381.html" title="A hybrid version of TreePath that supports both compile time and run time indices.">HybridTreePath</a></code> from the given indices.  <a href="a00094.html#ga7151438fa6a456a95fe90029f28fae49">More...</a><br /></td></tr>
<tr class="separator:ga7151438fa6a456a95fe90029f28fae49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15a231b783d71e9daa350133a71b2b53"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ga15a231b783d71e9daa350133a71b2b53"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00094.html#ga15a231b783d71e9daa350133a71b2b53">treePathSize</a> (const <a class="el" href="a01381.html">HybridTreePath</a>&lt; T... &gt; &amp;)</td></tr>
<tr class="memdesc:ga15a231b783d71e9daa350133a71b2b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size (number of components) of the given <code><a class="el" href="a01381.html" title="A hybrid version of TreePath that supports both compile time and run time indices.">HybridTreePath</a></code>.  <a href="a00094.html#ga15a231b783d71e9daa350133a71b2b53">More...</a><br /></td></tr>
<tr class="separator:ga15a231b783d71e9daa350133a71b2b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e3abac9bca53b1cf72a5a0354b36908"><td class="memTemplParams" colspan="2">template&lt;std::size_t i, typename... T&gt; </td></tr>
<tr class="memitem:ga6e3abac9bca53b1cf72a5a0354b36908"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00094.html#ga6e3abac9bca53b1cf72a5a0354b36908">treePathEntry</a> (const <a class="el" href="a01381.html">HybridTreePath</a>&lt; T... &gt; &amp;tp, index_constant&lt; i &gt;={}) -&gt; typename std::decay&lt; decltype(std::get&lt; i &gt;(tp._data))&gt;::type</td></tr>
<tr class="memdesc:ga6e3abac9bca53b1cf72a5a0354b36908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the i-th element of the <code><a class="el" href="a01381.html" title="A hybrid version of TreePath that supports both compile time and run time indices.">HybridTreePath</a></code>.  <a href="a00094.html#ga6e3abac9bca53b1cf72a5a0354b36908">More...</a><br /></td></tr>
<tr class="separator:ga6e3abac9bca53b1cf72a5a0354b36908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93fde33df04c0302b1efa4363b4741ab"><td class="memTemplParams" colspan="2">template&lt;std::size_t i, typename... T&gt; </td></tr>
<tr class="memitem:ga93fde33df04c0302b1efa4363b4741ab"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00094.html#ga93fde33df04c0302b1efa4363b4741ab">treePathIndex</a> (const <a class="el" href="a01381.html">HybridTreePath</a>&lt; T... &gt; &amp;tp, index_constant&lt; i &gt;={})</td></tr>
<tr class="memdesc:ga93fde33df04c0302b1efa4363b4741ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index value of the i-th element of the <code><a class="el" href="a01381.html" title="A hybrid version of TreePath that supports both compile time and run time indices.">HybridTreePath</a></code>.  <a href="a00094.html#ga93fde33df04c0302b1efa4363b4741ab">More...</a><br /></td></tr>
<tr class="separator:ga93fde33df04c0302b1efa4363b4741ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cc0ebfc16a54124ef87684a71d7a834"><td class="memTemplParams" colspan="2">template&lt;typename... T, typename std::enable_if&lt;(sizeof...(T) &gt; 0), bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:ga0cc0ebfc16a54124ef87684a71d7a834"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00094.html#ga0cc0ebfc16a54124ef87684a71d7a834">back</a> (const <a class="el" href="a01381.html">HybridTreePath</a>&lt; T... &gt; &amp;tp) -&gt; decltype(<a class="el" href="a00094.html#ga6e3abac9bca53b1cf72a5a0354b36908">treePathEntry</a>&lt; sizeof...(T) -1 &gt;(tp))</td></tr>
<tr class="memdesc:ga0cc0ebfc16a54124ef87684a71d7a834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the last element of the <code><a class="el" href="a01381.html" title="A hybrid version of TreePath that supports both compile time and run time indices.">HybridTreePath</a></code>.  <a href="a00094.html#ga0cc0ebfc16a54124ef87684a71d7a834">More...</a><br /></td></tr>
<tr class="separator:ga0cc0ebfc16a54124ef87684a71d7a834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55a683d97c17c93630e8bdf30b435155"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ga55a683d97c17c93630e8bdf30b435155"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00094.html#ga55a683d97c17c93630e8bdf30b435155">front</a> (const <a class="el" href="a01381.html">HybridTreePath</a>&lt; T... &gt; &amp;tp) -&gt; decltype(<a class="el" href="a00094.html#ga6e3abac9bca53b1cf72a5a0354b36908">treePathEntry</a>&lt; 0 &gt;(tp))</td></tr>
<tr class="memdesc:ga55a683d97c17c93630e8bdf30b435155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the first element of the <code><a class="el" href="a01381.html" title="A hybrid version of TreePath that supports both compile time and run time indices.">HybridTreePath</a></code>.  <a href="a00094.html#ga55a683d97c17c93630e8bdf30b435155">More...</a><br /></td></tr>
<tr class="separator:ga55a683d97c17c93630e8bdf30b435155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6381a6598524f8142e8666469fee975"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:gaa6381a6598524f8142e8666469fee975"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a01381.html">HybridTreePath</a>&lt; T..., std::size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00094.html#gaa6381a6598524f8142e8666469fee975">push_back</a> (const <a class="el" href="a01381.html">HybridTreePath</a>&lt; T... &gt; &amp;tp, std::size_t i)</td></tr>
<tr class="memdesc:gaa6381a6598524f8142e8666469fee975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a run time index to a <code><a class="el" href="a01381.html" title="A hybrid version of TreePath that supports both compile time and run time indices.">HybridTreePath</a></code>.  <a href="a00094.html#gaa6381a6598524f8142e8666469fee975">More...</a><br /></td></tr>
<tr class="separator:gaa6381a6598524f8142e8666469fee975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ff30a1176b31b4dd62201ea80176b35"><td class="memTemplParams" colspan="2">template&lt;std::size_t i, typename... T&gt; </td></tr>
<tr class="memitem:ga4ff30a1176b31b4dd62201ea80176b35"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a01381.html">HybridTreePath</a>&lt; T..., index_constant&lt; i &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00094.html#ga4ff30a1176b31b4dd62201ea80176b35">push_back</a> (const <a class="el" href="a01381.html">HybridTreePath</a>&lt; T... &gt; &amp;tp, index_constant&lt; i &gt; i_={})</td></tr>
<tr class="memdesc:ga4ff30a1176b31b4dd62201ea80176b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a compile time index to a <code><a class="el" href="a01381.html" title="A hybrid version of TreePath that supports both compile time and run time indices.">HybridTreePath</a></code>.  <a href="a00094.html#ga4ff30a1176b31b4dd62201ea80176b35">More...</a><br /></td></tr>
<tr class="separator:ga4ff30a1176b31b4dd62201ea80176b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5121951e36f1894d04c4e17286d59c5"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:gaa5121951e36f1894d04c4e17286d59c5"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a01381.html">HybridTreePath</a>&lt; std::size_t, T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00094.html#gaa5121951e36f1894d04c4e17286d59c5">push_front</a> (const <a class="el" href="a01381.html">HybridTreePath</a>&lt; T... &gt; &amp;tp, std::size_t element)</td></tr>
<tr class="memdesc:gaa5121951e36f1894d04c4e17286d59c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepends a run time index to a <code><a class="el" href="a01381.html" title="A hybrid version of TreePath that supports both compile time and run time indices.">HybridTreePath</a></code>.  <a href="a00094.html#gaa5121951e36f1894d04c4e17286d59c5">More...</a><br /></td></tr>
<tr class="separator:gaa5121951e36f1894d04c4e17286d59c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6911aa2f6b5c8b6eccc66c5ad20ae7c8"><td class="memTemplParams" colspan="2">template&lt;std::size_t i, typename... T&gt; </td></tr>
<tr class="memitem:ga6911aa2f6b5c8b6eccc66c5ad20ae7c8"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a01381.html">HybridTreePath</a>&lt; index_constant&lt; i &gt;, T... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00094.html#ga6911aa2f6b5c8b6eccc66c5ad20ae7c8">push_front</a> (const <a class="el" href="a01381.html">HybridTreePath</a>&lt; T... &gt; &amp;tp, index_constant&lt; i &gt; _i={})</td></tr>
<tr class="memdesc:ga6911aa2f6b5c8b6eccc66c5ad20ae7c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepends a compile time index to a <code><a class="el" href="a01381.html" title="A hybrid version of TreePath that supports both compile time and run time indices.">HybridTreePath</a></code>.  <a href="a00094.html#ga6911aa2f6b5c8b6eccc66c5ad20ae7c8">More...</a><br /></td></tr>
<tr class="separator:ga6911aa2f6b5c8b6eccc66c5ad20ae7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga593153c1cb9e22708afa50b4116a04fd"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ga593153c1cb9e22708afa50b4116a04fd"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00094.html#ga593153c1cb9e22708afa50b4116a04fd">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="a01381.html">HybridTreePath</a>&lt; T... &gt; &amp;tp)</td></tr>
<tr class="memdesc:ga593153c1cb9e22708afa50b4116a04fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps a <code><a class="el" href="a01381.html" title="A hybrid version of TreePath that supports both compile time and run time indices.">HybridTreePath</a></code> to a stream.  <a href="a00094.html#ga593153c1cb9e22708afa50b4116a04fd">More...</a><br /></td></tr>
<tr class="separator:ga593153c1cb9e22708afa50b4116a04fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf44168c49c708a98dcb7d7bd494d6eb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abf44168c49c708a98dcb7d7bd494d6eb"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00098.html#abf44168c49c708a98dcb7d7bd494d6eb">declptr</a> ()</td></tr>
<tr class="memdesc:abf44168c49c708a98dcb7d7bd494d6eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for generating a pointer to a value of type T in an unevaluated operand setting.  <a href="a00098.html#abf44168c49c708a98dcb7d7bd494d6eb">More...</a><br /></td></tr>
<tr class="separator:abf44168c49c708a98dcb7d7bd494d6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f06f53488df709cddad40051120e058"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9f06f53488df709cddad40051120e058"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00098.html#a9f06f53488df709cddad40051120e058">isTreePath</a> (const T &amp;) -&gt; <a class="el" href="a01541.html">IsTreePath</a>&lt; T &gt;</td></tr>
<tr class="memdesc:a9f06f53488df709cddad40051120e058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if given object represents a tree path.  <a href="a00098.html#a9f06f53488df709cddad40051120e058">More...</a><br /></td></tr>
<tr class="separator:a9f06f53488df709cddad40051120e058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa861d23cc92a6317f2fd5521a2781be6"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:gaa861d23cc92a6317f2fd5521a2781be6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00090.html#gaa861d23cc92a6317f2fd5521a2781be6">discard</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:gaa861d23cc92a6317f2fd5521a2781be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">No-op function to make calling a function on a variadic template argument pack legal C++.  <a href="a00090.html#gaa861d23cc92a6317f2fd5521a2781be6">More...</a><br /></td></tr>
<tr class="separator:gaa861d23cc92a6317f2fd5521a2781be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74366514796c2f1ee6a2f8a41fdd8e90"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F , typename Policy &gt; </td></tr>
<tr class="memitem:ga74366514796c2f1ee6a2f8a41fdd8e90"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00090.html#ga74366514796c2f1ee6a2f8a41fdd8e90">apply_to_tuple</a> (T &amp;&amp;t, F &amp;&amp;f, Policy=<a class="el" href="a00107.html#afa02522e9be69e1950f07311993edbc6">apply_to_tuple_policy::default_policy</a>())</td></tr>
<tr class="memdesc:ga74366514796c2f1ee6a2f8a41fdd8e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a functor to each element of a std::tuple.  <a href="a00090.html#ga74366514796c2f1ee6a2f8a41fdd8e90">More...</a><br /></td></tr>
<tr class="separator:ga74366514796c2f1ee6a2f8a41fdd8e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="abf44168c49c708a98dcb7d7bd494d6eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf44168c49c708a98dcb7d7bd494d6eb">&#9670;&nbsp;</a></span>declptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* Dune::TypeTree::declptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function for generating a pointer to a value of type T in an unevaluated operand setting. </p>

</div>
</div>
<a id="a9f06f53488df709cddad40051120e058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f06f53488df709cddad40051120e058">&#9670;&nbsp;</a></span>isTreePath()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto Dune::TypeTree::isTreePath </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="a01541.html">IsTreePath</a>&lt;T&gt;
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if given object represents a tree path. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Check if this type represents a tree path </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::true_type if argument is a tree path and std::false_type if not </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
